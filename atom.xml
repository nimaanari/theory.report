<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title>Theory of Computing Report</title>
  <link rel="self" href=""/>
  <link href=""/>
  <id></id>
  <updated></updated>
  <generator uri="http://feedreader.github.io/">Pluto 1.6.2 on Ruby 3.0.4 (2022-04-12) [x86_64-linux]</generator>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Computational Complexity: Polynomial computational complexity of matrix elements of finite-rank-generated single-particle operators in products of finite bosonic states</title>
    <link href="http://arxiv.org/abs/2210.11568"/>
    <id>http://arxiv.org/abs/2210.11568</id>
    <updated>2022-10-24T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/quant-ph/1/au:+Ivanov_D/0/1/0/all/0/1&quot;&gt;Dmitri A. Ivanov&lt;/a&gt;&lt;/p&gt;&lt;p&gt;It is known that computing the permanent $\mathop{\rm Per}(1+A)$, where $A$
is a finite-rank matrix requires a number of operations polynomial in the
matrix size. I generalize this result to the expectation values
$\left\langle\Psi| P(1+A) |\Psi\right\rangle$, where $P()$ is the
multiplicative extension of a single-particle operator and
$\left|\Psi\right\rangle$ is a product of a large number of identical finite
bosonic states (i.e. bosonic states with a bounded number of bosons). I also
improve an earlier polynomial estimate for the fermionic version of the same
problem.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Computational Complexity</name>
      <uri>https://arxiv.org/list/cs.CC/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Computational Geometry: On the Longest Flip Sequence to Untangle Segments in the Plane</title>
    <link href="http://arxiv.org/abs/2210.12036"/>
    <id>http://arxiv.org/abs/2210.12036</id>
    <updated>2022-10-24T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Fonseca_G/0/1/0/all/0/1&quot;&gt;Guilherme D. da Fonseca&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Gerard_Y/0/1/0/all/0/1&quot;&gt;Yan Gerard&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Rivier_B/0/1/0/all/0/1&quot;&gt;Bastien Rivier&lt;/a&gt;&lt;/p&gt;&lt;p&gt;A set of segments in the plane may form a Euclidean TSP tour or a matching.
Optimal TSP tours as well as minimum weight perfect matchings have no crossing
segments, but several heuristics and approximation algorithms may produce
solutions with crossings. To improve such solutions, we can successively apply
a flip operation that replaces a pair of crossing segments by non-crossing
ones. This paper considers the maximum number D(n) of flips performed on n
segments. First, we present reductions relating D(n) for different versions of
matchings and the TSP tour. Second, we show that if all except t points are in
convex position, then D(n) = O(tn^2), providing a smooth transition between the
convex O(n^2) bound and the general O(n^3) bound. Last, we show that if instead
of counting the total number of flips, we only count the number of distinct
flips, then the cubic upper bound improves to O(n^{8/3}).
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Computational Geometry</name>
      <uri>https://arxiv.org/list/cs.CG/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Computational Geometry: Blocking Delaunay Triangulations from the Exterior</title>
    <link href="http://arxiv.org/abs/2210.12015"/>
    <id>http://arxiv.org/abs/2210.12015</id>
    <updated>2022-10-24T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Aichholzer_O/0/1/0/all/0/1&quot;&gt;Oswin Aichholzer&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Hackl_T/0/1/0/all/0/1&quot;&gt;Thomas Hackl&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Loffler_M/0/1/0/all/0/1&quot;&gt;Maarten L&amp;#xf6;ffler&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Pilz_A/0/1/0/all/0/1&quot;&gt;Alexander Pilz&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Parada_I/0/1/0/all/0/1&quot;&gt;Irene Parada&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Scheucher_M/0/1/0/all/0/1&quot;&gt;Manfred Scheucher&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Vogtenhuber_B/0/1/0/all/0/1&quot;&gt;Birgit Vogtenhuber&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Given two distinct point sets $P$ and $Q$ in the plane, we say that $Q$
\emph{blocks} $P$ if no two points of $P$ are adjacent in any Delaunay
triangulation of $P\cup Q$. Aichholzer et al. (2013) showed that any set $P$ of
$n$ points in general position can be blocked by $\frac{3}{2}n$ points and that
every set $P$ of $n$ points in convex position can be blocked by $\frac{5}{4}n$
points. Moreover, they conjectured that, if $P$ is in convex position, $n$
blocking points are sufficient and necessary. The necessity was recently shown
by Biniaz (2021) who proved that every point set in general position requires
$n$ blocking points.
&lt;/p&gt;
&lt;p&gt;Here we investigate the variant, where blocking points can only lie outside
of the convex hull of the given point set. We show that $\frac{5}{4}n-O(1)$
such \emph{exterior-blocking} points are sometimes necessary, even if the given
point set is in convex position. As a consequence we obtain that, if the
conjecture of Aichholzer et al. for the original setting was true, then minimal
blocking sets of some point configurations $P$ would have to contain points
inside of the convex hull of $P$.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Computational Geometry</name>
      <uri>https://arxiv.org/list/cs.CG/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: Rerouting Planar Curves and Disjoint Paths</title>
    <link href="http://arxiv.org/abs/2210.11778"/>
    <id>http://arxiv.org/abs/2210.11778</id>
    <updated>2022-10-24T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Ito_T/0/1/0/all/0/1&quot;&gt;Takehiro Ito&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Iwamasa_Y/0/1/0/all/0/1&quot;&gt;Yuni Iwamasa&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Kakimura_N/0/1/0/all/0/1&quot;&gt;Naonori Kakimura&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Kobayashi_Y/0/1/0/all/0/1&quot;&gt;Yusuke Kobayashi&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Maezawa_S/0/1/0/all/0/1&quot;&gt;Shun-ichi Maezawa&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Nozaki_Y/0/1/0/all/0/1&quot;&gt;Yuta Nozaki&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Okamoto_Y/0/1/0/all/0/1&quot;&gt;Yoshio Okamoto&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Ozeki_K/0/1/0/all/0/1&quot;&gt;Kenta Ozeki&lt;/a&gt;&lt;/p&gt;&lt;p&gt;In this paper, we consider a transformation of $k$ disjoint paths in a graph.
For a graph and a pair of $k$ disjoint paths $\mathcal{P}$ and $\mathcal{Q}$
connecting the same set of terminal pairs, we aim to determine whether
$\mathcal{P}$ can be transformed to $\mathcal{Q}$ by repeatedly replacing one
path with another path so that the intermediates are also $k$ disjoint paths.
The problem is called Disjoint Paths Reconfiguration. We first show that
Disjoint Paths Reconfiguration is PSPACE-complete even when $k=2$. On the other
hand, we prove that, when the graph is embedded on a plane and all paths in
$\mathcal{P}$ and $\mathcal{Q}$ connect the boundaries of two faces, Disjoint
Paths Reconfiguration can be solved in polynomial time. The algorithm is based
on a topological characterization for rerouting curves on a plane using the
algebraic intersection number. We also consider a transformation of disjoint
$s$-$t$ paths as a variant. We show that the disjoint $s$-$t$ paths
reconfiguration problem in planar graphs can be determined in polynomial time,
while the problem is PSPACE-complete in general.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: Sketching Meets Differential Privacy: Fast Algorithm for Dynamic Kronecker Projection Maintenance</title>
    <link href="http://arxiv.org/abs/2210.11542"/>
    <id>http://arxiv.org/abs/2210.11542</id>
    <updated>2022-10-24T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Song_Z/0/1/0/all/0/1&quot;&gt;Zhao Song&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Yang_X/0/1/0/all/0/1&quot;&gt;Xin Yang&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Yang_Y/0/1/0/all/0/1&quot;&gt;Yuanyuan Yang&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Zhang_L/0/1/0/all/0/1&quot;&gt;Lichen Zhang&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Projection maintenance is one of the core data structure tasks. Efficient
data structures for projection maintenance have led to recent breakthroughs in
many convex programming algorithms. In this work, we further extend this
framework to the Kronecker product structure. Given a constraint matrix ${\sf
A}$ and a positive semi-definite matrix $W\in \mathbb{R}^{n\times n}$ with a
sparse eigenbasis, we consider the task of maintaining the projection in the
form of ${\sf B}^\top({\sf B}{\sf B}^\top)^{-1}{\sf B}$, where ${\sf B}={\sf
A}(W\otimes I)$ or ${\sf B}={\sf A}(W^{1/2}\otimes W^{1/2})$. At each
iteration, the weight matrix $W$ receives a low rank change and we receive a
new vector $h$. The goal is to maintain the projection matrix and answer the
query ${\sf B}^\top({\sf B}{\sf B}^\top)^{-1}{\sf B}h$ with good approximation
guarantees. We design a fast dynamic data structure for this task and it is
robust against an adaptive adversary. Following the work of [Beimel, Kaplan,
Mansour, Nissim, Saranurak and Stemmer, STOC&#39;22], we use tools from
differential privacy to reduce the randomness required by the data structure
and further improve the running time.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: Online Resource Allocation with Buyback: Optimal Algorithms via Primal-Dual</title>
    <link href="http://arxiv.org/abs/2210.11570"/>
    <id>http://arxiv.org/abs/2210.11570</id>
    <updated>2022-10-24T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Ekbatani_F/0/1/0/all/0/1&quot;&gt;Farbod Ekbatani&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Feng_Y/0/1/0/all/0/1&quot;&gt;Yiding Feng&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Niazadeh_R/0/1/0/all/0/1&quot;&gt;Rad Niazadeh&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Motivated by applications in cloud computing spot markets and selling banner
ads on popular websites, we study the online resource allocation problem with
&quot;costly buyback&quot;. To model this problem, we consider the classic edge-weighted
fractional online matching problem with a tweak, where the decision maker can
recall (i.e., buyback) any fraction of an offline resource that is
pre-allocated to an earlier online vertex; however, by doing so not only the
decision maker loses the previously allocated reward (which equates the
edge-weight), it also has to pay a non-negative constant factor $f$ of this
edge-weight as an extra penalty. Parameterizing the problem by the buyback
factor $f$, our main result is obtaining optimal competitive algorithms for all
possible values of $f$ through a novel primal-dual family of algorithms. We
establish the optimality of our results by obtaining separate lower-bounds for
each of small and large buyback factor regimes, and showing how our primal-dual
algorithm exactly matches this lower-bound by appropriately tuning a parameter
as a function of $f$. We further study lower and upper bounds on the
competitive ratio in variants of this model, e.g., single-resource with
different demand sizes, or matching with deterministic integral allocations. We
show how algorithms in the our family of primal-dual algorithms can obtain the
exact optimal competitive ratio in all of these variants -- which in turn
demonstrates the power of our algorithmic framework for online resource
allocations with costly buyback.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: A polynomial-time algorithm to solve the large scale of airplane refueling problem</title>
    <link href="http://arxiv.org/abs/2210.11634"/>
    <id>http://arxiv.org/abs/2210.11634</id>
    <updated>2022-10-24T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Cui_J/0/1/0/all/0/1&quot;&gt;Jinchuan Cui&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Li_X/0/1/0/all/0/1&quot;&gt;Xiaoya Li&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Airplane refueling problem (ARP) is a scheduling problem with an objective
function of fractional form. Given a fleet of $n$ airplanes with mid-air
refueling technique, each airplane has a specific fuel capacity and fuel
consumption rate. The fleet starts to fly together to a same target and during
the trip each airplane could instantaneously refuel to other airplanes and then
be dropped out. The question is how to find the best refueling policy to make
the last remaining airplane travels the farthest. We give a definition of the
sequential feasible solution and construct a sequential search algorithm, whose
computational complexity depends on the number of sequential feasible solutions
referred to $Q_n$. By utilizing combination and recurrence ideas, we prove that
the the upper bound of $Q_n$ is $2^{n-2}$. Then we focus on the worst-case and
investigate the complexity of the sequential search algorithm from a dynamic
perspective. Given a worst-case instance under some assumptions, we prove that
there must exist an index $m$ such that when $n$ is greater than $2m$, $Q_n$
turns out to be upper bounded by $\frac{m^2}{n}C_n^m$. Here the index $m$ is a
constant and could be regarded as an &quot;inflection point&quot;: with the increasing
scale of input $n$, $Q_n$ turns out to be a polynomial function of $n$. Hence,
the sequential search algorithm turns out to run in polynomial time of $n$.
Moreover, we build an efficient computability scheme by which we shall predict
the complexity of $Q_n$ to choose a proper algorithm considering the available
running time for decision makers or users.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: Two-stage Stochastic Matching and Pricing with Applications to Ride Hailing</title>
    <link href="http://arxiv.org/abs/2210.11648"/>
    <id>http://arxiv.org/abs/2210.11648</id>
    <updated>2022-10-24T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Feng_Y/0/1/0/all/0/1&quot;&gt;Yiding Feng&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Niazadeh_R/0/1/0/all/0/1&quot;&gt;Rad Niazadeh&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Saberi_A/0/1/0/all/0/1&quot;&gt;Amin Saberi&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Matching and pricing are two critical levers in two-sided marketplaces to
connect demand and supply. The platform can produce more efficient matching and
pricing decisions by batching the demand requests. We initiate the study of the
two-stage stochastic matching problem, with or without pricing, to enable the
platform to make improved decisions in a batch with an eye toward the imminent
future demand requests. This problem is motivated in part by applications in
online marketplaces such as ride hailing platforms.
&lt;/p&gt;
&lt;p&gt;We design online competitive algorithms for vertex-weighted (or unweighted)
two-stage stochastic matching for maximizing supply efficiency, and two-stage
joint matching and pricing for maximizing market efficiency. In the former
problem, using a randomized primal-dual algorithm applied to a family of
``balancing&#39;&#39; convex programs, we obtain the optimal $3/4$ competitive ratio
against the optimum offline benchmark. Using a factor revealing program and
connections to submodular optimization, we improve this ratio against the
optimum online benchmark to $(1-1/e+1/e^2)\approx 0.767$ for the unweighted and
$0.761$ for the weighted case. In the latter problem, we design optimal
$1/2$-competitive joint pricing and matching algorithm by borrowing ideas from
the ex-ante prophet inequality literature. We also show an improved
$(1-1/e)$-competitive algorithm for the special case of demand efficiency
objective using the correlation gap of submodular functions. Finally, we
complement our theoretical study by using DiDi&#39;s ride-sharing dataset for
Chengdu city and numerically evaluating the performance of our proposed
algorithms in practical instances of this problem.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: A Simple Deterministic Distributed Low-Diameter Clustering</title>
    <link href="http://arxiv.org/abs/2210.11784"/>
    <id>http://arxiv.org/abs/2210.11784</id>
    <updated>2022-10-24T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Rozhon_V/0/1/0/all/0/1&quot;&gt;V&amp;#xe1;clav Rozho&amp;#x148;&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Haeupler_B/0/1/0/all/0/1&quot;&gt;Bernhard Haeupler&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Grunau_C/0/1/0/all/0/1&quot;&gt;Christoph Grunau&lt;/a&gt;&lt;/p&gt;&lt;p&gt;We give a simple, local process for nodes in an undirected graph to form
non-adjacent clusters that (1) have at most a polylogarithmic diameter and (2)
contain at least half of all vertices. Efficient deterministic distributed
clustering algorithms for computing strong-diameter network decompositions and
other key tools follow immediately. Overall, our process is a direct and
drastically simplified way for computing these fundamental objects.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: Solving the Probabilistic Profitable Tour Problem on a Tree</title>
    <link href="http://arxiv.org/abs/2210.11881"/>
    <id>http://arxiv.org/abs/2210.11881</id>
    <updated>2022-10-24T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Angelelli_E/0/1/0/all/0/1&quot;&gt;Enrico Angelelli&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Mansini_R/0/1/0/all/0/1&quot;&gt;Renata Mansini&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Rizzi_R/0/1/0/all/0/1&quot;&gt;Romeo Rizzi&lt;/a&gt;&lt;/p&gt;&lt;p&gt;The profitable tour problem (PTP) is a well-known NP-hard routing problem
searching for a tour visiting a subset of customers while maximizing profit as
the difference between total revenue collected and traveling costs. PTP is
known to be solvable in polynomial time when special structures of the
underlying graph are considered. However, the computational complexity of the
corresponding probabilistic generalizations is still an open issue in many
cases. In this paper, we analyze the probabilistic PTP where customers are
located on a tree and need, with a known probability, for a service provision
at a predefined prize. The problem objective is to select a priori a subset of
customers with whom to commit the service so to maximize the expected profit.
We provide a polynomial time algorithm computing the optimal solution in
$O(n^2)$, where $n$ is the number of nodes in the tree.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: Splay Top Trees</title>
    <link href="http://arxiv.org/abs/2210.11918"/>
    <id>http://arxiv.org/abs/2210.11918</id>
    <updated>2022-10-24T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Holm_J/0/1/0/all/0/1&quot;&gt;Jacob Holm&lt;/a&gt; (1), &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Rotenberg_E/0/1/0/all/0/1&quot;&gt;Eva Rotenberg&lt;/a&gt; (2), &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Ryhl_A/0/1/0/all/0/1&quot;&gt;Alice Ryhl&lt;/a&gt; (2) ((1) University of Copenhagen, (2) Technical University of Denmark)&lt;/p&gt;&lt;p&gt;The top tree data structure is an important and fundamental tool in dynamic
graph algorithms. Top trees have existed for decades, and today serve as an
ingredient in many state-of-the-art algorithms for dynamic graphs. In this
work, we give a new direct proof of the existence of top trees, facilitating
simpler and more direct implementations of top trees, based on ideas from splay
trees. This result hinges on new insights into the structure of top trees, and
in particular the structure of each root path in a top tree.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: Efficient Submodular Optimization under Noise: Local Search is Robust</title>
    <link href="http://arxiv.org/abs/2210.11992"/>
    <id>http://arxiv.org/abs/2210.11992</id>
    <updated>2022-10-24T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Huang_L/0/1/0/all/0/1&quot;&gt;Lingxiao Huang&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Wang_Y/0/1/0/all/0/1&quot;&gt;Yuyi Wang&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Yang_C/0/1/0/all/0/1&quot;&gt;Chunxue Yang&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Zhou_H/0/1/0/all/0/1&quot;&gt;Huanjian Zhou&lt;/a&gt;&lt;/p&gt;&lt;p&gt;The problem of monotone submodular maximization has been studied extensively
due to its wide range of applications. However, there are cases where one can
only access the objective function in a distorted or noisy form because of the
uncertain nature or the errors involved in the evaluation. This paper considers
the problem of constrained monotone submodular maximization with noisy oracles
introduced by [Hassidim et al., 2017]. For a cardinality constraint, we propose
an algorithm achieving a near-optimal
$\left(1-\frac{1}{e}-O(\varepsilon)\right)$-approximation guarantee (for
arbitrary $\varepsilon &amp;gt; 0$) with only a polynomial number of queries to the
noisy value oracle, which improves the exponential query complexity of [Singer
et al., 2018]. For general matroid constraints, we show the first constant
approximation algorithm in the presence of noise. Our main approaches are to
design a novel local search framework that can handle the effect of noise and
to construct certain smoothing surrogate functions for noise reduction.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: Unbalanced Triangle Detection and Enumeration Hardness for Unions of Conjunctive Queries</title>
    <link href="http://arxiv.org/abs/2210.11996"/>
    <id>http://arxiv.org/abs/2210.11996</id>
    <updated>2022-10-24T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Bringmann_K/0/1/0/all/0/1&quot;&gt;Karl Bringmann&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Carmeli_N/0/1/0/all/0/1&quot;&gt;Nofar Carmeli&lt;/a&gt;&lt;/p&gt;&lt;p&gt;We study the enumeration of answers to Unions of Conjunctive Queries (UCQs)
with optimal time guarantees. More precisely, we wish to identify the queries
that can be solved with linear preprocessing time and constant delay. Despite
the basic nature of this problem, it was shown only recently that UCQs can be
solved within these time bounds if they admit free-connex union extensions,
even if all individual CQs in the union are intractable with respect to the
same complexity measure. Our goal is to understand whether there exist
additional tractable UCQs, not covered by the currently known algorithms.
&lt;/p&gt;
&lt;p&gt;As a first step, we show that some previously unclassified UCQs are hard
using the classic 3SUM hypothesis, via a known reduction from 3SUM to triangle
listing in graphs. As a second step, we identify a question about a variant of
this graph task which is unavoidable if we want to classify all self-join free
UCQs: is it possible to decide the existence of a triangle in a
vertex-unbalanced tripartite graph in linear time? We prove that this task is
equivalent in hardness to some family of UCQs. Finally, we show a dichotomy for
unions of two self-join-free CQs if we assume the answer to this question is
negative.
&lt;/p&gt;
&lt;p&gt;As a result, to reason about a class of enumeration problems defined by UCQs,
it is enough to study the single decision problem of detecting triangles in
unbalanced graphs. As of today, we know of no algorithm that comes close to
solving this decision problem within the required time bounds. Our conclusion
is that, without a breakthrough for triangle detection, we have no hope to find
an efficient algorithm for additional unions of two self-join free CQs. On the
other hand, if we will one day have such a triangle detection algorithm, we
will immediately obtain an efficient algorithm for a family of UCQs that are
currently not known to be tractable.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">ECCC Papers: TR22-141 |  TFNP Characterizations of Proof Systems and Monotone Circuits | 

	Noah Fleming, 

	Sam Buss, 

	Russell Impagliazzo</title>
    <link href="https://eccc.weizmann.ac.il/report/2022/141"/>
    <id>https://eccc.weizmann.ac.il/report/2022/141</id>
    <updated>2022-10-23T01:10:16+00:00</updated>
    <content type="html" xml:lang="en">
    Connections between proof complexity and circuit complexity have become major tools for obtaining lower bounds in both areas. These connections -- which take the form of interpolation theorems and query-to-communication lifting theorems --  translate efficient proofs into small circuits, and vice versa, allowing tools from one area to be applied to the other. Recently, the theory of TFNP has emerged as a unifying framework underlying these connections. For many of the proof systems which admit such a connection there is a TFNP problem which characterizes it: the class of problems which are reducible to this TFNP problem via query-efficient reductions is equivalent to the tautologies that can be efficiently proven in the system. Through this, proof complexity has become a major tool for proving separations in black-box TFNP. Similarly, for certain monotone circuit models, the class of functions that it can compute efficiently is equivalent to what can be reduced to a certain TFNP problem in low communication. When a TFNP problem has both a proof and circuit characterization, one can prove an interpolation theorem. Conversely, many lifting theorems can be viewed as relating the communication and query reductions to TFNP problems. This is exciting, as it suggests that TFNP provides a roadmap for the development of further interpolation theorems and lifting theorems. 

In this paper we begin to develop a more systematic understanding of when these connections to TFNP occur. We give exact conditions under which a proof system or circuit model admits a characterization by a TFNP problem. We show:

- Every well-behaved proof system which can prove its own soundness (a reflection principle) is characterized by a TFNP problem. Conversely, every TFNP problem gives rise to a well-behaved proof system which proves its own soundness.

- Every well-behaved monotone circuit model which admits a universal family  of functions is characterized by a TFNP problem. Conversely, every TFNP problem gives rise to a well-behaved monotone circuit model with a universal problem.

As an example, we provide a TFNP characterization of the Polynomial Calculus, answering a question of Goos et al., and show that it can prove its own soundness.
  </content>
    <author>
      <name>ECCC Papers</name>
      <uri>https://eccc.weizmann.ac.il/</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">David Eppstein: Repeated vertices in TSP tours</title>
    <link href="https://11011110.github.io/blog/2022/10/22/repeated-vertices-tsp.html"/>
    <id>https://11011110.github.io/blog/2022/10/22/repeated-vertices-tsp</id>
    <updated>2022-10-22T17:22:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p&gt;This week my graph algorithms course covered the traveling salesperson problem, which I usually describe in two equivalent forms:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Given a distance matrix representing a metric space, find a cycle that passes through each point of the space exactly once, of minimum total length&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Given a connected positively-weighted undirected graph, find a closed walk that passes through each vertex at least once, of minimum total length&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To go from a distance matrix to a graph, we just use the complete graph, and skip any repeated vertices in its closed walk. To go from a graph to a distance matrix, compute all pairs shortest distances, and then form a closed walk by concatenating the shortest paths between consecutive vertices of the non-repeating cycle. But this concatenation may create many unavoidable repeated vertices. For instance, if your graph is an &lt;span style=&quot;white-space:nowrap&quot;&gt;\(n\)-vertex&lt;/span&gt; star, then any closed walk through all the vertices must return to the central vertex \(n-1\) times, like the blue curve past all of the vertices in the nine-vertex star below.&lt;/p&gt;

&lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;/blog/assets/2022/star-tour.svg&quot; alt=&quot;A closed walk through all vertices of the star $$K_{1,8}$$ visits the central vertex eight times.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It occurred to me to wonder: how many repetitions might be necessary, in total? The multigraph of edges used by the closed walk (with one copy for each time the walk uses each edge) is Eulerian, meaning that it connects all the vertices and has even degree at all of them. Any Eulerian multigraph has a closed walk visiting all the vertices, its Euler tour. Among these graphs, the TSP multigraph must be minimal: if it had an Eulerian subgraph we could walk on that instead. And any minimal Eulerian multigraph can be turned into a simple graph and weighted in such a way that all edges are used with their given multiplicities in the optimal TSP walk. So another, more combinatorial, way of asking the same question is: how many edges can a minimal Eulerian multigraph have?&lt;/p&gt;

&lt;p&gt;The answer: &lt;span style=&quot;white-space:nowrap&quot;&gt;\(2n-2\).&lt;/span&gt; More precisely, a graph is said to be &lt;a href=&quot;https://en.wikipedia.org/wiki/Dense_graph&quot;&gt;\((a,b)\)-sparse&lt;/a&gt; if every &lt;span style=&quot;white-space:nowrap&quot;&gt;\(k\)-vertex&lt;/span&gt; subgraph has at most \(ak-b\) edges. In this sense, the minimal Eulerian graphs are &lt;span style=&quot;white-space:nowrap&quot;&gt;\((2,2)\)-sparse.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;If you were given an Eulerian graph that is not &lt;span style=&quot;white-space:nowrap&quot;&gt;\((2,2)\)-sparse,&lt;/span&gt; it could not be minimal Eulerian. To see this, choose a minimal subset of \(k\) vertices that has more than \(2k-2\) edges. By deleting edges, you can find a subgraph that is &lt;span style=&quot;white-space:nowrap&quot;&gt;\((2,2)\)-tight:&lt;/span&gt; it has exactly \(2k-2\) edges, and every subgraph is &lt;span style=&quot;white-space:nowrap&quot;&gt;\((2,2)\)-sparse.&lt;/span&gt; A result of Nash-Williams from the 1960s states that a subgraph like this can always be decomposed into two spanning trees. But if you combine one of the deleted edges with a path between its endpoints in one of the trees, you get a cycle that you can remove without changing the parity of the vertex degrees. Removing this cycle still leaves a subgraph that is connected through the other spanning tree. Because there is a cycle you can remove leaving an Eulerian subgraph, your starting graph is not minimal.&lt;/p&gt;

&lt;p&gt;The bound of \(2(n-1)\) on the number of edges in a minimal Eulerian multigraph cannot be made any smaller. One way to construct a minimal Eulerian multigraph with exactly this many edges (maybe the only way) is just to double all of the edges in a tree.&lt;/p&gt;

&lt;p&gt;Instead of counting edges, another way to define sparse graphs involves forbidden &lt;a href=&quot;https://en.wikipedia.org/wiki/Shallow_minor&quot;&gt;shallow minors&lt;/a&gt;. However, this does not work for minimal Eulerian graphs: they have no forbidden shallow minors. For instance, if you subdivide the edges of any Eulerian graph, such as a complete graph on an odd number of vertices, you will get a minimal Eulerian graph that has the complete graph as a depth-1 minor.&lt;/p&gt;

&lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;/blog/assets/2022/subdivided-K7.svg&quot; alt=&quot;Subdividing the edges of the complete graph $$K_7$$ produces a minimal Eulerian graph with $$K_7$$ as a 1-shallow minor.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;(&lt;a href=&quot;https://mathstodon.xyz/@11011110/109214811068499556&quot;&gt;Discuss on Mastodon&lt;/a&gt;)&lt;/p&gt;&lt;p class=&quot;authors&quot;&gt;By David Eppstein&lt;/p&gt;
  </content>
    <author>
      <name>David Eppstein</name>
      <uri>https://11011110.github.io/blog/</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">CCI: jobs: Faculty at Northeastern University (apply by December 1, 2022)</title>
    <link href="https://cstheory-jobs.org/2022/10/21/faculty-at-northeastern-university-apply-by-december-1-2022/"/>
    <id>http://cstheory-jobs.org/2022/10/21/faculty-at-northeastern-university-apply-by-december-1-2022/</id>
    <updated>2022-10-21T17:52:43+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p&gt;Northeastern&amp;#8217;s Khoury College of Computer Sciences is looking to hire 8 open-rank tenure-track faculty this year! We are specifically targeting cryptography, differential privacy, and quantum computing, but are interested in exceptional candidates in all areas.&lt;/p&gt;
&lt;p&gt;Website: &lt;a href=&quot;https://www.khoury.northeastern.edu/information-for-overview/prospective-faculty/open-positions/tenure-track/&quot;&gt;https://www.khoury.northeastern.edu/information-for-overview/prospective-faculty/open-positions/tenure-track/&lt;/a&gt;&lt;br /&gt;
Email: jullman@ccs.neu.edu&lt;/p&gt;
&lt;p class=&quot;authors&quot;&gt;By shacharlovett&lt;/p&gt;
  </content>
    <author>
      <name>CCI: jobs</name>
      <uri>https://cstheory-jobs.org</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">CCI: jobs: Postdoc at Nanyang Technological University (apply by December 31, 2023)</title>
    <link href="https://cstheory-jobs.org/2022/10/21/postdoc-at-nanyang-technological-university-apply-by-december-31-2023/"/>
    <id>http://cstheory-jobs.org/2022/10/21/postdoc-at-nanyang-technological-university-apply-by-december-31-2023/</id>
    <updated>2022-10-21T04:49:58+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p&gt;I&amp;#8217;m looking for two postdocs to work with me on data stream algorithms, low distortion metric embeddings, randomized numerical linear algebra or other related topics.&lt;/p&gt;
&lt;p&gt;The starting date is flexible and will be from February 2023 onwards. The initial contract is for one year and an extension is possible based on performance and the funding situation.&lt;/p&gt;
&lt;p&gt;Website: &lt;a href=&quot;https://personal.ntu.edu.sg/yili/&quot;&gt;https://personal.ntu.edu.sg/yili/&lt;/a&gt;&lt;br /&gt;
Email: yili@ntu.edu.sg&lt;/p&gt;
&lt;p class=&quot;authors&quot;&gt;By shacharlovett&lt;/p&gt;
  </content>
    <author>
      <name>CCI: jobs</name>
      <uri>https://cstheory-jobs.org</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: Substring Density Estimation from Traces</title>
    <link href="http://arxiv.org/abs/2210.10917"/>
    <id>http://arxiv.org/abs/2210.10917</id>
    <updated>2022-10-21T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Mazooji_K/0/1/0/all/0/1&quot;&gt;Kayvon Mazooji&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Shomorony_I/0/1/0/all/0/1&quot;&gt;Ilan Shomorony&lt;/a&gt;&lt;/p&gt;&lt;p&gt;In the trace reconstruction problem, one seeks to reconstruct a binary string
$s$ from a collection of traces, each of which is obtained by passing $s$
through a deletion channel. It is known that $\exp(\tilde O(n^{1/5}))$ traces
suffice to reconstruct any length-$n$ string with high probability. We consider
a variant of the trace reconstruction problem where the goal is to recover a
&quot;density map&quot; that indicates the locations of each length-$k$ substring
throughout $s$. We show that $\epsilon^{-2}\cdot \text{poly}(n)$ traces suffice
to recover the density map with error at most $\epsilon$. As a result, when
restricted to a set of source strings whose minimum &quot;density map distance&quot; is
at least $1/\text{poly}(n)$, the trace reconstruction problem can be solved
with polynomially many traces.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: Identities and periodic oscillations of divide-and-conquer recurrences splitting at half</title>
    <link href="http://arxiv.org/abs/2210.10968"/>
    <id>http://arxiv.org/abs/2210.10968</id>
    <updated>2022-10-21T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Hwang_H/0/1/0/all/0/1&quot;&gt;Hsien-Kuei Hwang&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Janson_S/0/1/0/all/0/1&quot;&gt;Svante Janson&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Tsai_T/0/1/0/all/0/1&quot;&gt;Tsung-Hsi Tsai&lt;/a&gt;&lt;/p&gt;&lt;p&gt;We study divide-and-conquer recurrences of the form \begin{equation*}
&lt;/p&gt;
&lt;p&gt;f(n)
&lt;/p&gt;
&lt;p&gt;= \alpha f(\lfloor \tfrac n2\rfloor)
&lt;/p&gt;
&lt;p&gt;+ \beta f(\lceil \tfrac n2\rceil)
&lt;/p&gt;
&lt;p&gt;+ g(n) \qquad(n\ge2), \end{equation*} with $g(n)$ and $f(1)$ given, where
$\alpha,\beta\ge0$ with $\alpha+\beta&amp;gt;0$; such recurrences appear often in
analysis of computer algorithms, numeration systems, combinatorial sequences,
and related areas. We show that the solution satisfies always the simple
\emph{identity} \begin{equation*}
&lt;/p&gt;
&lt;p&gt;f(n)
&lt;/p&gt;
&lt;p&gt;= n^{\log_2(\alpha+\beta)} P(\log_2n) - Q(n) \end{equation*} under an optimum
(iff) condition on $g(n)$. This form is not only an identity but also an
asymptotic expansion because $Q(n)$ is of a smaller order. Explicit forms for
the \emph{continuity} of the periodic function $P$ are provided, together with
a few other smoothness properties. We show how our results can be easily
applied to many dozens of concrete examples collected from the literature, and
how they can be extended in various directions. Our method of proof is
surprisingly simple and elementary, but leads to the strongest types of results
for all examples to which our theory applies.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: A general model-and-run solver for multistage robust discrete linear optimization</title>
    <link href="http://arxiv.org/abs/2210.11132"/>
    <id>http://arxiv.org/abs/2210.11132</id>
    <updated>2022-10-21T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/math/1/au:+Hartisch_M/0/1/0/all/0/1&quot;&gt;Michael Hartisch&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/math/1/au:+Lorenz_U/0/1/0/all/0/1&quot;&gt;Ulf Lorenz&lt;/a&gt;&lt;/p&gt;&lt;p&gt;The necessity to deal with uncertain data is a major challenge in decision
making. Robust optimization emerged as one of the predominant paradigms to
produce solutions that hedge against uncertainty. In order to obtain an even
more realistic description of the underlying problem where the decision maker
can react to newly disclosed information, multistage models can be used.
However, due to their computational difficulty, multistage problems beyond two
stages have received less attention and are often only addressed using
approximation rather than optimization schemes. Even less attention is paid to
the consideration of decision-dependent uncertainty in a multistage setting. We
explore multistage robust optimization via quantified linear programs, which
are linear programs with ordered variables that are either existentially or
universally quantified. Building upon a (mostly) discrete setting where the
uncertain parameters -- the universally quantified variables -- are only
restricted by their bounds, we present an augmented version that allows stating
the discrete uncertainty set via a linear constraint system that also can be
affected by decision variables. We present a general search-based solution
approach and introduce our solver Yasol that is able to deal with multistage
robust linear discrete optimization problems, with final mixed-integer recourse
actions and a discrete uncertainty set, which even can be decision-dependent.
In doing so, we provide a convenient model-and-run approach, that can serve as
baseline for computational experiments in the field of multistage robust
optimization, providing optimal solutions for problems with an arbitrary number
of decision stages.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: Using Integer Programming Techniques in Real-Time Scheduling Analysis</title>
    <link href="http://arxiv.org/abs/2210.11185"/>
    <id>http://arxiv.org/abs/2210.11185</id>
    <updated>2022-10-21T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Singh_A/0/1/0/all/0/1&quot;&gt;Abhishek Singh&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Real-time scheduling theory assists developers of embedded systems in
verifying that the timing constraints required by critical software tasks can
be feasibly met on a given hardware platform. Fundamental problems in the
theory are often formulated as search problems for fixed points of functions
and are solved by fixed-point iterations. These fixed-point methods are used
widely because they are simple to understand, simple to implement, and seem to
work well in practice. These fundamental problems can also be formulated as
integer programs and solved with algorithms that are based on theories of
linear programming and cutting planes amongst others. However, such algorithms
are harder to understand and implement than fixed-point iterations. In this
research, we show that ideas like linear programming duality and cutting planes
can be used to develop algorithms that are as easy to implement as existing
fixed-point iteration schemes but have better convergence properties. We
evaluate the algorithms on synthetically generated problem instances to
demonstrate that the new algorithms are faster than the existing algorithms.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: Noisy Tree Data Structures and Quantum Applications</title>
    <link href="http://arxiv.org/abs/2210.11197"/>
    <id>http://arxiv.org/abs/2210.11197</id>
    <updated>2022-10-21T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/quant-ph/1/au:+Khadiev_K/0/1/0/all/0/1&quot;&gt;Kamil Khadiev&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/quant-ph/1/au:+Savelyev_N/0/1/0/all/0/1&quot;&gt;Nikita Savelyev&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/quant-ph/1/au:+Ziatdinov_M/0/1/0/all/0/1&quot;&gt;Mansur Ziatdinov&lt;/a&gt;&lt;/p&gt;&lt;p&gt;The paper presents a technique for constructing noisy data structures called
a walking tree. We apply it for a Red-Black tree (an implementation of a
Self-Balanced Binary Search Tree) and a segment tree. We obtain the same
complexity of the main operations for these data structures as in the case
without noise (asymptotically). We use these data structures in quantum
algorithms for two problems: the Exam Problem and the Largest File Problem.
&lt;/p&gt;
&lt;p&gt;Finally, we suggest new quantum solution for strings sorting problem and show
the lower bound. The upper bound and lower bound for the problem are the same
up to log factor. At the same time, it is more effective than classical
counterparts.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: Private Algorithms with Private Predictions</title>
    <link href="http://arxiv.org/abs/2210.11222"/>
    <id>http://arxiv.org/abs/2210.11222</id>
    <updated>2022-10-21T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Amin_K/0/1/0/all/0/1&quot;&gt;Kareem Amin&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Dick_T/0/1/0/all/0/1&quot;&gt;Travis Dick&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Khodak_M/0/1/0/all/0/1&quot;&gt;Mikhail Khodak&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Vassilvitskii_S/0/1/0/all/0/1&quot;&gt;Sergei Vassilvitskii&lt;/a&gt;&lt;/p&gt;&lt;p&gt;When applying differential privacy to sensitive data, a common way of getting
improved performance is to use external information such as other sensitive
data, public data, or human priors. We propose to use the algorithms with
predictions framework -- previously applied largely to improve time complexity
or competitive ratios -- as a powerful way of designing and analyzing
privacy-preserving methods that can take advantage of such external information
to improve utility. For four important tasks -- quantile release, its extension
to multiple quantiles, covariance estimation, and data release -- we construct
prediction-dependent differentially private methods whose utility scales with
natural measures of prediction quality. The analyses enjoy several advantages,
including minimal assumptions about the data, natural ways of adding robustness
to noisy predictions, and novel &quot;meta&quot; algorithms that can learn predictions
from other (potentially sensitive) data. Overall, our results demonstrate how
to enable differentially private algorithms to make use of and learn noisy
predictions, which holds great promise for improving utility while preserving
privacy across a variety of tasks.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: Block subsampled randomized Hadamard transform for low-rank approximation on distributed architectures</title>
    <link href="http://arxiv.org/abs/2210.11295"/>
    <id>http://arxiv.org/abs/2210.11295</id>
    <updated>2022-10-21T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/math/1/au:+Balabanov_O/0/1/0/all/0/1&quot;&gt;Oleg Balabanov&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/math/1/au:+Beaupere_M/0/1/0/all/0/1&quot;&gt;Matthias Beaupere&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/math/1/au:+Grigori_L/0/1/0/all/0/1&quot;&gt;Laura Grigori&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/math/1/au:+Lederer_V/0/1/0/all/0/1&quot;&gt;Victor Lederer&lt;/a&gt;&lt;/p&gt;&lt;p&gt;This article introduces a novel structured random matrix composed blockwise
from subsampled randomized Hadamard transforms (SRHTs). The block SRHT is
expected to outperform well-known dimension reduction maps, including SRHT and
Gaussian matrices, on distributed architectures with not too many cores
compared to the dimension. We prove that a block SRHT with enough rows is an
oblivious subspace embedding, i.e., an approximate isometry for an arbitrary
low-dimensional subspace with high probability. Our estimate of the required
number of rows is similar to that of the standard SRHT. This suggests that the
two transforms should provide the same accuracy of approximation in the
algorithms. The block SRHT can be readily incorporated into randomized methods,
for instance to compute a low-rank approximation of a large-scale matrix. For
completeness, we revisit some common randomized approaches for this problem
such as Randomized Singular Value Decomposition and Nystr\&quot;{o}m approximation,
with a discussion of their accuracy and implementation on distributed
architectures.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: Finding the smallest or largest element of a tensor from its low-rank factors</title>
    <link href="http://arxiv.org/abs/2210.11413"/>
    <id>http://arxiv.org/abs/2210.11413</id>
    <updated>2022-10-21T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/eess/1/au:+Sidiropoulos_N/0/1/0/all/0/1&quot;&gt;Nicholas D. Sidiropoulos&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/eess/1/au:+Karakasis_P/0/1/0/all/0/1&quot;&gt;Paris Karakasis&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/eess/1/au:+Konar_A/0/1/0/all/0/1&quot;&gt;Aritra Konar&lt;/a&gt;&lt;/p&gt;&lt;p&gt;We consider the problem of finding the smallest or largest entry of a tensor
of order $N$ that is specified via its rank decomposition. Stated in a
different way, we are given $N$ sets of $R$-dimensional vectors and we wish to
select one vector from each set such that the sum of the Hadamard product of
the selected vectors is minimized or maximized. This is a fundamental tensor
problem with numerous applications in embedding similarity search, recommender
systems, graph mining, multivariate probability, and statistics. We show that
this discrete optimization problem is NP-hard for any tensor rank higher than
one, but also provide an equivalent continuous problem reformulation which is
amenable to disciplined non-convex optimization. We propose a suite of
gradient-based approximation algorithms whose performance in preliminary
experiments appears to be promising.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">CCI: jobs: Tenure-track Faculty Positions at Simon Fraser University (apply by December 15, 2022)</title>
    <link href="https://cstheory-jobs.org/2022/10/20/tenure-track-faculty-positions-at-simon-fraser-university-apply-by-december-15-2022/"/>
    <id>http://cstheory-jobs.org/2022/10/20/tenure-track-faculty-positions-at-simon-fraser-university-apply-by-december-15-2022/</id>
    <updated>2022-10-20T23:49:12+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p&gt;The School of Computing Science at Simon Fraser University (SFU) invites applications for multiple tenure-track faculty positions.&lt;/p&gt;
&lt;p&gt;Website: &lt;a href=&quot;https://www.sfu.ca/computing/job-opportunities.html&quot;&gt;https://www.sfu.ca/computing/job-opportunities.html&lt;/a&gt;&lt;br /&gt;
Email: cs_faculty_affairs@sfu.ca&lt;/p&gt;
&lt;p class=&quot;authors&quot;&gt;By shacharlovett&lt;/p&gt;
  </content>
    <author>
      <name>CCI: jobs</name>
      <uri>https://cstheory-jobs.org</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">CCI: jobs: Faculty (TT, open to all ranks) at University of Colorado Boulder (apply by December 5, 2022)</title>
    <link href="https://cstheory-jobs.org/2022/10/20/faculty-tt-open-to-all-ranks-at-university-of-colorado-boulder-apply-by-december-5-2022/"/>
    <id>http://cstheory-jobs.org/2022/10/20/faculty-tt-open-to-all-ranks-at-university-of-colorado-boulder-apply-by-december-5-2022/</id>
    <updated>2022-10-20T18:53:34+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p&gt;The University of Colorado Boulder is seeking applications for a tenure-track faculty position at the Assistant Professor rank in theoretical computer science, broadly deﬁned. Associate &amp;amp; Full Professor ranks may be considered for qualified candidates. All researchers working on topics within &amp;amp; adjacent to the broad area of Computer Science Theory are encouraged to apply.&lt;/p&gt;
&lt;p&gt;Website: &lt;a href=&quot;https://jobs.colorado.edu/jobs/JobDetail/?jobId=43568&quot;&gt;https://jobs.colorado.edu/jobs/JobDetail/?jobId=43568&lt;/a&gt;&lt;br /&gt;
Email: jgrochow@colorado.edu&lt;/p&gt;
&lt;p class=&quot;authors&quot;&gt;By shacharlovett&lt;/p&gt;
  </content>
    <author>
      <name>CCI: jobs</name>
      <uri>https://cstheory-jobs.org</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">CCI: jobs: Two postdoc positions in Lisbon at University of Lisbon (apply by January 1, 2023)</title>
    <link href="https://cstheory-jobs.org/2022/10/20/two-postdoc-positions-in-lisbon-at-university-of-lisbon-apply-by-january-1-2023/"/>
    <id>http://cstheory-jobs.org/2022/10/20/two-postdoc-positions-in-lisbon-at-university-of-lisbon-apply-by-january-1-2023/</id>
    <updated>2022-10-20T17:30:08+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p&gt;I&amp;#8217;m looking for two postdocs to join me as part of the ERC Starting Grant &amp;#8220;The Hardness of Finding Good Algorithms&amp;#8221;. The project focuses on metacomplexity and unconditional lower-bounds.&lt;/p&gt;
&lt;p&gt;The starting date is flexible, between March-October 2023. A decision on individual applicants will not be made before November 1, and I expect both positions to be filled by mid-late January.&lt;/p&gt;
&lt;p&gt;Website: &lt;a href=&quot;https://brunoloff.wordpress.com/hofga/&quot;&gt;https://brunoloff.wordpress.com/hofga/&lt;/a&gt;&lt;br /&gt;
Email: bruno.loff@gmail.com&lt;/p&gt;
&lt;p class=&quot;authors&quot;&gt;By shacharlovett&lt;/p&gt;
  </content>
    <author>
      <name>CCI: jobs</name>
      <uri>https://cstheory-jobs.org</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">Computational Complexity: Alpha Tensor</title>
    <link href="http://blog.computationalcomplexity.org/2022/10/alpha-tensor.html"/>
    <id>tag:blogger.com,1999:blog-3722233.post-7404772395411010832</id>
    <updated>2022-10-20T14:27:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p&gt;In a &lt;a href=&quot;https://blog.computationalcomplexity.org/2022/10/will-strassens-matrix-mult-alg-ever-be.html&quot;&gt;recent post&lt;/a&gt;, Bill used the announcement of a new AI multiplication algorithm to discuss the applications of Strassen&#39;s famous algorithm. For this post I&#39;d like to focus on the new algorithm itself,&amp;nbsp;&lt;a href=&quot;https://www.deepmind.com/blog/discovering-novel-algorithms-with-alphatensor&quot;&gt;Alpha Tensor&lt;/a&gt;, the algorithm behind the algorithm, what it has actually accomplished&amp;nbsp;and what it means for us theorists.&amp;nbsp;&lt;/p&gt;&lt;p&gt;To multiply two 2x2 matrices in the usual way you need eight multiplication steps. In 1969 Strassen surprised the world by showing how to &lt;a href=&quot;https://en.wikipedia.org/wiki/Strassen_algorithm#Algorithm&quot;&gt;multiply those matrices using only seven multiplications&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;You can recurse on larger matrices. For 4x4 matrices you can use 7&lt;sup&gt;2&lt;/sup&gt;=49 multiplications instead of the naïve 64. In general for nxn matrices you need roughly n&lt;sup&gt;log&lt;sub&gt;2&lt;/sub&gt;7&lt;/sup&gt; ≈ n&lt;sup&gt;2.81&lt;/sup&gt; multiplications.&lt;/p&gt;&lt;p&gt;No one has found an algorithm for 4x4 matrices that uses less than 49 from recursing on Strassen. Alpha Tensor does so for the special case of working over GF[2], where addition and subtraction are interchangeable. Their algorithm does not work for general fields such as the real numbers.&lt;/p&gt;&lt;p&gt;Here&#39;s the full table of Alpha Tensor results from the &lt;a href=&quot;https://doi.org/10.1038/s41586-022-05172-4&quot;&gt;Nature paper&lt;/a&gt; for multiplying a nxm matrix by a mxp matrix. The Modular column is for GF[2] and the standard column is for general fields. Alpha tensor does improve on the best known for general fields for specific problems like multiplying a 3x4 matrix by a 4x5 matrix. Much of the press &lt;a href=&quot;https://arstechnica.com/information-technology/2022/10/deepmind-breaks-50-year-math-record-using-ai-new-record-falls-a-week-later/&quot;&gt;failed to make this distinction&lt;/a&gt; for 4x4 multiplication leading to some confusion.&lt;/p&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj9-_aNBNNDkLCuUrz9Wz2dzgctRxEAk2Q8ptCHuk1SwBLyNrwentWYhpYulJX3VP64GE3UxlfaQlSHxm2faVnrh44MCnEyHSM2o-998w6P0_gKIk9fPScLQU9PtxKUPmfuFZR6SiYYlvuXw01FhP0Jg24ro1j0YCY99pxg7aTzMI7mzgWCfw/s833/IMG_0190.jpg&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;833&quot; data-original-width=&quot;702&quot; height=&quot;640&quot; src=&quot;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj9-_aNBNNDkLCuUrz9Wz2dzgctRxEAk2Q8ptCHuk1SwBLyNrwentWYhpYulJX3VP64GE3UxlfaQlSHxm2faVnrh44MCnEyHSM2o-998w6P0_gKIk9fPScLQU9PtxKUPmfuFZR6SiYYlvuXw01FhP0Jg24ro1j0YCY99pxg7aTzMI7mzgWCfw/w540-h640/IMG_0190.jpg&quot; width=&quot;540&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;What does this mean for theory? Recursing on 4x4 matrices now reduces the time for matrix multiplication to roughly n&lt;sup&gt;2.78&lt;/sup&gt; nowhere close to the best &lt;a href=&quot;https://doi.org/10.1137/1.9781611976465.32&quot;&gt;theoretical upper bound&lt;/a&gt; of about n&lt;sup&gt;2.37&lt;/sup&gt;. The Alpha tensor result may be more practical though time will tell.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;Manuel Kauers and Jakob Moosbauer shortly after Alpha Tensor announcement, &lt;a href=&quot;https://arxiv.org/abs/2210.04045&quot;&gt;reduced&lt;/a&gt; the 5x5 case over GF[2] to 95 multiplications. Nice to see the last word isn&#39;t by machine (yet!) but that shouldn&#39;t reduce the excitement over Alpha Tensor. Often we see a breakthrough followed by a small improvement. Note that 95 multiplications for 5x5 matrices won&#39;t give a faster asymptotic algorithm for nxn multiplication than Strassen.&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;What excites me the most is not the algorithm, but the algorithm to find the algorithm. Alpha Tensor uses the tools that AlphaZero used to play Chess and Go to search the large search space of potential algorithms using Monte Carlo Tree search, basically searching at random and learning and updating the probabilities of the search. Before using machine learning, we had few good approaches to searching large combinatorial spaces of this nature.&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;In general, most new algorithms come from new approaches, not just from the structural decomposition we see in matrix multiplication so theorists won&#39;t be out of a job anytime soon. Nevertheless this is just another lesson that using ML has dramatically improved our ability to search through a large number of possibilities looking for a specific solution.&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: left;&quot;&gt;The Alpha Tensor Nature paper was &lt;a href=&quot;https://www.nature.com/articles/s41586-022-05172-4#article-info&quot;&gt;submitted&lt;/a&gt; in October of 2021. A year is eternity in the ML world. I wonder what is happening now that we don&#39;t know about.&lt;/div&gt;&lt;p class=&quot;authors&quot;&gt;By Lance Fortnow&lt;/p&gt;
  </content>
    <author>
      <name>Computational Complexity</name>
      <uri>http://blog.computationalcomplexity.org/</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">TCS+ Seminar Series: TCS+ talk: Wednesday, October 26 — Shay Moran, Technion and Google Research</title>
    <link href="https://tcsplus.wordpress.com/2022/10/20/tcs-talk-wednesday-october-26-shay-moran-technion-and-google-research/"/>
    <id>http://tcsplus.wordpress.com/?p=643</id>
    <updated>2022-10-20T10:29:17+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p&gt;The next TCS+ talk will take place this coming Wednesday, October 26th at 1:00 PM Eastern Time (10:00 AM Pacific Time, 19:00 Central European Time, 17:00 UTC). &lt;strong&gt;Shay Moran&lt;/strong&gt; from Technion and Google Research will speak about &amp;#8220;&lt;em&gt;A Characterization of Multiclass PAC Learning&lt;/em&gt;&amp;#8221; (abstract below).&lt;/p&gt;
&lt;p&gt;You can reserve a spot as an individual or a group to join us live by signing up on &lt;a href=&quot;https://sites.google.com/view/tcsplus/welcome/next-tcs-talk&quot;&gt;the online form&lt;/a&gt;. Registration is &lt;em&gt;not&lt;/em&gt; required to attend the interactive talk, and the link will be posted on the website the day prior to the talk; however, by registering in the form, you will receive a reminder, along with the link. (The recorded talk will also be posted &lt;a href=&quot;https://sites.google.com/view/tcsplus/welcome/past-talks&quot;&gt;on our website&lt;/a&gt; afterwards) As usual, for more information about the TCS+ online seminar series and the upcoming talks, or to &lt;a href=&quot;https://sites.google.com/view/tcsplus/welcome/suggest-a-talk&quot;&gt;suggest&lt;/a&gt; a possible topic or speaker, please see &lt;a href=&quot;https://sites.google.com/view/tcsplus/&quot;&gt;the website&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote class=&quot;wp-block-quote&quot;&gt;&lt;p&gt;Abstract: A seminal result in learning theory characterizes the PAC learnability of binary classes through the VC dimension. Extending this characterization to the general multiclass setting has been open since the late 1980s.&lt;/p&gt;
&lt;p&gt;We resolve this problem by characterizing multiclass PAC learnability through the DS dimension, a combinatorial dimension defined by Daniely and Shalev-Shwartz (2014).&lt;/p&gt;
&lt;p&gt;The classical characterization of the binary case boils down to empirical risk minimization. In contrast, our characterization of the multiclass case involves a variety of algorithmic ideas; these include a natural setting we call list PAC learning. In the list learning setting, instead of predicting the label of a given unseen input, the goal is to provide a short list of labels which contains the correct one with high probability.&lt;/p&gt;
&lt;p&gt;Our second main result concerns the Natarajan dimension, which has been a central candidate for characterizing multiclass learnability. This dimension was introduced by Natarajan (1988) as a barrier for PAC learning. Whether the Natarajan dimension characterizes PAC learnability in general has been posed as an open question in several papers since. We provide a negative answer: we construct a non-learnable class with Natarajan dimension one.&lt;/p&gt;
&lt;p&gt;For the construction, we identify a fundamental connection between concept classes and topology. We crucially rely on a deep and involved geometric-group-theoretic construction by Januszkiewicz and Swiatkowski. This proof provides another demonstration of the fruitful links learning theory has with different areas in mathematics.&lt;/p&gt;
&lt;p&gt;Joint work with Nataly Brukhim, Daniel Carmon, Irit Dinur, and Amir Yehudayoff&lt;/p&gt;&lt;/blockquote&gt;
&lt;p class=&quot;authors&quot;&gt;By plustcs&lt;/p&gt;
  </content>
    <author>
      <name>TCS+ Seminar Series</name>
      <uri>https://tcsplus.wordpress.com</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">CCI: jobs: Teaching Faculty (Open Rank) at University of Illinois at Urbana-Champaign (apply by November 15, 2022)</title>
    <link href="https://cstheory-jobs.org/2022/10/20/teaching-faculty-open-rank-at-university-of-illinois-at-urbana-champaign-apply-by-november-15-2022/"/>
    <id>http://cstheory-jobs.org/2022/10/20/teaching-faculty-open-rank-at-university-of-illinois-at-urbana-champaign-apply-by-november-15-2022/</id>
    <updated>2022-10-20T01:51:34+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p&gt;The Computer Science Department at the University of Illinois invites applications for multiple full-time teaching positions to support the continued expansion of our teaching activity in Urbana-Champaign, in Chicago, and online. We welcome applications from instructors able to teach across the computer science curriculum, including candidates who can teach algorithms and theory.&lt;/p&gt;
&lt;p&gt;Website: &lt;a href=&quot;https://cs.illinois.edu/about/positions/faculty-positions/teaching-faculty&quot;&gt;https://cs.illinois.edu/about/positions/faculty-positions/teaching-faculty&lt;/a&gt;&lt;br /&gt;
Email: facultysearch@cs.illinois.edu&lt;/p&gt;
&lt;p class=&quot;authors&quot;&gt;By shacharlovett&lt;/p&gt;
  </content>
    <author>
      <name>CCI: jobs</name>
      <uri>https://cstheory-jobs.org</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">CCI: jobs: Professor (Open Rank) at University of Illinois at Urbana-Champaign (apply by November 15, 2022)</title>
    <link href="https://cstheory-jobs.org/2022/10/20/professor-open-rank-at-university-of-illinois-at-urbana-champaign-apply-by-november-15-2022/"/>
    <id>http://cstheory-jobs.org/2022/10/20/professor-open-rank-at-university-of-illinois-at-urbana-champaign-apply-by-november-15-2022/</id>
    <updated>2022-10-20T01:45:15+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p&gt;The Department of Computer Science at the University of Illinois Urbana-Champaign invites applications for full-time tenure-track faculty positions at all levels (Assistant Professor, Associate Professor, Full Professor). We particularly encourage applications from candidates working in quantum computing, but all areas of theory will be considered.&lt;/p&gt;
&lt;p&gt;Website: &lt;a href=&quot;https://cs.illinois.edu/about/positions/faculty-positions/tenure-track&quot;&gt;https://cs.illinois.edu/about/positions/faculty-positions/tenure-track&lt;/a&gt;&lt;br /&gt;
Email: cs-facultysearch@illinois.edu&lt;/p&gt;
&lt;p class=&quot;authors&quot;&gt;By shacharlovett&lt;/p&gt;
  </content>
    <author>
      <name>CCI: jobs</name>
      <uri>https://cstheory-jobs.org</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Computational Geometry: Comparing Embedded Graphs Using Average Branching Distance</title>
    <link href="http://arxiv.org/abs/2210.10181"/>
    <id>http://arxiv.org/abs/2210.10181</id>
    <updated>2022-10-20T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Batakci_L/0/1/0/all/0/1&quot;&gt;Levent Batakci&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Branson_A/0/1/0/all/0/1&quot;&gt;Abigail Branson&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Castillo_B/0/1/0/all/0/1&quot;&gt;Bryan Castillo&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Todd_C/0/1/0/all/0/1&quot;&gt;Candace Todd&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Chambers_E/0/1/0/all/0/1&quot;&gt;Erin Wolf Chambers&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Munch_E/0/1/0/all/0/1&quot;&gt;Elizabeth Munch&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Graphs drawn in the plane are ubiquitous, arising from data sets through a
variety of methods ranging from GIS analysis to image classification to shape
analysis. A fundamental problem in this type of data is comparison: given a set
of such graphs, can we rank how similar they are, in such a way that we capture
their geometric &quot;shape&quot; in the plane? In this paper we explore a method to
compare two such embedded graphs, via a simplified combinatorial representation
called a tail-less merge tree which encodes the structure based on a fixed
direction. First, we examine the properties of a distance designed to compare
merge trees called the branching distance, and show that the distance as
defined in previous work fails to satisfy some of the requirements of a metric.
We incorporate this into a new distance function called average branching
distance to compare graphs by looking at the branching distance for merge trees
defined over many directions. Despite the theoretical issues, we show that the
definition is still quite useful in practice by using our open-source code to
cluster data sets of embedded graphs.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Computational Geometry</name>
      <uri>https://arxiv.org/list/cs.CG/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Computational Geometry: Stability of Entropic Wasserstein Barycenters and application to random geometric graphs</title>
    <link href="http://arxiv.org/abs/2210.10535"/>
    <id>http://arxiv.org/abs/2210.10535</id>
    <updated>2022-10-20T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Theveneau_M/0/1/0/all/0/1&quot;&gt;Marc Theveneau&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Keriven_N/0/1/0/all/0/1&quot;&gt;Nicolas Keriven&lt;/a&gt;&lt;/p&gt;&lt;p&gt;As interest in graph data has grown in recent years, the computation of
various geometric tools has become essential. In some area such as mesh
processing, they often rely on the computation of geodesics and shortest paths
in discretized manifolds. A recent example of such a tool is the computation of
Wasserstein barycenters (WB), a very general notion of barycenters derived from
the theory of Optimal Transport, and their entropic-regularized variant. In
this paper, we examine how WBs on discretized meshes relate to the geometry of
the underlying manifold. We first provide a generic stability result with
respect to the input cost matrices. We then apply this result to random
geometric graphs on manifolds, whose shortest paths converge to geodesics,
hence proving the consistency of WBs computed on discretized shapes.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Computational Geometry</name>
      <uri>https://arxiv.org/list/cs.CG/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: List homomorphisms by deleting edges and vertices: tight complexity bounds for bounded-treewidth graphs</title>
    <link href="http://arxiv.org/abs/2210.10677"/>
    <id>http://arxiv.org/abs/2210.10677</id>
    <updated>2022-10-20T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Esmer_B/0/1/0/all/0/1&quot;&gt;Bar&amp;#x131;&amp;#x15f; Can Esmer&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Focke_J/0/1/0/all/0/1&quot;&gt;Jacob Focke&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Marx_D/0/1/0/all/0/1&quot;&gt;D&amp;#xe1;niel Marx&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Rzazewski_P/0/1/0/all/0/1&quot;&gt;Pawe&amp;#x142; Rz&amp;#x105;&amp;#x17c;ewski&lt;/a&gt;&lt;/p&gt;&lt;p&gt;The goal of this paper is to investigate a family of optimization problems
arising from list homomorphisms, and to understand what the best possible
algorithms are if we restrict the problem to bounded-treewidth graphs. For a
fixed $H$, the input of the optimization problem LHomVD($H$) is a graph $G$
with lists $L(v)$, and the task is to find a set $X$ of vertices having minimum
size such that $(G-X,L)$ has a list homomorphism to $H$. We define analogously
the edge-deletion variant LHomED($H$). This expressive family of problems
includes members that are essentially equivalent to fundamental problems such
as Vertex Cover, Max Cut, Odd Cycle Transversal, and Edge/Vertex Multiway Cut.
&lt;/p&gt;
&lt;p&gt;For both variants, we first characterize those graphs $H$ that make the
problem polynomial-time solvable and show that the problem is NP-hard for every
other fixed $H$. Second, as our main result, we determine for every graph $H$
for which the problem is NP-hard, the smallest possible constant $c_H$ such
that the problem can be solved in time $c^t_H\cdot n^{O(1)}$ if a tree
decomposition of $G$ having width $t$ is given in the input, assuming the SETH.
Let $i(H)$ be the maximum size of a set of vertices in $H$ that have pairwise
incomparable neighborhoods. For the vertex-deletion variant LHomVD($H$), we
show that the smallest possible constant is $i(H)+1$ for every $H$.
&lt;/p&gt;
&lt;p&gt;The situation is more complex for the edge-deletion version. For every $H$,
one can solve LHomED($H$) in time $i(H)^t\cdot n^{O(1)}$ if a tree
decomposition of width $t$ is given. However, the existence of a specific type
of decomposition of $H$ shows that there are graphs $H$ where LHomED($H$) can
be solved significantly more efficiently and the best possible constant can be
arbitrarily smaller than $i(H)$. Nevertheless, we determine this best possible
constant and (assuming the SETH) prove tight bounds for every fixed $H$.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: Simplex Range Searching Revisited: How to Shave Logs in Multi-Level Data Structures</title>
    <link href="http://arxiv.org/abs/2210.10172"/>
    <id>http://arxiv.org/abs/2210.10172</id>
    <updated>2022-10-20T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Chan_T/0/1/0/all/0/1&quot;&gt;Timothy M. Chan&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Zheng_D/0/1/0/all/0/1&quot;&gt;Da Wei Zheng&lt;/a&gt;&lt;/p&gt;&lt;p&gt;We revisit the classic problem of simplex range searching and related
problems in computational geometry. We present a collection of new results
which improve previous bounds by multiple logarithmic factors that were caused
by the use of multi-level data structures. Highlights include the following:
\begin{itemize} \item For a set of $n$ points in a constant dimension $d$, we
give data structures with $O(n^d)$ (or slightly better) space that can answer
simplex range counting queries in optimal $O(\log n)$ time and simplex range
reporting queries in optimal $O(\log n + k)$ time, where $k$ denotes the output
size. For semigroup range searching, we obtain $O(\log n)$ query time with
$O(n^d\mathop{\rm polylog}n)$ space. Previous data structures with similar
space bounds by Matou\v{s}ek from nearly three decades ago had $O(\log^{d+1}n)$
or $O(\log^{d+1}n + k)$ query time. \item For a set of $n$ simplices in a
constant dimension $d$, we give data structures with $O(n)$ space that can
answer stabbing counting queries (counting the number of simplices containing a
query point) in $O(n^{1-1/d})$ time, and stabbing reporting queries in
$O(n^{1-1/d}+k)$ time. Previous data structures had extra $\log^d n$ factors in
space and query time. \item For a set of $n$ (possibly intersecting) line
segments in 2D, we give a data structure with $O(n)$ space that can answer ray
shooting queries in $O(\sqrt{n})$ time. This improves Wang&#39;s recent data
structure [SoCG&#39;20] with $O(n\log n)$ space and $O(\sqrt{n}\log n)$ query time.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: Optimized Telecloning Circuits: Theory and Practice of Nine NISQ Clones</title>
    <link href="http://arxiv.org/abs/2210.10164"/>
    <id>http://arxiv.org/abs/2210.10164</id>
    <updated>2022-10-20T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/quant-ph/1/au:+Pelofske_E/0/1/0/all/0/1&quot;&gt;Elijah Pelofske&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/quant-ph/1/au:+Bartschi_A/0/1/0/all/0/1&quot;&gt;Andreas B&amp;#xe4;rtschi&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/quant-ph/1/au:+Eidenbenz_S/0/1/0/all/0/1&quot;&gt;Stephan Eidenbenz&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Although perfect copying of an unknown quantum state is not possible,
approximate cloning is possible in quantum mechanics. Quantum telecloning is a
variant of approximate quantum cloning which uses quantum teleportation to
allow for the use of classical communication to create physically separate
clones of a quantum state. We present results of a of $1 \rightarrow 9$
universal, symmetric, optimal quantum telecloning implementation on a cloud
accessible quantum computer - the Quantinuum H1-1 device. The H1-1 device
allows direct creation of the telecloning protocol due to real time classical
if-statements that are conditional on the mid-circuit measurement outcome of a
Bell measurement. In this implementation, we also provide an improvement over
previous work for the circuit model description of quantum telecloning, which
reduces the required gate depth and gate count for an all-to-all connectivity.
The demonstration of creating $9$ approximate clones on a quantum processor is
the largest number of clones that has been generated, telecloning or otherwise.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: Faster Matrix Multiplication via Asymmetric Hashing</title>
    <link href="http://arxiv.org/abs/2210.10173"/>
    <id>http://arxiv.org/abs/2210.10173</id>
    <updated>2022-10-20T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Duan_R/0/1/0/all/0/1&quot;&gt;Ran Duan&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Wu_H/0/1/0/all/0/1&quot;&gt;Hongxun Wu&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Zhou_R/0/1/0/all/0/1&quot;&gt;Renfei Zhou&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Fast matrix multiplication is one of the most fundamental problems in
algorithm research. The exponent of the optimal time complexity of matrix
multiplication is usually denoted by $\omega$. This paper discusses new ideas
for improving the laser method for fast matrix multiplication. We observe that
the analysis of higher powers of the Coppersmith-Winograd tensor [Coppersmith &amp;amp;
Winograd 1990] incurs a &quot;combination loss&quot;, and we partially compensate it by
using an asymmetric version of CW&#39;s hashing method. By analyzing the 8th power
of the CW tensor, we give a new bound of $\omega&amp;lt;2.37188$, which improves the
previous best bound of $\omega&amp;lt;2.37286$ [Alman &amp;amp; V.Williams 2020]. Our result
breaks the lower bound of $2.3725$ in [Ambainis et al. 2014] because of the new
method for analyzing component (constituent) tensors.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: On Hitting Times for General Quantum Markov Processes</title>
    <link href="http://arxiv.org/abs/2210.10188"/>
    <id>http://arxiv.org/abs/2210.10188</id>
    <updated>2022-10-20T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/quant-ph/1/au:+Laneve_L/0/1/0/all/0/1&quot;&gt;Lorenzo Laneve&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/quant-ph/1/au:+Tacchino_F/0/1/0/all/0/1&quot;&gt;Francesco Tacchino&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/quant-ph/1/au:+Tavernelli_I/0/1/0/all/0/1&quot;&gt;Ivano Tavernelli&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Random walks (or Markov chains) are models extensively used in theoretical
computer science. Several tools, including analysis of quantities such as
hitting and mixing times, are helpful for devising randomized algorithms. A
notable example is Sch\&quot;oning&#39;s algorithm for the satisfiability (SAT) problem.
In this work, we use the density-matrix formalism to define a quantum Markov
chain model which directly generalizes classical walks, and we show that a
common tools such as hitting times can be computed with a similar formula as
the one found in the classical theory, which we then apply to known quantum
settings such as Grover&#39;s algorithm.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: On the Perturbation Function of Ranking and Balance for Weighted Online Bipartite Matching</title>
    <link href="http://arxiv.org/abs/2210.10370"/>
    <id>http://arxiv.org/abs/2210.10370</id>
    <updated>2022-10-20T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Liang_J/0/1/0/all/0/1&quot;&gt;Jingxun Liang&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Tang_Z/0/1/0/all/0/1&quot;&gt;Zhihao Gavin Tang&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Xu_Y/0/1/0/all/0/1&quot;&gt;Yixuan Xu&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Zhang_Y/0/1/0/all/0/1&quot;&gt;Yuhao Zhang&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Zhou_R/0/1/0/all/0/1&quot;&gt;Renfei Zhou&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Ranking and Balance are arguably the two most important algorithms in the
online matching literature. They achieve the same optimal competitive ratio of
$1-1/e$ for the integral version and fractional version of online bipartite
matching by Karp, Vazirani, and Vazirani (STOC 1990) respectively. The two
algorithms have been generalized to weighted online bipartite matching
problems, including vertex-weighted online bipartite matching and AdWords, by
utilizing a perturbation function. The canonical choice of the perturbation
function is $f(x)=1-e^{x-1}$ as it leads to the optimal competitive ratio of
$1-1/e$ in both settings.
&lt;/p&gt;
&lt;p&gt;We advance the understanding of the weighted generalizations of Ranking and
Balance in this paper, with a focus on studying the effect of different
perturbation functions. First, we prove that the canonical perturbation
function is the \emph{unique} optimal perturbation function for vertex-weighted
online bipartite matching. In stark contrast, all perturbation functions
achieve the optimal competitive ratio of $1-1/e$ in the unweighted setting.
Second, we prove that the generalization of Ranking to AdWords with unknown
budgets using the canonical perturbation function is at most $0.624$
competitive, refuting a conjecture of Vazirani (2021). More generally, as an
application of the first result, we prove that no perturbation function leads
to the prominent competitive ratio of $1-1/e$ by establishing an upper bound of
$1-1/e-0.0003$.
&lt;/p&gt;
&lt;p&gt;Finally, we propose the online budget-additive welfare maximization problem
that is intermediate between AdWords and AdWords with unknown budgets, and we
design an optimal $1-1/e$ competitive algorithm by generalizing Balance.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: Near-optimal Coresets for Robust Clustering</title>
    <link href="http://arxiv.org/abs/2210.10394"/>
    <id>http://arxiv.org/abs/2210.10394</id>
    <updated>2022-10-20T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Huang_L/0/1/0/all/0/1&quot;&gt;Lingxiao Huang&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Jiang_S/0/1/0/all/0/1&quot;&gt;Shaofeng H.-C. Jiang&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Lou_J/0/1/0/all/0/1&quot;&gt;Jianing Lou&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Wu_X/0/1/0/all/0/1&quot;&gt;Xuan Wu&lt;/a&gt;&lt;/p&gt;&lt;p&gt;We consider robust clustering problems in $\mathbb{R}^d$, specifically
$k$-clustering problems (e.g., $k$-Median and $k$-Means with $m$ outliers,
where the cost for a given center set $C \subset \mathbb{R}^d$ aggregates the
distances from $C$ to all but the furthest $m$ data points, instead of all
points as in classical clustering. We focus on the $\epsilon$-coreset for
robust clustering, a small proxy of the dataset that preserves the clustering
cost within $\epsilon$-relative error for all center sets. Our main result is
an $\epsilon$-coreset of size $O(m + \mathrm{poly}(k \epsilon^{-1}))$ that can
be constructed in near-linear time. This significantly improves previous
results, which either suffers an exponential dependence on $(m + k)$ [Feldman
and Schulman, SODA&#39;12], or has a weaker bi-criteria guarantee [Huang et al.,
FOCS&#39;18]. Furthermore, we show this dependence in $m$ is nearly-optimal, and
the fact that it is isolated from other factors may be crucial for dealing with
large number of outliers. We construct our coresets by adapting to the outlier
setting a recent framework [Braverman et al., FOCS&#39;22] which was designed for
capacity-constrained clustering, overcoming a new challenge that the
participating terms in the cost, particularly the excluded $m$ outlier points,
are dependent on the center set $C$. We validate our coresets on various
datasets, and we observe a superior size-accuracy tradeoff compared with
popular baselines including uniform sampling and sensitivity sampling. We also
achieve a significant speedup of existing approximation algorithms for robust
clustering using our coresets.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: Community detection in edge-labeled graphs</title>
    <link href="http://arxiv.org/abs/2210.10583"/>
    <id>http://arxiv.org/abs/2210.10583</id>
    <updated>2022-10-20T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Kumpulainen_I/0/1/0/all/0/1&quot;&gt;Iiro Kumpulainen&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Tatti_N/0/1/0/all/0/1&quot;&gt;Nikolaj Tatti&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Finding dense communities in networks is a widely-used tool for analysis in
graph mining. A popular choice for finding such communities is to find
subgraphs with a high average degree. While useful, interpreting such subgraphs
may be difficult. On the other hand, many real-world networks have additional
information, and we are specifically interested in networks that have labels on
edges. In this paper, we study finding dense subgraphs that can be explained
with the labels on edges. More specifically, we are looking for a set of labels
so that the induced subgraph has a high average degree. There are many ways to
induce a subgraph from a set of labels, and we study two cases: First, we study
conjunctive-induced dense subgraphs, where the subgraph edges need to have all
labels. Secondly, we study disjunctive-induced dense subgraphs, where the
subgraph edges need to have at least one label. We show that both problems are
$\textbf{NP}$-hard. Because of the hardness, we resort to greedy heuristics. We
show that we can implement the greedy search efficiently: the respective
running times for finding conjunctive-induced and disjunctive-induced dense
subgraphs are in $\mathcal{O}(p \log k)$ and $\mathcal{O}(p \log^2 k)$, where
$p$ is the number of edge-label pairs and $k$ is the number of labels. Our
experimental evaluation demonstrates that we can find the ground truth in
synthetic graphs and that we can find interpretable subgraphs from real-world
networks.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: Towards Practical Explainability with Cluster Descriptors</title>
    <link href="http://arxiv.org/abs/2210.10662"/>
    <id>http://arxiv.org/abs/2210.10662</id>
    <updated>2022-10-20T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Liu_X/0/1/0/all/0/1&quot;&gt;Xiaoyuan Liu&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Tyagin_I/0/1/0/all/0/1&quot;&gt;Ilya Tyagin&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Ushijima_Mwesigwa_H/0/1/0/all/0/1&quot;&gt;Hayato Ushijima-Mwesigwa&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Ghosh_I/0/1/0/all/0/1&quot;&gt;Indradeep Ghosh&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Safro_I/0/1/0/all/0/1&quot;&gt;Ilya Safro&lt;/a&gt;&lt;/p&gt;&lt;p&gt;With the rapid development of machine learning, improving its explainability
has become a crucial research goal. We study the problem of making the clusters
more explainable by investigating the cluster descriptors. Given a set of
objects $S$, a clustering of these objects $\pi$, and a set of tags $T$ that
have not participated in the clustering algorithm. Each object in $S$ is
associated with a subset of $T$. The goal is to find a representative set of
tags for each cluster, referred to as the cluster descriptors, with the
constraint that these descriptors we find are pairwise disjoint, and the total
size of all the descriptors is minimized. In general, this problem is NP-hard.
We propose a novel explainability model that reinforces the previous models in
such a way that tags that do not contribute to explainability and do not
sufficiently distinguish between clusters are not added to the optimal
descriptors. The proposed model is formulated as a quadratic unconstrained
binary optimization problem which makes it suitable for solving on modern
optimization hardware accelerators. We experimentally demonstrate how a
proposed explainability model can be solved on specialized hardware for
accelerating combinatorial optimization, the Fujitsu Digital Annealer, and use
real-life Twitter and PubMed datasets for use cases.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">Gil Kalai: James Davies: Every finite colouring of the plane contains a monochromatic pair of points at an odd distance from each other.</title>
    <link href="https://gilkalai.wordpress.com/2022/10/19/james-davies-every-finite-colouring-of-the-plane-contains-a-monochromatic-pair-of-points-at-an-odd-distance-from-each-other/"/>
    <id>http://gilkalai.wordpress.com/?p=23446</id>
    <updated>2022-10-19T12:17:10+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p&gt;Here is a lovely piece of news: the following paper by James Davies was posted on the arXive a few weeks ago. The paper uses spectral methods to settle an &lt;strong&gt;old question, posed in 1994, by Moshe Rosenfeld. &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(&lt;/strong&gt;See this &lt;a href=&quot;https://gilkalai.wordpress.com/2009/02/21/rosenfelds-odd-distance-problem/&quot;&gt;2009 post over here&lt;/a&gt; and &lt;a href=&quot;http://193.2.67.252/index.php/amc/article/view/25&quot;&gt;this 2008 paper by Moshe&lt;/a&gt;. Rosenfeld problem first appeared in print in a 1994 paper by Paul Erdos and&lt;a href=&quot;https://asoifer.uccs.edu/&quot;&gt; Alexander Soifer&lt;/a&gt; also wrote in several places about this problem.)&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;https://arxiv.org/abs/2209.15598&quot;&gt;Odd distances in colorings of the plane&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Theorem (Davies)&lt;/strong&gt;:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;E&lt;/em&gt;&lt;span id=&quot;2209.15598v2-abstract-short&quot; class=&quot;abstract-short has-text-grey-dark mathjax&quot;&gt;&lt;em&gt;very finite colouring of the plane contains a monochromatic pair of points at an odd (integral) distance from each other.&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;The paper proves more general result and discover a new class of triangle free graphs with large chromatic number. Congratulations, James.&lt;/p&gt;
&lt;p&gt;&lt;img data-attachment-id=&quot;23455&quot; data-permalink=&quot;https://gilkalai.wordpress.com/2022/10/19/james-davies-every-finite-colouring-of-the-plane-contains-a-monochromatic-pair-of-points-at-an-odd-distance-from-each-other/soifer/&quot; data-orig-file=&quot;https://gilkalai.files.wordpress.com/2022/10/soifer.jpg&quot; data-orig-size=&quot;449,432&quot; data-comments-opened=&quot;1&quot; data-image-meta=&quot;{&amp;quot;aperture&amp;quot;:&amp;quot;1.8&amp;quot;,&amp;quot;credit&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;camera&amp;quot;:&amp;quot;SM-G986B&amp;quot;,&amp;quot;caption&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;created_timestamp&amp;quot;:&amp;quot;1665136509&amp;quot;,&amp;quot;copyright&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;focal_length&amp;quot;:&amp;quot;5.4&amp;quot;,&amp;quot;iso&amp;quot;:&amp;quot;100&amp;quot;,&amp;quot;shutter_speed&amp;quot;:&amp;quot;0.01&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;orientation&amp;quot;:&amp;quot;1&amp;quot;}&quot; data-image-title=&quot;soifer&quot; data-image-description=&quot;&quot; data-image-caption=&quot;&quot; data-medium-file=&quot;https://gilkalai.files.wordpress.com/2022/10/soifer.jpg?w=300&quot; data-large-file=&quot;https://gilkalai.files.wordpress.com/2022/10/soifer.jpg?w=449&quot; class=&quot;alignnone size-full wp-image-23455&quot; src=&quot;https://gilkalai.files.wordpress.com/2022/10/soifer.jpg?w=640&quot; alt=&quot;soifer&quot; srcset=&quot;https://gilkalai.files.wordpress.com/2022/10/soifer.jpg 449w, https://gilkalai.files.wordpress.com/2022/10/soifer.jpg?w=150 150w, https://gilkalai.files.wordpress.com/2022/10/soifer.jpg?w=300 300w&quot; sizes=&quot;(max-width: 449px) 100vw, 449px&quot;   /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color:#ff0000;&quot;&gt;Challenge: what is the smallest odd distance between a monochromatic pair in the Hoffman-Soifer coloring?&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;authors&quot;&gt;By Gil Kalai&lt;/p&gt;
  </content>
    <author>
      <name>Gil Kalai</name>
      <uri>https://gilkalai.wordpress.com</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Computational Complexity: Phase transition in the computational complexity of the shortest common superstring and genome assembly</title>
    <link href="http://arxiv.org/abs/2210.09986"/>
    <id>http://arxiv.org/abs/2210.09986</id>
    <updated>2022-10-19T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cond-mat/1/au:+Fernandez_L/0/1/0/all/0/1&quot;&gt;L. A. Fernandez&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cond-mat/1/au:+Martin_Mayor_V/0/1/0/all/0/1&quot;&gt;V. Martin-Mayor&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cond-mat/1/au:+Yllanes_D/0/1/0/all/0/1&quot;&gt;D. Yllanes&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Genome assembly, the process of reconstructing a long genetic sequence by
aligning and merging short fragments, or reads, is known to be NP-hard, either
as a version of the shortest common superstring problem or in a
Hamiltonian-cycle formulation. That is, the computing time is believed to grow
exponentially with the the problem size in the worst case. Despite this fact,
high-throughput technologies and modern algorithms currently allow
bioinformaticians to produce and assemble datasets of billions of reads. Using
methods from statistical mechanics, we address this conundrum by demonstrating
the existence of a phase transition in the computational complexity of the
problem and showing that practical instances always fall in the `easy&#39; phase
(solvable by polynomial-time algorithms). In addition, we propose a
Markov-chain Monte Carlo method that outperforms common deterministic
algorithms in the hard regime.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Computational Complexity</name>
      <uri>https://arxiv.org/list/cs.CC/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: First Order Logic on Pathwidth Revisited Again</title>
    <link href="http://arxiv.org/abs/2210.09899"/>
    <id>http://arxiv.org/abs/2210.09899</id>
    <updated>2022-10-19T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Lampis_M/0/1/0/all/0/1&quot;&gt;Michael Lampis&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Courcelle&#39;s celebrated theorem states that all MSO-expressible properties can
be decided in linear time on graphs of bounded treewidth. Unfortunately, the
hidden constant implied by this theorem is a tower of exponentials whose height
increases with each quantifier alternation in the formula. More devastatingly,
this cannot be improved, under standard assumptions, even if we consider the
much more restricted problem of deciding FO-expressible properties on trees.
&lt;/p&gt;
&lt;p&gt;In this paper we revisit this well-studied topic and identify a natural
special case where the dependence of Courcelle&#39;s theorem can, in fact, be
improved. Specifically, we show that all FO-expressible properties can be
decided with an elementary dependence on the input formula, if the input graph
has bounded pathwidth (rather than treewidth). This is a rare example of
treewidth and pathwidth having different complexity behaviors. Our result is
also in sharp contrast with MSO logic on graphs of bounded pathwidth, where it
is known that the dependence has to be non-elementary, under standard
assumptions. Our work builds upon, and generalizes, a corresponding
meta-theorem by Gajarsk{\&#39;{y}} and Hlin{\v{e}}n{\&#39;{y}} for the more restricted
class of graphs of bounded tree-depth.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: Clustering Categorical Data: Soft Rounding k-modes</title>
    <link href="http://arxiv.org/abs/2210.09640"/>
    <id>http://arxiv.org/abs/2210.09640</id>
    <updated>2022-10-19T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Gavva_S/0/1/0/all/0/1&quot;&gt;Surya Teja Gavva&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+S%2E_K/0/1/0/all/0/1&quot;&gt;Karthik C. S.&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Punna_S/0/1/0/all/0/1&quot;&gt;Sharath Punna&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Over the last three decades, researchers have intensively explored various
clustering tools for categorical data analysis. Despite the proposal of various
clustering algorithms, the classical k-modes algorithm remains a popular choice
for unsupervised learning of categorical data. Surprisingly, our first insight
is that in a natural generative block model, the k-modes algorithm performs
poorly for a large range of parameters. We remedy this issue by proposing a
soft rounding variant of the k-modes algorithm (SoftModes) and theoretically
prove that our variant addresses the drawbacks of the k-modes algorithm in the
generative model. Finally, we empirically verify that SoftModes performs well
on both synthetic and real-world datasets.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: Capacitated Vehicle Routing in Graphic Metrics</title>
    <link href="http://arxiv.org/abs/2210.09806"/>
    <id>http://arxiv.org/abs/2210.09806</id>
    <updated>2022-10-19T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Momke_T/0/1/0/all/0/1&quot;&gt;Tobias M&amp;#xf6;mke&lt;/a&gt;, &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Zhou_H/0/1/0/all/0/1&quot;&gt;Hang Zhou&lt;/a&gt;&lt;/p&gt;&lt;p&gt;We study the capacitated vehicle routing problem in graphic metrics (graphic
CVRP). Our main contribution is a new lower bound on the cost of an optimal
solution. For graphic metrics, this lower bound is tight and significantly
stronger than the well-known bound for general metrics. The proof of the new
lower bound is simple and combinatorial. Using this lower bound, we analyze the
approximation ratio of the classical iterated tour partitioning algorithm
combined with the TSP algorithms for graphic metrics of Christofides [1976], of
M\&quot;omke-Svensson [JACM 2016], and of Seb\H{o}-Vygen [Combinatorica 2014]. In
particular, we obtain a 1.95-approximation for the graphic CVRP.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: Performance evaluation of approximation algorithms for the minimum size 2-vertex strongly connected subgraph problem</title>
    <link href="http://arxiv.org/abs/2210.09844"/>
    <id>http://arxiv.org/abs/2210.09844</id>
    <updated>2022-10-19T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Habib_A/0/1/0/all/0/1&quot;&gt;Azzam Habib&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Jaberi [7] presented approximation algorithms for the problem of computing a
minimum size 2-vertex strongly biconnected subgraph in directed graphs. We have
implemented approximation algorithms presented in [7] and we have tested the
implementation on some graphs. The experimental results show that these
algorithms work well in practice.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


  <entry xml:lang="en">
    <title type="html" xml:lang="en">arXiv: Data Structures and Algorithms: Computing MEMs on Repetitive Text Collections</title>
    <link href="http://arxiv.org/abs/2210.09914"/>
    <id>http://arxiv.org/abs/2210.09914</id>
    <updated>2022-10-19T00:30:00+00:00</updated>
    <content type="html" xml:lang="en">
    &lt;p class=&quot;arxiv-authors&quot;&gt;&lt;b&gt;Authors:&lt;/b&gt; &lt;a href=&quot;http://arxiv.org/find/cs/1/au:+Navarro_G/0/1/0/all/0/1&quot;&gt;Gonzalo Navarro&lt;/a&gt;&lt;/p&gt;&lt;p&gt;We consider the problem of computing the Maximal Exact Matches (MEMs) of a
given pattern $P[1..m]$ on a large repetitive text collection $T[1..n]$, which
is represented as a (hopefully much smaller) run-length context-free grammar of
size $g_{rl}$. We show that the problem can be solved in time $O(m^2
\log^\epsilon n)$, for any constant $\epsilon &amp;gt; 0$, on a data structure of size
$O(g_{rl})$. Further, on a locally consistent grammar of size
$O(\delta\log\frac{n}{\delta})$, the time decreases to $O(m\log m(\log m +
\log^\epsilon n))$. The value $\delta$ is a function of the substring
complexity of $T$ and $\Omega(\delta\log\frac{n}{\delta})$ is a tight lower
bound on the compressibility of repetitive texts $T$, so our structure has
optimal size in terms of $n$ and $\delta$.
&lt;/p&gt;
  </content>
    <author>
      <name>arXiv: Data Structures and Algorithms</name>
      <uri>https://arxiv.org/list/cs.DS/recent</uri>
    </author>
  </entry>


</feed>
