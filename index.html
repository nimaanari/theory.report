<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-0RQ5M78VX5"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-0RQ5M78VX5');
  </script>
  <meta charset='utf-8'>
  <meta name='generator' content='Pluto 1.6.2 on Ruby 3.0.4 (2022-04-12) [x86_64-linux]'>

  <title>Theory of Computing Report</title>

  <link rel="alternate" type="application/rss+xml" title="Posts (RSS)" href="rss20.xml" />
  <link rel="alternate" type="application/atom+xml" title="Posts (Atom)" href="atom.xml" />
  
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">

  <link rel='stylesheet' type='text/css' href='css/font-awesome.css'>
  <link rel='stylesheet' type='text/css' href='css/blank.css'>
</head>
<body>
  <div id='navwrap'>
    <div id='nav'>
      <p>
        Last Update
      </p>
      <p class='small'>
        
          <time class='timeago' datetime="2022-10-11T15:47:24Z">Tuesday, October 11 2022, 15:47</time>
        
      </p>

      <p>Feeds</p>
      <ul class='subscriptions small' >
      
        <li>
          <a href='http://arxiv.org/rss/cs.CC'><img src='i/feed.png'></a>
          <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a>
          
        </li>
      
        <li>
          <a href='http://arxiv.org/rss/cs.CG'><img src='i/feed.png'></a>
          <a href='https://arxiv.org/list/cs.CG/recent'>arXiv: Computational Geometry</a>
          
        </li>
      
        <li>
          <a href='http://arxiv.org/rss/cs.DS'><img src='i/feed.png'></a>
          <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a>
          
        </li>
      
        <li>
          <a href='http://aaronsadventures.blogspot.com/feeds/posts/default'><img src='i/feed.png'></a>
          <a href='http://aaronsadventures.blogspot.com/'>Aaron Roth</a>
          
        </li>
      
        <li>
          <a href='https://adamsheffer.wordpress.com/feed/'><img src='i/feed.png'></a>
          <a href='https://adamsheffer.wordpress.com'>Adam Sheffer</a>
          
        </li>
      
        <li>
          <a href='https://adamdsmith.wordpress.com/feed/'><img src='i/feed.png'></a>
          <a href='https://adamdsmith.wordpress.com'>Adam Smith</a>
          
        </li>
      
        <li>
          <a href='https://polylogblog.wordpress.com/feed/'><img src='i/feed.png'></a>
          <a href='https://polylogblog.wordpress.com'>Andrew McGregor</a>
          
        </li>
      
        <li>
          <a href='https://corner.mimuw.edu.pl/?feed=rss2'><img src='i/feed.png'></a>
          <a href='https://corner.mimuw.edu.pl'>Banach's Algorithmic Corner</a>
          
        </li>
      
        <li>
          <a href='http://www.argmin.net/feed.xml'><img src='i/feed.png'></a>
          <a href='http://benjamin-recht.github.io/'>Ben Recht</a>
          
        </li>
      
        <li>
          <a href='http://bit-player.org/feed/atom/'><img src='i/feed.png'></a>
          <a href='http://bit-player.org'>bit-player</a>
          
        </li>
      
        <li>
          <a href='https://cstheory-jobs.org/feed/'><img src='i/feed.png'></a>
          <a href='https://cstheory-jobs.org'>CCI: jobs</a>
          
        </li>
      
        <li>
          <a href='https://cstheory-events.org/feed/'><img src='i/feed.png'></a>
          <a href='https://cstheory-events.org'>CS Theory Events</a>
          
        </li>
      
        <li>
          <a href='http://blog.computationalcomplexity.org/feeds/posts/default'><img src='i/feed.png'></a>
          <a href='http://blog.computationalcomplexity.org/'>Computational Complexity</a>
          
        </li>
      
        <li>
          <a href='https://11011110.github.io/blog/feed.xml'><img src='i/feed.png'></a>
          <a href='https://11011110.github.io/blog/'>David Eppstein</a>
          
        </li>
      
        <li>
          <a href='https://daveagp.wordpress.com/category/toc/feed/'><img src='i/feed.png'></a>
          <a href='https://daveagp.wordpress.com'>David Pritchard</a>
          
        </li>
      
        <li>
          <a href='https://decentdescent.org/feed.xml'><img src='i/feed.png'></a>
          <a href='https://decentdescent.org/'>Decent Descent</a>
          
        </li>
      
        <li>
          <a href='https://decentralizedthoughts.github.io/feed'><img src='i/feed.png'></a>
          <a href='https://decentralizedthoughts.github.io'>Decentralized Thoughts</a>
          
        </li>
      
        <li>
          <a href='https://differentialprivacy.org/feed.xml'><img src='i/feed.png'></a>
          <a href='https://differentialprivacy.org'>DifferentialPrivacy.org</a>
          
        </li>
      
        <li>
          <a href='https://eccc.weizmann.ac.il//feeds/reports/'><img src='i/feed.png'></a>
          <a href='https://eccc.weizmann.ac.il/'>ECCC Papers</a>
          
        </li>
      
        <li>
          <a href='https://emanueleviola.wordpress.com/feed/'><img src='i/feed.png'></a>
          <a href='https://emanueleviola.wordpress.com'>Emanuele Viola</a>
          
        </li>
      
        <li>
          <a href='https://3dpancakes.typepad.com/ernie/atom.xml'><img src='i/feed.png'></a>
          <a href='https://3dpancakes.typepad.com/ernie/'>Ernie's 3D Pancakes</a>
          
        </li>
      
        <li>
          <a href='https://dstheory.wordpress.com/feed/'><img src='i/feed.png'></a>
          <a href='https://dstheory.wordpress.com'>Foundation of Data Science - Virtual Talk Series</a>
          
        </li>
      
        <li>
          <a href='https://francisbach.com/feed/'><img src='i/feed.png'></a>
          <a href='https://francisbach.com'>Francis Bach</a>
          
        </li>
      
        <li>
          <a href='https://gilkalai.wordpress.com/feed/'><img src='i/feed.png'></a>
          <a href='https://gilkalai.wordpress.com'>Gil Kalai</a>
          
        </li>
      
        <li>
          <a href='https://blogs.oregonstate.edu:443/glencora/tag/tcs/feed/'><img src='i/feed.png'></a>
          <a href='https://blogs.oregonstate.edu/glencora'>Glencora Borradaile</a>
          
        </li>
      
        <li>
          <a href='https://research.googleblog.com/feeds/posts/default/-/Algorithms'><img src='i/feed.png'></a>
          <a href='https://research.googleblog.com/search/label/Algorithms'>Google Research Blog: Algorithms</a>
          
        </li>
      
        <li>
          <a href='https://gradientscience.org/feed.xml'><img src='i/feed.png'></a>
          <a href='https://gradientscience.org/'>Gradient Science</a>
          
        </li>
      
        <li>
          <a href='http://grigory.us/blog/feed.xml'><img src='i/feed.png'></a>
          <a href='http://grigory.github.io/blog'>Grigory Yaroslavtsev</a>
          
        </li>
      
        <li>
          <a href='https://tcsmath.wordpress.com/feed/'><img src='i/feed.png'></a>
          <a href='https://tcsmath.wordpress.com'>James R. Lee</a>
          
        </li>
      
        <li>
          <a href='https://kamathematics.wordpress.com/feed/'><img src='i/feed.png'></a>
          <a href='https://kamathematics.wordpress.com'>Kamathematics</a>
          
        </li>
      
        <li>
          <a href='http://processalgebra.blogspot.com/feeds/posts/default'><img src='i/feed.png'></a>
          <a href='http://processalgebra.blogspot.com/'>Luca Aceto</a>
          
        </li>
      
        <li>
          <a href='https://lucatrevisan.wordpress.com/feed/'><img src='i/feed.png'></a>
          <a href='https://lucatrevisan.wordpress.com'>Luca Trevisan</a>
          
        </li>
      
        <li>
          <a href='https://mittheory.wordpress.com/feed/'><img src='i/feed.png'></a>
          <a href='https://mittheory.wordpress.com'>MIT CSAIL Student Blog</a>
          
        </li>
      
        <li>
          <a href='http://mybiasedcoin.blogspot.com/feeds/posts/default'><img src='i/feed.png'></a>
          <a href='http://mybiasedcoin.blogspot.com/'>Michael Mitzenmacher</a>
          
        </li>
      
        <li>
          <a href='http://blog.mrtz.org/feed.xml'><img src='i/feed.png'></a>
          <a href='http://blog.mrtz.org/'>Moritz Hardt</a>
          
        </li>
      
        <li>
          <a href='http://mysliceofpizza.blogspot.com/feeds/posts/default/-/aggregator'><img src='i/feed.png'></a>
          <a href='http://mysliceofpizza.blogspot.com/search/label/aggregator'>Muthu Muthukrishnan</a>
          
        </li>
      
        <li>
          <a href='https://nisheethvishnoi.wordpress.com/feed/'><img src='i/feed.png'></a>
          <a href='https://nisheethvishnoi.wordpress.com'>Nisheeth Vishnoi</a>
          
        </li>
      
        <li>
          <a href='http://www.solipsistslog.com/feed/'><img src='i/feed.png'></a>
          <a href='http://www.solipsistslog.com'>Noah Stephens-Davidowitz</a>
          
        </li>
      
        <li>
          <a href='http://www.offconvex.org/feed.xml'><img src='i/feed.png'></a>
          <a href='http://offconvex.github.io/'>Off the Convex Path</a>
          
        </li>
      
        <li>
          <a href='http://paulwgoldberg.blogspot.com/feeds/posts/default/-/aggregator'><img src='i/feed.png'></a>
          <a href='http://paulwgoldberg.blogspot.com/search/label/aggregator'>Paul Goldberg</a>
          
        </li>
      
        <li>
          <a href='https://ptreview.sublinear.info/?feed=rss2'><img src='i/feed.png'></a>
          <a href='https://ptreview.sublinear.info'>Property Testing Review</a>
          
        </li>
      
        <li>
          <a href='https://rjlipton.wpcomstaging.com/feed/'><img src='i/feed.png'></a>
          <a href='https://rjlipton.wpcomstaging.com'>Richard Lipton</a>
          
        </li>
      
        <li>
          <a href='https://blogs.princeton.edu/imabandit/feed/'><img src='i/feed.png'></a>
          <a href='https://blogs.princeton.edu/imabandit'>Sébastien Bubeck</a>
          
        </li>
      
        <li>
          <a href='https://scottaaronson.blog/?feed=atom'><img src='i/feed.png'></a>
          <a href='https://scottaaronson.blog'>Scott Aaronson</a>
          
        </li>
      
        <li>
          <a href='https://blog.simons.berkeley.edu/feed/'><img src='i/feed.png'></a>
          <a href='https://blog.simons.berkeley.edu'>Simons Institute Blog</a>
          
        </li>
      
        <li>
          <a href='https://tcsplus.wordpress.com/feed/'><img src='i/feed.png'></a>
          <a href='https://tcsplus.wordpress.com'>TCS+ Seminar Series</a>
          
        </li>
      
        <li>
          <a href='https://toc4fairness.org/feed/'><img src='i/feed.png'></a>
          <a href='https://toc4fairness.org'>TOC for Fairness</a>
          
        </li>
      
        <li>
          <a href='http://www.blogger.com/feeds/6555947/posts/default?alt=atom'><img src='i/feed.png'></a>
          <a href='http://blog.geomblog.org/'>The Geomblog</a>
          
        </li>
      
        <li>
          <a href='https://www.let-all.com/blog/feed/'><img src='i/feed.png'></a>
          <a href='https://www.let-all.com/blog'>The Learning Theory Alliance Blog</a>
          
        </li>
      
        <li>
          <a href='https://theorydish.blog/feed/'><img src='i/feed.png'></a>
          <a href='https://theorydish.blog'>Theory Dish: Stanford Blog</a>
          
        </li>
      
        <li>
          <a href='https://thmatters.wordpress.com/feed/'><img src='i/feed.png'></a>
          <a href='https://thmatters.wordpress.com'>Theory Matters</a>
          
        </li>
      
        <li>
          <a href='https://mycqstate.wordpress.com/feed/'><img src='i/feed.png'></a>
          <a href='https://mycqstate.wordpress.com'>Thomas Vidick</a>
          
        </li>
      
        <li>
          <a href='https://agtb.wordpress.com/feed/'><img src='i/feed.png'></a>
          <a href='https://agtb.wordpress.com'>Turing's Invisible Hand</a>
          
        </li>
      
        <li>
          <a href='https://windowsontheory.org/feed/'><img src='i/feed.png'></a>
          <a href='https://windowsontheory.org'>Windows on Theory</a>
          
        </li>
      
      </ul>

      <p class='small'><a href="opml.xml">OPML feed</a> of all feeds.</p>
      <p class='small'>Subscribe to the <a href="atom.xml">Atom feed</a> or <a href="rss20.xml">RSS feed</a> to stay up to date.</p>
      <p class='small'>Source on <a href="https://github.com/nimaanari/theory.report">GitHub</a>.</p>
      <p class='small'>Maintained by Nima Anari, Arnab Bhattacharyya, Gautam Kamath.</p>
      <p class='small'>Powered by <a href='https://github.com/feedreader'>Pluto</a>.</p>
    </div>
  </div>

  <div id='opts'>
    <div style='width: 100%; text-align: right;'>
    <img src='i/view-headlines.png' id='show-headlines' title='Show Headlines Only' width='24' height='24'>
    <img src='i/view-snippets.png' id='show-snippets' title='Show Snippets' width='24' height='24'>
    <img src='i/view-standard.png' id='show-fulltext' title='Show Full Text' width='24' height='24'>
    </div>
  </div>

  <h1>
    Theory of Computing Report
  </h1>

  <div id="articles">
    
    
    <h2 class='new-date'>
      <i class='icon-calendar-empty'></i> Tuesday, October 11
    </h2>
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='https://gilkalai.wordpress.com/2022/10/11/test-your-intuition-51/'>Test Your intuition 51</a></h3>
          <p class='item-feed'>from <a href='https://gilkalai.wordpress.com'>Gil Kalai</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          Suppose that and are two compact convex sets in space. Suppose that contains . Now consider two quantities is the average volume of a simplex forms by four points in drawn uniformly at random. is the average volume of a &#8230; Continue reading &#8594;
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p></p>



<p></p>


<p>Suppose that <img src="https://s0.wp.com/latex.php?latex=K&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=K&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=K&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="K" class="latex" /> and <img src="https://s0.wp.com/latex.php?latex=L&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=L&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=L&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="L" class="latex" /> are two compact convex sets in space. Suppose that <img src="https://s0.wp.com/latex.php?latex=K&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=K&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=K&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="K" class="latex" /> <span style="color:#0000ff;"><strong>contains</strong></span> <img src="https://s0.wp.com/latex.php?latex=L&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=L&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=L&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="L" class="latex" />. Now consider two quantities</p>
<ul>
<li><img src="https://s0.wp.com/latex.php?latex=X&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=X&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=X&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="X" class="latex" /> is the average volume of a simplex forms by four points in <img src="https://s0.wp.com/latex.php?latex=K&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=K&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=K&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="K" class="latex" /> drawn uniformly at random.</li>
<li><img src="https://s0.wp.com/latex.php?latex=Y&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=Y&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=Y&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="Y" class="latex" /> is the average volume of a simplex forms by four points in <img src="https://s0.wp.com/latex.php?latex=L&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002" srcset="https://s0.wp.com/latex.php?latex=L&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002 1x, https://s0.wp.com/latex.php?latex=L&#038;bg=ffffff&#038;fg=333333&#038;s=0&#038;c=20201002&#038;zoom=4.5 4x" alt="L" class="latex" /> drawn uniformly at random.</li>
</ul>
<h3>TYI: Is it always the case that X ≥ Y?</h3><p class="authors">By Gil Kalai</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-11T09:05:53Z">Tuesday, October 11 2022, 09:05</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='https://cstheory-jobs.org/2022/10/11/postdoc-at-technion-apply-by-december-31-2022/'>Postdoc  at Technion (apply by December 31, 2022)</a></h3>
          <p class='item-feed'>from <a href='https://cstheory-jobs.org'>CCI: jobs</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          Candidates with a strong publication record in top venues in distributed computing (broadly interpreted) or algorithms in general are welcome to apply. To apply, send the following to Mrs. Hila Mizrahi at hilamiz@cs.technion.ac.il: 1. CV (PDF) 2. 1-2 page research statement (PDF) 3. Contact details of 3 references (email plaintext) 4. Expected graduation date, if [&#8230;]
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p>Candidates with a strong publication record in top venues in distributed computing (broadly interpreted) or algorithms in general are welcome to apply. To apply, send the following to Mrs. Hila Mizrahi at hilamiz@cs.technion.ac.il: 1. CV (PDF)<br />
2. 1-2 page research statement (PDF)<br />
3. Contact details of 3 references (email plaintext)<br />
4. Expected graduation date, if applicable (email plaintext)</p>
<p>Website: <a href="https://ckeren.net.technion.ac.il/">https://ckeren.net.technion.ac.il/</a><br />
Email: hilamiz@cs.technion.ac.il</p>
<p class="authors">By shacharlovett</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-11T08:13:20Z">Tuesday, October 11 2022, 08:13</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.03839'>Edge deletion to tree-like graph classes</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Ivo Koch, Nina Pardal, Vinicius Fernandes dos Santos</p><p>For a fixed property (graph class) $\Pi$, given a graph $G$ and an integer
$k$, the $\Pi$-deletion problem consists in deciding if we can turn $G$ into a
graph with the property $\Pi$ by deleting at most $k$ edges of $G$. The
$\Pi$-deletion problem is known to be NP-hard for most of the well-studied
graph classes (such as chordal, interval, bipartite, planar, comparability and
permutation graphs, among others), with the notable exception of trees.
Motivated by this fact, in this work we study the deletion problem for some
classes close to trees. We obtain NP-hardness results for several classes of
sparse graphs, for which we prove that deletion is hard even when the input is
a bipartite graph. In addition, we give sufficient structural conditions for
the graph class $\Pi$ for NP-hardness. In the case of deletion to cactus, we
show that the problem becomes tractable when the input is chordal, and we give
polynomial-time algorithms for quasi-threshold graphs.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Koch_I/0/1/0/all/0/1">Ivo Koch</a>, <a href="http://arxiv.org/find/cs/1/au:+Pardal_N/0/1/0/all/0/1">Nina Pardal</a>, <a href="http://arxiv.org/find/cs/1/au:+Santos_V/0/1/0/all/0/1">Vinicius Fernandes dos Santos</a></p><p>For a fixed property (graph class) $\Pi$, given a graph $G$ and an integer
$k$, the $\Pi$-deletion problem consists in deciding if we can turn $G$ into a
graph with the property $\Pi$ by deleting at most $k$ edges of $G$. The
$\Pi$-deletion problem is known to be NP-hard for most of the well-studied
graph classes (such as chordal, interval, bipartite, planar, comparability and
permutation graphs, among others), with the notable exception of trees.
Motivated by this fact, in this work we study the deletion problem for some
classes close to trees. We obtain NP-hardness results for several classes of
sparse graphs, for which we prove that deletion is hard even when the input is
a bipartite graph. In addition, we give sufficient structural conditions for
the graph class $\Pi$ for NP-hardness. In the case of deletion to cactus, we
show that the problem becomes tractable when the input is chordal, and we give
polynomial-time algorithms for quasi-threshold graphs.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-11T00:30:00Z">Tuesday, October 11 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.03934'>Automata Equipped with Auxiliary Data Structures and Regular Realizability Problems</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Alexander Rubtsov, Mikhail Vyalyi</p><p>We consider general computational models: one-way and two-way finite
automata, and logarithmic space Turing machines, all equipped with an auxiliary
data structure (ADS). The definition of an ADS is based on the language of
protocols of work with the ADS. We describe the connection of automata-based
models with ``Balloon automata'' that are another general formalization of
automata equipped with an ADS presented by Hopcroft and Ullman in 1967.
</p>
<p>This definition establishes the connection between the non-emptiness problem
for one-way automata with ADS, languages recognizable by nondeterministic
log-space Turing machines equipped with the same ADS, and a regular
realizability problem (NRR) for the language of ADS' protocols. The NRR problem
is to verify whether the regular language on the input has a non-empty
intersection with the language of protocols. The computational complexity of
these problems (and languages) is the same up to log-space reductions.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Rubtsov_A/0/1/0/all/0/1">Alexander Rubtsov</a>, <a href="http://arxiv.org/find/cs/1/au:+Vyalyi_M/0/1/0/all/0/1">Mikhail Vyalyi</a></p><p>We consider general computational models: one-way and two-way finite
automata, and logarithmic space Turing machines, all equipped with an auxiliary
data structure (ADS). The definition of an ADS is based on the language of
protocols of work with the ADS. We describe the connection of automata-based
models with ``Balloon automata'' that are another general formalization of
automata equipped with an ADS presented by Hopcroft and Ullman in 1967.
</p>
<p>This definition establishes the connection between the non-emptiness problem
for one-way automata with ADS, languages recognizable by nondeterministic
log-space Turing machines equipped with the same ADS, and a regular
realizability problem (NRR) for the language of ADS' protocols. The NRR problem
is to verify whether the regular language on the input has a non-empty
intersection with the language of protocols. The computational complexity of
these problems (and languages) is the same up to log-space reductions.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-11T00:30:00Z">Tuesday, October 11 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.04045'>The FBHHRBNRSSSHK-Algorithm for Multiplication in $\mathbb{Z}_2^{5\times5}$ is still not the end of the story 2</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Manuel Kauers, Jakob Moosbauer</p><p>In response to a recent Nature article which announced an algorithm for
multiplying $5\times5$-matrices over $\mathbb{Z}_2$ with only 96
multiplications, two fewer than the previous record, we present an algorithm
that does the job with only 95 multiplications.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Kauers_M/0/1/0/all/0/1">Manuel Kauers</a>, <a href="http://arxiv.org/find/cs/1/au:+Moosbauer_J/0/1/0/all/0/1">Jakob Moosbauer</a></p><p>In response to a recent Nature article which announced an algorithm for
multiplying $5\times5$-matrices over $\mathbb{Z}_2$ with only 96
multiplications, two fewer than the previous record, we present an algorithm
that does the job with only 95 multiplications.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-11T00:30:00Z">Tuesday, October 11 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.03964'>An Efficient and Continuous Voronoi Density Estimator</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.CG/recent'>arXiv: Computational Geometry</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Giovanni Luca Marchetti, Vladislav Polianskii, Anastasiia Varava, Florian T. Pokorny, Danica Kragic</p><p>We introduce a non-parametric density estimator deemed Radial Voronoi Density
Estimator (RVDE). RVDE is grounded in the geometry of Voronoi tessellations and
as such benefits from local geometric adaptiveness and broad convergence
properties. Due to its radial definition RVDE is moreover continuous and
computable in linear time with respect to the dataset size. This amends for the
main shortcomings of previously studied VDEs, which are highly discontinuous
and computationally expensive. We provide a theoretical study of the modes of
RVDE as well as an empirical investigation of its performance on
high-dimensional data. Results show that RVDE outperforms other non-parametric
density estimators, including recently introduced VDEs.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/stat/1/au:+Marchetti_G/0/1/0/all/0/1">Giovanni Luca Marchetti</a>, <a href="http://arxiv.org/find/stat/1/au:+Polianskii_V/0/1/0/all/0/1">Vladislav Polianskii</a>, <a href="http://arxiv.org/find/stat/1/au:+Varava_A/0/1/0/all/0/1">Anastasiia Varava</a>, <a href="http://arxiv.org/find/stat/1/au:+Pokorny_F/0/1/0/all/0/1">Florian T. Pokorny</a>, <a href="http://arxiv.org/find/stat/1/au:+Kragic_D/0/1/0/all/0/1">Danica Kragic</a></p><p>We introduce a non-parametric density estimator deemed Radial Voronoi Density
Estimator (RVDE). RVDE is grounded in the geometry of Voronoi tessellations and
as such benefits from local geometric adaptiveness and broad convergence
properties. Due to its radial definition RVDE is moreover continuous and
computable in linear time with respect to the dataset size. This amends for the
main shortcomings of previously studied VDEs, which are highly discontinuous
and computationally expensive. We provide a theoretical study of the modes of
RVDE as well as an empirical investigation of its performance on
high-dimensional data. Results show that RVDE outperforms other non-parametric
density estimators, including recently introduced VDEs.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-11T00:30:00Z">Tuesday, October 11 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.04090'>APUD(1,1) Recognition in Polynomial Time</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.CG/recent'>arXiv: Computational Geometry</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Deniz A&#x11f;ao&#x11f;lu &#xc7;a&#x11f;&#x131;r&#x131;c&#x131;, Onur &#xc7;a&#x11f;&#x131;r&#x131;c&#x131;</p><p>A unit disk graph is the intersection graph of a set of disk of unit radius
in the Euclidean plane. In 1998, Breu and Kirkpatrick showed that the
recognition problem for unit disk graphs is NP-hard. Given $k$ horizontal and
$m$ vertical lines, an APUD($k,m$) is a unit disk graph such that each unit
disk is centered either on a given horizontal or vertical line.
\c{C}a\u{g}{\i}r{\i}c{\i} showed in 2020 that APUD($k,m$) recognition is
NP-hard. In this paper, we show that APUD($1,1$) recognition is polynomial time
solvable.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Cagirici_D/0/1/0/all/0/1">Deniz A&#x11f;ao&#x11f;lu &#xc7;a&#x11f;&#x131;r&#x131;c&#x131;</a>, <a href="http://arxiv.org/find/cs/1/au:+Cagirici_O/0/1/0/all/0/1">Onur &#xc7;a&#x11f;&#x131;r&#x131;c&#x131;</a></p><p>A unit disk graph is the intersection graph of a set of disk of unit radius
in the Euclidean plane. In 1998, Breu and Kirkpatrick showed that the
recognition problem for unit disk graphs is NP-hard. Given $k$ horizontal and
$m$ vertical lines, an APUD($k,m$) is a unit disk graph such that each unit
disk is centered either on a given horizontal or vertical line.
\c{C}a\u{g}{\i}r{\i}c{\i} showed in 2020 that APUD($k,m$) recognition is
NP-hard. In this paper, we show that APUD($1,1$) recognition is polynomial time
solvable.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-11T00:30:00Z">Tuesday, October 11 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.04099'>Developable Quad Meshes</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.CG/recent'>arXiv: Computational Geometry</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Victor Ceballos Inza, Florian Rist, Johannes Wallner, Helmut Pottmann</p><p>There are different ways to capture the property of a surface being
developable, i.e., it can be mapped to a planar domain without stretching or
tearing. Contributions range from special parametrizations to
discrete-isometric mappings. So far, a local criterion expressing the
developability of general quad meshes has been lacking. In this paper, we
propose a new and efficient discrete developability criterion that is based on
a property well-known from differential geometry, namely a rank-deficient
second fundamental form. This criterion is expressed in terms of the canonical
checkerboard patterns inscribed in a quad mesh which already was successful in
describing discrete-isometric mappings. In combination with standard global
optimization procedures, we are able to perform developable lofting,
approximation, and design. The meshes we employ are combinatorially regular
quad meshes with isolated singularities but are otherwise not required to
follow any special curves. They are thus easily embedded into a design workflow
involving standard operations like re-meshing, trimming, and merging
operations.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Inza_V/0/1/0/all/0/1">Victor Ceballos Inza</a>, <a href="http://arxiv.org/find/cs/1/au:+Rist_F/0/1/0/all/0/1">Florian Rist</a>, <a href="http://arxiv.org/find/cs/1/au:+Wallner_J/0/1/0/all/0/1">Johannes Wallner</a>, <a href="http://arxiv.org/find/cs/1/au:+Pottmann_H/0/1/0/all/0/1">Helmut Pottmann</a></p><p>There are different ways to capture the property of a surface being
developable, i.e., it can be mapped to a planar domain without stretching or
tearing. Contributions range from special parametrizations to
discrete-isometric mappings. So far, a local criterion expressing the
developability of general quad meshes has been lacking. In this paper, we
propose a new and efficient discrete developability criterion that is based on
a property well-known from differential geometry, namely a rank-deficient
second fundamental form. This criterion is expressed in terms of the canonical
checkerboard patterns inscribed in a quad mesh which already was successful in
describing discrete-isometric mappings. In combination with standard global
optimization procedures, we are able to perform developable lofting,
approximation, and design. The meshes we employ are combinatorially regular
quad meshes with isolated singularities but are otherwise not required to
follow any special curves. They are thus easily embedded into a design workflow
involving standard operations like re-meshing, trimming, and merging
operations.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-11T00:30:00Z">Tuesday, October 11 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.03932'>A Finite Algorithm for the Realizabilty of a Delaunay Triangulation</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Akanksha Agrawal, Saket Saurabh, Meirav Zehavi</p><p>The \emph{Delaunay graph} of a point set $P \subseteq \mathbb{R}^2$ is the
plane graph with the vertex-set $P$ and the edge-set that contains $\{p,p'\}$
if there exists a disc whose intersection with $P$ is exactly $\{p,p'\}$.
Accordingly, a triangulated graph $G$ is \emph{Delaunay realizable} if there
exists a triangulation of the Delaunay graph of some $P \subseteq
\mathbb{R}^2$, called a \emph{Delaunay triangulation} of $P$, that is
isomorphic to $G$. The objective of \textsc{Delaunay Realization} is to compute
a point set $P \subseteq \mathbb{R}^2$ that realizes a given graph $G$ (if such
a $P$ exists). Known algorithms do not solve \textsc{Delaunay Realization} as
they are non-constructive. Obtaining a constructive algorithm for
\textsc{Delaunay Realization} was mentioned as an open problem by Hiroshima et
al.~\cite{hiroshima2000}. We design an $n^{\mathcal{O}(n)}$-time constructive
algorithm for \textsc{Delaunay Realization}. In fact, our algorithm outputs
sets of points with {\em integer} coordinates.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Agrawal_A/0/1/0/all/0/1">Akanksha Agrawal</a>, <a href="http://arxiv.org/find/cs/1/au:+Saurabh_S/0/1/0/all/0/1">Saket Saurabh</a>, <a href="http://arxiv.org/find/cs/1/au:+Zehavi_M/0/1/0/all/0/1">Meirav Zehavi</a></p><p>The \emph{Delaunay graph} of a point set $P \subseteq \mathbb{R}^2$ is the
plane graph with the vertex-set $P$ and the edge-set that contains $\{p,p'\}$
if there exists a disc whose intersection with $P$ is exactly $\{p,p'\}$.
Accordingly, a triangulated graph $G$ is \emph{Delaunay realizable} if there
exists a triangulation of the Delaunay graph of some $P \subseteq
\mathbb{R}^2$, called a \emph{Delaunay triangulation} of $P$, that is
isomorphic to $G$. The objective of \textsc{Delaunay Realization} is to compute
a point set $P \subseteq \mathbb{R}^2$ that realizes a given graph $G$ (if such
a $P$ exists). Known algorithms do not solve \textsc{Delaunay Realization} as
they are non-constructive. Obtaining a constructive algorithm for
\textsc{Delaunay Realization} was mentioned as an open problem by Hiroshima et
al.~\cite{hiroshima2000}. We design an $n^{\mathcal{O}(n)}$-time constructive
algorithm for \textsc{Delaunay Realization}. In fact, our algorithm outputs
sets of points with {\em integer} coordinates.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-11T00:30:00Z">Tuesday, October 11 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.03811'>An Approximation Algorithm for Distance-Constrained Vehicle Routing on Trees</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Marc Dufay, Claire Mathieu, Hang Zhou</p><p>In the Distance-constrained Vehicle Routing Problem (DVRP), we are given a
graph with integer edge weights, a depot, a set of $n$ terminals, and a
distance constraint $D$. The goal is to find a minimum number of tours starting
and ending at the depot such that those tours together cover all the terminals
and the length of each tour is at most $D$.
</p>
<p>The DVRP on trees is of independent interest, because it is equivalent to the
virtual machine packing problem on trees studied by Sindelar et al. [SPAA'11].
We design a simple and natural approximation algorithm for the tree DVRP,
parameterized by $\varepsilon &gt;0$. We show that its approximation ratio is
$\alpha + \varepsilon$, where $\alpha \approx 1.691$, and in addition, that our
analysis is essentially tight. The running time is polynomial in $n$ and $D$.
The approximation ratio improves on the ratio of 2 due to Nagarajan and Ravi
[Networks'12].
</p>
<p>The main novelty of this paper lies in the analysis of the algorithm. It
relies on a reduction from the tree DVRP to the bounded space online bin
packing problem via a new notion of reduced length.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Dufay_M/0/1/0/all/0/1">Marc Dufay</a>, <a href="http://arxiv.org/find/cs/1/au:+Mathieu_C/0/1/0/all/0/1">Claire Mathieu</a>, <a href="http://arxiv.org/find/cs/1/au:+Zhou_H/0/1/0/all/0/1">Hang Zhou</a></p><p>In the Distance-constrained Vehicle Routing Problem (DVRP), we are given a
graph with integer edge weights, a depot, a set of $n$ terminals, and a
distance constraint $D$. The goal is to find a minimum number of tours starting
and ending at the depot such that those tours together cover all the terminals
and the length of each tour is at most $D$.
</p>
<p>The DVRP on trees is of independent interest, because it is equivalent to the
virtual machine packing problem on trees studied by Sindelar et al. [SPAA'11].
We design a simple and natural approximation algorithm for the tree DVRP,
parameterized by $\varepsilon &gt;0$. We show that its approximation ratio is
$\alpha + \varepsilon$, where $\alpha \approx 1.691$, and in addition, that our
analysis is essentially tight. The running time is polynomial in $n$ and $D$.
The approximation ratio improves on the ratio of 2 due to Nagarajan and Ravi
[Networks'12].
</p>
<p>The main novelty of this paper lies in the analysis of the algorithm. It
relies on a reduction from the tree DVRP to the bounded space online bin
packing problem via a new notion of reduced length.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-11T00:30:00Z">Tuesday, October 11 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.03831'>How to Make Your Approximation Algorithm Private: A Black-Box Differentially-Private Transformation for Tunable Approximation Algorithms of Functions with Low Sensitivity</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Jeremiah Blocki, Elena Grigorescu, Tamalika Mukherjee, Samson Zhou</p><p>We develop a framework for efficiently transforming certain approximation
algorithms into differentially-private variants, in a black-box manner. Our
results focus on algorithms A that output an approximation to a function f of
the form $(1-a)f(x)-k &lt;= A(x) &lt;= (1+a)f(x)+k$, where 0&lt;=a &lt;1 is a parameter
that can be``tuned" to small-enough values while incurring only a poly blowup
in the running time/space. We show that such algorithms can be made DP without
sacrificing accuracy, as long as the function f has small global sensitivity.
We achieve these results by applying the smooth sensitivity framework developed
by Nissim, Raskhodnikova, and Smith (STOC 2007).
</p>
<p>Our framework naturally applies to transform non-private FPRAS (resp. FPTAS)
algorithms into $(\epsilon,\delta)$-DP (resp. $\epsilon$-DP) approximation
algorithms. We apply our framework in the context of sublinear-time and
sublinear-space algorithms, while preserving the nature of the algorithm in
meaningful ranges of the parameters. Our results include the first (to the best
of our knowledge) $(\epsilon,\delta)$-edge DP sublinear-time algorithm for
estimating the number of triangles, the number of connected components, and the
weight of a MST of a graph, as well as a more efficient algorithm (while
sacrificing pure DP in contrast to previous results) for estimating the average
degree of a graph. In the area of streaming algorithms, our results include
$(\epsilon,\delta)$-DP algorithms for estimating L_p-norms, distinct elements,
and weighted MST for both insertion-only and turnstile streams. Our
transformation also provides a private version of the smooth histogram
framework, which is commonly used for converting streaming algorithms into
sliding window variants, and achieves a multiplicative approximation to many
problems, such as estimating L_p-norms, distinct elements, and the length of
the longest increasing subsequence.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Blocki_J/0/1/0/all/0/1">Jeremiah Blocki</a>, <a href="http://arxiv.org/find/cs/1/au:+Grigorescu_E/0/1/0/all/0/1">Elena Grigorescu</a>, <a href="http://arxiv.org/find/cs/1/au:+Mukherjee_T/0/1/0/all/0/1">Tamalika Mukherjee</a>, <a href="http://arxiv.org/find/cs/1/au:+Zhou_S/0/1/0/all/0/1">Samson Zhou</a></p><p>We develop a framework for efficiently transforming certain approximation
algorithms into differentially-private variants, in a black-box manner. Our
results focus on algorithms A that output an approximation to a function f of
the form $(1-a)f(x)-k &lt;= A(x) &lt;= (1+a)f(x)+k$, where 0&lt;=a &lt;1 is a parameter
that can be``tuned" to small-enough values while incurring only a poly blowup
in the running time/space. We show that such algorithms can be made DP without
sacrificing accuracy, as long as the function f has small global sensitivity.
We achieve these results by applying the smooth sensitivity framework developed
by Nissim, Raskhodnikova, and Smith (STOC 2007).
</p>
<p>Our framework naturally applies to transform non-private FPRAS (resp. FPTAS)
algorithms into $(\epsilon,\delta)$-DP (resp. $\epsilon$-DP) approximation
algorithms. We apply our framework in the context of sublinear-time and
sublinear-space algorithms, while preserving the nature of the algorithm in
meaningful ranges of the parameters. Our results include the first (to the best
of our knowledge) $(\epsilon,\delta)$-edge DP sublinear-time algorithm for
estimating the number of triangles, the number of connected components, and the
weight of a MST of a graph, as well as a more efficient algorithm (while
sacrificing pure DP in contrast to previous results) for estimating the average
degree of a graph. In the area of streaming algorithms, our results include
$(\epsilon,\delta)$-DP algorithms for estimating L_p-norms, distinct elements,
and weighted MST for both insertion-only and turnstile streams. Our
transformation also provides a private version of the smooth histogram
framework, which is commonly used for converting streaming algorithms into
sliding window variants, and achieves a multiplicative approximation to many
problems, such as estimating L_p-norms, distinct elements, and the length of
the longest increasing subsequence.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-11T00:30:00Z">Tuesday, October 11 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.03961'>Dynamic Tensor Product Regression</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Aravind Reddy, Zhao Song, Lichen Zhang</p><p>In this work, we initiate the study of \emph{Dynamic Tensor Product
Regression}. One has matrices $A_1\in \mathbb{R}^{n_1\times d_1},\ldots,A_q\in
\mathbb{R}^{n_q\times d_q}$ and a label vector $b\in \mathbb{R}^{n_1\ldots
n_q}$, and the goal is to solve the regression problem with the design matrix
$A$ being the tensor product of the matrices $A_1, A_2, \dots, A_q$ i.e.
$\min_{x\in \mathbb{R}^{d_1\ldots d_q}}~\|(A_1\otimes \ldots\otimes
A_q)x-b\|_2$. At each time step, one matrix $A_i$ receives a sparse change, and
the goal is to maintain a sketch of the tensor product $A_1\otimes\ldots
\otimes A_q$ so that the regression solution can be updated quickly.
Recomputing the solution from scratch for each round is very slow and so it is
important to develop algorithms which can quickly update the solution with the
new design matrix. Our main result is a dynamic tree data structure where any
update to a single matrix can be propagated quickly throughout the tree. We
show that our data structure can be used to solve dynamic versions of not only
Tensor Product Regression, but also Tensor Product Spline regression (which is
a generalization of ridge regression) and for maintaining Low Rank
Approximations for the tensor product.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Reddy_A/0/1/0/all/0/1">Aravind Reddy</a>, <a href="http://arxiv.org/find/cs/1/au:+Song_Z/0/1/0/all/0/1">Zhao Song</a>, <a href="http://arxiv.org/find/cs/1/au:+Zhang_L/0/1/0/all/0/1">Lichen Zhang</a></p><p>In this work, we initiate the study of \emph{Dynamic Tensor Product
Regression}. One has matrices $A_1\in \mathbb{R}^{n_1\times d_1},\ldots,A_q\in
\mathbb{R}^{n_q\times d_q}$ and a label vector $b\in \mathbb{R}^{n_1\ldots
n_q}$, and the goal is to solve the regression problem with the design matrix
$A$ being the tensor product of the matrices $A_1, A_2, \dots, A_q$ i.e.
$\min_{x\in \mathbb{R}^{d_1\ldots d_q}}~\|(A_1\otimes \ldots\otimes
A_q)x-b\|_2$. At each time step, one matrix $A_i$ receives a sparse change, and
the goal is to maintain a sketch of the tensor product $A_1\otimes\ldots
\otimes A_q$ so that the regression solution can be updated quickly.
Recomputing the solution from scratch for each round is very slow and so it is
important to develop algorithms which can quickly update the solution with the
new design matrix. Our main result is a dynamic tree data structure where any
update to a single matrix can be propagated quickly throughout the tree. We
show that our data structure can be used to solve dynamic versions of not only
Tensor Product Regression, but also Tensor Product Spline regression (which is
a generalization of ridge regression) and for maintaining Low Rank
Approximations for the tensor product.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-11T00:30:00Z">Tuesday, October 11 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.04059'>Order Selection Problems in Hiring Pipelines</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Boris Epstein, Will Ma (Columbia University)</p><p>Motivated by hiring pipelines, we study two order selection problems in which
applicants for a finite set of positions must be interviewed or made offers
sequentially. There is a finite time budget for interviewing or making offers,
and a stochastic realization after each decision, leading to
computationally-challenging problems. In the first problem we study sequential
interviewing, and show that a computationally-tractable, non-adaptive policy
that must make offers immediately after interviewing is approximately optimal,
assuming offerees always accept their offers. In the second problem, we assume
that applicants have already been interviewed but only accept offers with some
probability; we develop a computationally-tractable policy that makes offers
for the different positions in parallel, which is approximately optimal even
relative to a policy that does not need to make parallel offers. Our two
results both generalize and improve the guarantees in the work of Purohit et
al. on hiring algorithms, from 1/2 and 1/4 to approximation factors that are at
least 1-1/e.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Epstein_B/0/1/0/all/0/1">Boris Epstein</a>, <a href="http://arxiv.org/find/cs/1/au:+Ma_W/0/1/0/all/0/1">Will Ma</a> (Columbia University)</p><p>Motivated by hiring pipelines, we study two order selection problems in which
applicants for a finite set of positions must be interviewed or made offers
sequentially. There is a finite time budget for interviewing or making offers,
and a stochastic realization after each decision, leading to
computationally-challenging problems. In the first problem we study sequential
interviewing, and show that a computationally-tractable, non-adaptive policy
that must make offers immediately after interviewing is approximately optimal,
assuming offerees always accept their offers. In the second problem, we assume
that applicants have already been interviewed but only accept offers with some
probability; we develop a computationally-tractable policy that makes offers
for the different positions in parallel, which is approximately optimal even
relative to a policy that does not need to make parallel offers. Our two
results both generalize and improve the guarantees in the work of Purohit et
al. on hiring algorithms, from 1/2 and 1/4 to approximation factors that are at
least 1-1/e.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-11T00:30:00Z">Tuesday, October 11 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.04068'>IcebergHT: High Performance PMEM Hash Tables Through Stability and Low Associativity</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Prashant Pandey, Michael A. Bender, Alex Conway, Mart&#xed;n Farach-Colton, William Kuszmaul, Guido Tagliavini, Rob Johnson</p><p>Modern hash table designs strive to minimize space while maximizing speed.
The most important factor in speed is the number of cache lines accessed during
updates and queries. This is especially important on PMEM, which is slower than
DRAM and in which writes are more expensive than reads. This paper proposes two
stronger design objectives: stability and low-associativity. A stable hash
table doesn't move items around, and a hash table has low associativity if
there are only a few locations where an item can be stored. Low associativity
ensures that queries need to examine only a few memory locations, and stability
ensures that insertions write to very few cache lines. Stability also
simplifies scaling and crash safety.
</p>
<p>We present IcebergHT, a fast, crash-safe, concurrent, and space-efficient
hash table for PMEM based on the design principles of stability and low
associativity. IcebergHT combines in-memory metadata with a new hashing
technique, iceberg hashing, that is (1) space efficient, (2) stable, and (3)
supports low associativity. In contrast, existing hash-tables either modify
numerous cache lines during insertions (e.g. cuckoo hashing), access numerous
cache lines during queries (e.g. linear probing), or waste space (e.g.
chaining). Moreover, the combination of (1)-(3) yields several emergent
benefits: IcebergHT scales better than other hash tables, supports
crash-safety, and has excellent performance on PMEM (where writes are
particularly expensive).
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Pandey_P/0/1/0/all/0/1">Prashant Pandey</a>, <a href="http://arxiv.org/find/cs/1/au:+Bender_M/0/1/0/all/0/1">Michael A. Bender</a>, <a href="http://arxiv.org/find/cs/1/au:+Conway_A/0/1/0/all/0/1">Alex Conway</a>, <a href="http://arxiv.org/find/cs/1/au:+Farach_Colton_M/0/1/0/all/0/1">Mart&#xed;n Farach-Colton</a>, <a href="http://arxiv.org/find/cs/1/au:+Kuszmaul_W/0/1/0/all/0/1">William Kuszmaul</a>, <a href="http://arxiv.org/find/cs/1/au:+Tagliavini_G/0/1/0/all/0/1">Guido Tagliavini</a>, <a href="http://arxiv.org/find/cs/1/au:+Johnson_R/0/1/0/all/0/1">Rob Johnson</a></p><p>Modern hash table designs strive to minimize space while maximizing speed.
The most important factor in speed is the number of cache lines accessed during
updates and queries. This is especially important on PMEM, which is slower than
DRAM and in which writes are more expensive than reads. This paper proposes two
stronger design objectives: stability and low-associativity. A stable hash
table doesn't move items around, and a hash table has low associativity if
there are only a few locations where an item can be stored. Low associativity
ensures that queries need to examine only a few memory locations, and stability
ensures that insertions write to very few cache lines. Stability also
simplifies scaling and crash safety.
</p>
<p>We present IcebergHT, a fast, crash-safe, concurrent, and space-efficient
hash table for PMEM based on the design principles of stability and low
associativity. IcebergHT combines in-memory metadata with a new hashing
technique, iceberg hashing, that is (1) space efficient, (2) stable, and (3)
supports low associativity. In contrast, existing hash-tables either modify
numerous cache lines during insertions (e.g. cuckoo hashing), access numerous
cache lines during queries (e.g. linear probing), or waste space (e.g.
chaining). Moreover, the combination of (1)-(3) yields several emergent
benefits: IcebergHT scales better than other hash tables, supports
crash-safety, and has excellent performance on PMEM (where writes are
particularly expensive).
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-11T00:30:00Z">Tuesday, October 11 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    
    <h2 class='new-date'>
      <i class='icon-calendar-empty'></i> Monday, October 10
    </h2>
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='https://cstheory-jobs.org/2022/10/10/three-year-and-tenure-track-positions-at-ttic-apply-by-december-1-2022/'>THREE-YEAR AND TENURE-TRACK POSITIONS at TTIC (apply by December 1, 2022)</a></h3>
          <p class='item-feed'>from <a href='https://cstheory-jobs.org'>CCI: jobs</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          TTIC invites applications for the following faculty positions: research assistant professor (3-year term), tenure-track assistant professor, full or associate professor, and visiting professor. Applicants for research assistant professor positions (RAPs) are encouraged to simultaneously apply for the TTIC RAP program and the Simons-Berkeley Research Fellowship. Website: www.ttic.edu/faculty-hiring/ Email: recruiting@ttic.edu
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p>TTIC invites applications for the following faculty positions: research assistant professor (3-year term), tenure-track assistant professor, full or associate professor, and visiting professor. Applicants for research assistant professor positions (RAPs) are encouraged to simultaneously apply for the TTIC RAP program and the Simons-Berkeley Research Fellowship.</p>
<p>Website: <a href="https://www.ttic.edu/faculty-hiring/">https://www.ttic.edu/faculty-hiring/</a><br />
Email: recruiting@ttic.edu</p>
<p class="authors">By shacharlovett</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-10T18:07:37Z">Monday, October 10 2022, 18:07</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='https://cstheory-jobs.org/2022/10/10/lecturer-in-verification-at-university-of-sheffield-apply-by-october-14-2022/'>Lecturer in Verification at University of Sheffield (apply by October 14, 2022)</a></h3>
          <p class='item-feed'>from <a href='https://cstheory-jobs.org'>CCI: jobs</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          We seek candidates with an outstanding record in the logical and mathematical foundations of computing, including hardware and software verification. You will work within the Verification Group, a well-established group in the Department of Computer Science. Our research range from the mathematical and logical foundations of computing to practical verification methods and tools to support [&#8230;]
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p>We seek candidates with an outstanding record in the logical and mathematical foundations of computing, including hardware and software verification. You will work within the Verification Group, a well-established group in the Department of Computer Science. Our research range from the mathematical and logical foundations of computing to practical verification methods and tools to support these.</p>
<p>Website: <a href="https://www.jobs.ac.uk/job/CTU424/lecturer-in-verification">https://www.jobs.ac.uk/job/CTU424/lecturer-in-verification</a><br />
Email: g.j.brown@sheffield.ac.uk</p>
<p class="authors">By shacharlovett</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-10T12:26:03Z">Monday, October 10 2022, 12:26</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://blog.computationalcomplexity.org/2022/10/will-strassens-matrix-mult-alg-ever-be.html'>Will Strassen's Matrix Mult Alg ever be practical?</a></h3>
          <p class='item-feed'>from <a href='http://blog.computationalcomplexity.org/'>Computational Complexity</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>All time bounds are asymptotic and really O-of.</p><p>Recall that Strassen found a clever way to multiply&nbsp; two 2x2 matrices with 7 mults (and lots of adds)&nbsp; leading to a matrix mult alg in n^{\log_2 7} = n^{2.87...}</p><p><br></p><p>Recently (see&nbsp;here) a deep-mind-AI found a way to multiply&nbsp; two 4x4 matrices with 47 mults (and lots of adds) leading to a matrix mult alg in n^{\log_4 47} = n^{2.777...}&nbsp;</p><p>Much better is known, see our blog posts&nbsp;here&nbsp;and&nbsp;here.</p><p><br></p><p>The more advanced algorithms are complicated and have large constants so will never be practical. But Strassen's result, and now the new algorithm, SEEM to me they could be practical.</p><p>(ADDED LATER- many of the comments inform me that Strassen IS practical and IS being used. Great! Now we know!)</p><p>Thoughts about Strassen that also apply to the&nbsp; new algorithm.&nbsp;</p><p>1) n has to be large for Strassen to given an improvement. But as we deal with larger data sets the value of n is getting larger.&nbsp;</p><p>2) People are mostly interested in sparse matrices for which there are better methods. I've heard that for a while- but is it still true? I thought ML used dense matrices.&nbsp;</p><p>3) Strassen is hard to code up. Actually it doesn't look that hard to code up. However, I have never tried to code it up, so maybe there are subtle points there.</p><p>4) Strassen only works on matrices of size 2^n x 2^n. You can pad matrices out but that might kill whatever time advantage you get. (The new alg only works on&nbsp; 4^n x 4^n).&nbsp;</p><p>5) Strassen uses recursion and there is the hidden cost of recursion. I think that is a think of the past and our younger readers do not know what I am talking about.&nbsp;</p><p>6) (This is obvious) the recursion would only go down to a certain level and THEN you would use ordinary Matrix Mult. This may also add time.&nbsp;</p><p><br></p><p>I suspect that 2 and 4 are the most important reasons Strassen (or the new algorithm) is not practical BUT I would like to hear your thoughts?</p><p>Does any package NOW use Strassen's Algorithm?</p><p>Side Note: I like to ask students if they think there is a better-than-cubic algorithm for Matrix Mult. They do not. Then I show it to them and tell them THIS is why LOWER BOUNDS are hard. You have to show that NO, nobody clever will find a trick you hadn't thought of.&nbsp;</p><p><br></p><p>By gasarch</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p>All time bounds are asymptotic and really O-of.</p><p>Recall that Strassen found a clever way to multiply&nbsp; two 2x2 matrices with 7 mults (and lots of adds)&nbsp; leading to a matrix mult alg in n^{\log_2 7} = n^{2.87...}</p><p><br /></p><p>Recently (see&nbsp;<a href="https://www.newscientist.com/article/2340343-deepmind-ai-finds-new-way-to-multiply-numbers-and-speed-up-computers/">here</a>) a deep-mind-AI found a way to multiply&nbsp; two 4x4 matrices with 47 mults (and lots of adds) leading to a matrix mult alg in n^{\log_4 47} = n^{2.777...}&nbsp;</p><p>Much better is known, see our blog posts&nbsp;<a href="https://blog.computationalcomplexity.org/2011/11/matrix-mult-you-heard-it-here-third.html">here</a>&nbsp;and&nbsp;<a href="https://blog.computationalcomplexity.org/2015/06/when-do-we-care-about-small-improvements.html">here</a>.</p><p><br /></p><p>The more advanced algorithms are complicated and have large constants so will never be practical. But Strassen's result, and now the new algorithm, SEEM to me they could be practical.</p><p>(ADDED LATER- many of the comments inform me that Strassen IS practical and IS being used. Great! Now we know!)</p><p>Thoughts about Strassen that also apply to the&nbsp; new algorithm.&nbsp;</p><p>1) n has to be large for Strassen to given an improvement. But as we deal with larger data sets the value of n is getting larger.&nbsp;</p><p>2) People are mostly interested in sparse matrices for which there are better methods. I've heard that for a while- but is it still true? I thought ML used dense matrices.&nbsp;</p><p>3) Strassen is hard to code up. Actually it doesn't look that hard to code up. However, I have never tried to code it up, so maybe there are subtle points there.</p><p>4) Strassen only works on matrices of size 2^n x 2^n. You can pad matrices out but that might kill whatever time advantage you get. (The new alg only works on&nbsp; 4^n x 4^n).&nbsp;</p><p>5) Strassen uses recursion and there is <i>the hidden cost of recursion</i>. I think that is a think of the past and our younger readers do not know what I am talking about.&nbsp;</p><p>6) (This is obvious) the recursion would only go down to a certain level and THEN you would use ordinary Matrix Mult. This may also add time.&nbsp;</p><p><br /></p><p>I suspect that 2 and 4 are the most important reasons Strassen (or the new algorithm) is not practical BUT I would like to hear your thoughts?</p><p>Does any package NOW use Strassen's Algorithm?</p><p>Side Note: I like to ask students if they think there is a better-than-cubic algorithm for Matrix Mult. They do not. Then I show it to them and tell them THIS is why LOWER BOUNDS are hard. You have to show that NO, nobody clever will find a trick you hadn't thought of.&nbsp;</p><p><br /></p><p class="authors">By gasarch</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-10T04:03:00Z">Monday, October 10 2022, 04:03</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.03553'>Treewidth-aware Reductions of Normal ASP to SAT -- Is Normal ASP Harder than SAT after All?</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Markus Hecher</p><p>Answer Set Programming (ASP) is a paradigm for modeling and solving problems
for knowledge representation and reasoning. There are plenty of results
dedicated to studying the hardness of (fragments of) ASP. So far, these studies
resulted in characterizations in terms of computational complexity as well as
in fine-grained insights presented in form of dichotomy-style results, lower
bounds when translating to other formalisms like propositional satisfiability
(SAT), and even detailed parameterized complexity landscapes. A generic
parameter in parameterized complexity originating from graph theory is the
so-called treewidth, which in a sense captures structural density of a program.
Recently, there was an increase in the number of treewidth-based solvers
related to SAT. While there are translations from (normal) ASP to SAT, no
reduction that preserves treewidth or at least keeps track of the treewidth
increase is known. In this paper we propose a novel reduction from normal ASP
to SAT that is aware of the treewidth, and guarantees that a slight increase of
treewidth is indeed sufficient. Further, we show a new result establishing
that, when considering treewidth, already the fragment of normal ASP is
slightly harder than SAT (under reasonable assumptions in computational
complexity). This also confirms that our reduction probably cannot be
significantly improved and that the slight increase of treewidth is
unavoidable. Finally, we present an empirical study of our novel reduction from
normal ASP to SAT, where we compare treewidth upper bounds that are obtained
via known decomposition heuristics. Overall, our reduction works better with
these heuristics than existing translations.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Hecher_M/0/1/0/all/0/1">Markus Hecher</a></p><p>Answer Set Programming (ASP) is a paradigm for modeling and solving problems
for knowledge representation and reasoning. There are plenty of results
dedicated to studying the hardness of (fragments of) ASP. So far, these studies
resulted in characterizations in terms of computational complexity as well as
in fine-grained insights presented in form of dichotomy-style results, lower
bounds when translating to other formalisms like propositional satisfiability
(SAT), and even detailed parameterized complexity landscapes. A generic
parameter in parameterized complexity originating from graph theory is the
so-called treewidth, which in a sense captures structural density of a program.
Recently, there was an increase in the number of treewidth-based solvers
related to SAT. While there are translations from (normal) ASP to SAT, no
reduction that preserves treewidth or at least keeps track of the treewidth
increase is known. In this paper we propose a novel reduction from normal ASP
to SAT that is aware of the treewidth, and guarantees that a slight increase of
treewidth is indeed sufficient. Further, we show a new result establishing
that, when considering treewidth, already the fragment of normal ASP is
slightly harder than SAT (under reasonable assumptions in computational
complexity). This also confirms that our reduction probably cannot be
significantly improved and that the slight increase of treewidth is
unavoidable. Finally, we present an empirical study of our novel reduction from
normal ASP to SAT, where we compare treewidth upper bounds that are obtained
via known decomposition heuristics. Overall, our reduction works better with
these heuristics than existing translations.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-10T00:30:00Z">Monday, October 10 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.03343'>Boolean symmetric vs. functional PCSP dichotomy</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Tamio-Vesa Nakajima, Stanislav &#x17d;ivn&#xfd;</p><p>Given a 3-uniform hypergraph $(V,E)$ that is promised to admit a
$\{0,1\}$-colouring such that every edge contains exactly one $1$, can one find
a $d$-colouring $h:V\to \{0,1,\ldots,d-1\}$ such that $h(e)\in R$ for every
$e\in E$? This can be cast as a promise constraint satisfaction problem (PCSP)
of the form $\operatorname{PCSP}(1-in-3,\mathbf{B})$, where $\mathbf{B}$
defines the relation $R$, and is an example of
$\operatorname{PCSP}(\mathbf{A},\mathbf{B})$, where $\mathbf{A}$ (and thus wlog
also $\mathbf{B}$) is symmetric. The computational complexity of such problems
is understood for $\mathbf{A}$ and $\mathbf{B}$ on Boolean domains by the work
of Ficak, Kozik, Ol\v{s}\'{a}k, and Stankiewicz [ICALP'19].
</p>
<p>As our first result, we establish a dichotomy for
$\operatorname{PCSP}(\mathbf{A},\mathbf{B})$, where $\mathbf{A}$ is Boolean and
symmetric and $\mathbf{B}$ is functional (on a domain of any size); i.e, all
but one element of any tuple in a relation in $\mathbf{B}$ determine the last
element. This includes PCSPs of the form
$\operatorname{PCSP}(q-in-r,\mathbf{B})$, where $\mathbf{B}$ is functional,
thus making progress towards a classification of
$\operatorname{PCSP}(1-in-3,\mathbf{B})$, which were studied by Barto,
Battistelli, and Berg [STACS'21] for $\mathbf{B}$ on three-element domains.
</p>
<p>As our second result, we show that for
$\operatorname{PCSP}(\mathbf{A},\mathbf{B})$, where $\mathbf{A}$ contains a
single Boolean symmetric relation and $\mathbf{B}$ is arbitrary (and thus not
necessarily functional), the combined basic linear programmin relaxation (BLP)
and the affine integer programming relaxation (AIP) of Brakensiek et al.
[SICOMP'20] is no more powerful than the (in general strictly weaker) AIP
relaxation of Brakensiek and Guruswami [SICOMP'21].
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Nakajima_T/0/1/0/all/0/1">Tamio-Vesa Nakajima</a>, <a href="http://arxiv.org/find/cs/1/au:+Zivny_S/0/1/0/all/0/1">Stanislav &#x17d;ivn&#xfd;</a></p><p>Given a 3-uniform hypergraph $(V,E)$ that is promised to admit a
$\{0,1\}$-colouring such that every edge contains exactly one $1$, can one find
a $d$-colouring $h:V\to \{0,1,\ldots,d-1\}$ such that $h(e)\in R$ for every
$e\in E$? This can be cast as a promise constraint satisfaction problem (PCSP)
of the form $\operatorname{PCSP}(1-in-3,\mathbf{B})$, where $\mathbf{B}$
defines the relation $R$, and is an example of
$\operatorname{PCSP}(\mathbf{A},\mathbf{B})$, where $\mathbf{A}$ (and thus wlog
also $\mathbf{B}$) is symmetric. The computational complexity of such problems
is understood for $\mathbf{A}$ and $\mathbf{B}$ on Boolean domains by the work
of Ficak, Kozik, Ol\v{s}\'{a}k, and Stankiewicz [ICALP'19].
</p>
<p>As our first result, we establish a dichotomy for
$\operatorname{PCSP}(\mathbf{A},\mathbf{B})$, where $\mathbf{A}$ is Boolean and
symmetric and $\mathbf{B}$ is functional (on a domain of any size); i.e, all
but one element of any tuple in a relation in $\mathbf{B}$ determine the last
element. This includes PCSPs of the form
$\operatorname{PCSP}(q-in-r,\mathbf{B})$, where $\mathbf{B}$ is functional,
thus making progress towards a classification of
$\operatorname{PCSP}(1-in-3,\mathbf{B})$, which were studied by Barto,
Battistelli, and Berg [STACS'21] for $\mathbf{B}$ on three-element domains.
</p>
<p>As our second result, we show that for
$\operatorname{PCSP}(\mathbf{A},\mathbf{B})$, where $\mathbf{A}$ contains a
single Boolean symmetric relation and $\mathbf{B}$ is arbitrary (and thus not
necessarily functional), the combined basic linear programmin relaxation (BLP)
and the affine integer programming relaxation (AIP) of Brakensiek et al.
[SICOMP'20] is no more powerful than the (in general strictly weaker) AIP
relaxation of Brakensiek and Guruswami [SICOMP'21].
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-10T00:30:00Z">Monday, October 10 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.03166'>The Power of Greedy for Online Minimum Cost Matching on the Line</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Eric Balkanksi, Yuri Faenza, Noemie Perivier</p><p>We consider the online minimum cost matching problem on the line, in which
there are $n$ servers and, at each of $n$ time steps, a request arrives and
must be irrevocably matched to a server that has not yet been matched to, with
the goal of minimizing the sum of the distances between the matched pairs.
Despite achieving a worst-case competitive ratio that is exponential in $n$,
the simple greedy algorithm, which matches each request to its nearest
available free server, performs very well in practice. A major question is thus
to explain greedy's strong empirical performance. In this paper, we aim to
understand the performance of greedy over instances that are at least partially
random. When both the requests and the servers are drawn uniformly and
independently from $[0,1]$, we show that greedy is constant competitive, which
improves over the previously best-known $O(\sqrt{n})$ bound. We extend this
constant competitive ratio to a setting with a linear excess of servers, which
improves over the previously best-known $O(\log^3{n})$ bound. We moreover show
that in the semi-random model where the requests are still drawn uniformly and
independently but where the servers are chosen adversarially, greedy achieves
an $O(\log{n})$ competitive ratio. When the requests arrive in a random order
but are chosen adversarially, it was previously known that greedy is
$O(n)$-competitive. Even though this one-sided randomness allows a large
improvement in greedy's competitive ratio compared to the model where requests
are adversarial and arrive in a random order, we show that it is not sufficient
to obtain a constant competitive ratio by giving a tight $\Omega(\log{n})$
lower bound. These results invite further investigation about how much
randomness is necessary and sufficient to obtain strong theoretical guarantees
for the greedy algorithm for online minimum cost matching, on the line and
beyond.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Balkanksi_E/0/1/0/all/0/1">Eric Balkanksi</a>, <a href="http://arxiv.org/find/cs/1/au:+Faenza_Y/0/1/0/all/0/1">Yuri Faenza</a>, <a href="http://arxiv.org/find/cs/1/au:+Perivier_N/0/1/0/all/0/1">Noemie Perivier</a></p><p>We consider the online minimum cost matching problem on the line, in which
there are $n$ servers and, at each of $n$ time steps, a request arrives and
must be irrevocably matched to a server that has not yet been matched to, with
the goal of minimizing the sum of the distances between the matched pairs.
Despite achieving a worst-case competitive ratio that is exponential in $n$,
the simple greedy algorithm, which matches each request to its nearest
available free server, performs very well in practice. A major question is thus
to explain greedy's strong empirical performance. In this paper, we aim to
understand the performance of greedy over instances that are at least partially
random. When both the requests and the servers are drawn uniformly and
independently from $[0,1]$, we show that greedy is constant competitive, which
improves over the previously best-known $O(\sqrt{n})$ bound. We extend this
constant competitive ratio to a setting with a linear excess of servers, which
improves over the previously best-known $O(\log^3{n})$ bound. We moreover show
that in the semi-random model where the requests are still drawn uniformly and
independently but where the servers are chosen adversarially, greedy achieves
an $O(\log{n})$ competitive ratio. When the requests arrive in a random order
but are chosen adversarially, it was previously known that greedy is
$O(n)$-competitive. Even though this one-sided randomness allows a large
improvement in greedy's competitive ratio compared to the model where requests
are adversarial and arrive in a random order, we show that it is not sufficient
to obtain a constant competitive ratio by giving a tight $\Omega(\log{n})$
lower bound. These results invite further investigation about how much
randomness is necessary and sufficient to obtain strong theoretical guarantees
for the greedy algorithm for online minimum cost matching, on the line and
beyond.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-10T00:30:00Z">Monday, October 10 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.03211'>LazyFox: Fast and parallelized overlapping community detection in large graphs</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Tim Garrels, Athar Khodabakhsh, Bernhard Y. Renard, Katharina Baum</p><p>The detection of communities in graph datasets provides insight about a
graph's underlying structure and is an important tool for various domains such
as social sciences, marketing, traffic forecast, and drug discovery. While most
existing algorithms provide fast approaches for community detection, their
results usually contain strictly separated communities. However, most datasets
would semantically allow for or even require overlapping communities that can
only be determined at much higher computational cost. We build on an efficient
algorithm, Fox, that detects such overlapping communities. Fox measures the
closeness of a node to a community by approximating the count of triangles
which that node forms with that community. We propose LazyFox, a multi-threaded
version of the Fox algorithm, which provides even faster detection without an
impact on community quality. This allows for the analyses of significantly
larger and more complex datasets. LazyFox enables overlapping community
detection on complex graph datasets with millions of nodes and billions of
edges in days instead of weeks. As part of this work, LazyFox's implementation
was published and is available as a tool under an MIT licence at
github.com/TimGarrels/LazyFox.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Garrels_T/0/1/0/all/0/1">Tim Garrels</a>, <a href="http://arxiv.org/find/cs/1/au:+Khodabakhsh_A/0/1/0/all/0/1">Athar Khodabakhsh</a>, <a href="http://arxiv.org/find/cs/1/au:+Renard_B/0/1/0/all/0/1">Bernhard Y. Renard</a>, <a href="http://arxiv.org/find/cs/1/au:+Baum_K/0/1/0/all/0/1">Katharina Baum</a></p><p>The detection of communities in graph datasets provides insight about a
graph's underlying structure and is an important tool for various domains such
as social sciences, marketing, traffic forecast, and drug discovery. While most
existing algorithms provide fast approaches for community detection, their
results usually contain strictly separated communities. However, most datasets
would semantically allow for or even require overlapping communities that can
only be determined at much higher computational cost. We build on an efficient
algorithm, Fox, that detects such overlapping communities. Fox measures the
closeness of a node to a community by approximating the count of triangles
which that node forms with that community. We propose LazyFox, a multi-threaded
version of the Fox algorithm, which provides even faster detection without an
impact on community quality. This allows for the analyses of significantly
larger and more complex datasets. LazyFox enables overlapping community
detection on complex graph datasets with millions of nodes and billions of
edges in days instead of weeks. As part of this work, LazyFox's implementation
was published and is available as a tool under an MIT licence at
https://github.com/TimGarrels/LazyFox.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-10T00:30:00Z">Monday, October 10 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.03392'>Latent Matrices for Tensor Network Decomposition and to Tensor Completion</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Peilin Yang, Weijun Sun, Qinbin Zhao, Guoxu Zhou</p><p>The prevalent fully-connected tensor network (FCTN) has achieved excellent
success to compress data. However, the FCTN decomposition suffers from slow
computational speed when facing higher-order and large-scale data. Naturally,
there arises an interesting question: can a new model be proposed that
decomposes the tensor into smaller ones and speeds up the computation of the
algorithm? This work gives a positive answer by formulating a novel
higher-order tensor decomposition model that utilizes latent matrices based on
the tensor network structure, which can decompose a tensor into smaller-scale
data than the FCTN decomposition, hence we named it Latent Matrices for Tensor
Network Decomposition (LMTN). Furthermore, three optimization algorithms,
LMTN-PAM, LMTN-SVD and LMTN-AR, have been developed and applied to the
tensor-completion task. In addition, we provide proofs of theoretical
convergence and complexity analysis for these algorithms. Experimental results
show that our algorithm has the effectiveness in both deep learning dataset
compression and higher-order tensor completion, and that our LMTN-SVD algorithm
is 3-6 times faster than the FCTN-PAM algorithm and only a 1.8 points accuracy
drop.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Yang_P/0/1/0/all/0/1">Peilin Yang</a>, <a href="http://arxiv.org/find/cs/1/au:+Sun_W/0/1/0/all/0/1">Weijun Sun</a>, <a href="http://arxiv.org/find/cs/1/au:+Zhao_Q/0/1/0/all/0/1">Qinbin Zhao</a>, <a href="http://arxiv.org/find/cs/1/au:+Zhou_G/0/1/0/all/0/1">Guoxu Zhou</a></p><p>The prevalent fully-connected tensor network (FCTN) has achieved excellent
success to compress data. However, the FCTN decomposition suffers from slow
computational speed when facing higher-order and large-scale data. Naturally,
there arises an interesting question: can a new model be proposed that
decomposes the tensor into smaller ones and speeds up the computation of the
algorithm? This work gives a positive answer by formulating a novel
higher-order tensor decomposition model that utilizes latent matrices based on
the tensor network structure, which can decompose a tensor into smaller-scale
data than the FCTN decomposition, hence we named it Latent Matrices for Tensor
Network Decomposition (LMTN). Furthermore, three optimization algorithms,
LMTN-PAM, LMTN-SVD and LMTN-AR, have been developed and applied to the
tensor-completion task. In addition, we provide proofs of theoretical
convergence and complexity analysis for these algorithms. Experimental results
show that our algorithm has the effectiveness in both deep learning dataset
compression and higher-order tensor completion, and that our LMTN-SVD algorithm
is 3-6 times faster than the FCTN-PAM algorithm and only a 1.8 points accuracy
drop.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-10T00:30:00Z">Monday, October 10 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    
    <h2 class='new-date'>
      <i class='icon-calendar-empty'></i> Friday, October 07
    </h2>
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='https://scottaaronson.blog/?p=6745'>Postdocs, matrix multiplication, and WSJ: yet more shorties</a></h3>
          <p class='item-feed'>from <a href='https://scottaaronson.blog'>Scott Aaronson</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          I&#8217;m proud to say that Nick Hunter-Jones and Matteo Ippoliti&#8212;both of whom work at the interface between quantum information science and condensed-matter physics (Nick closer to the former and Matteo to the latter)&#8212;have joined the physics faculty at UT Austin this year. And Nick, Matteo, and I are jointly seeking postdocs to start in Fall [&#8230;]
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p>I&#8217;m proud to say that <a href="https://twitter.com/nickrhj">Nick Hunter-Jones</a> and <a href="https://matteoippoliti.com/">Matteo Ippoliti</a>&#8212;both of whom work at the interface between quantum information science and condensed-matter physics (Nick closer to the former and Matteo to the latter)&#8212;have joined the physics faculty at UT Austin this year.  And Nick, Matteo, and I are jointly seeking postdocs to start in Fall 2023!  <a href="https://academicjobsonline.org/ajo/jobs/23104">Please check out our call for applications here.</a>  The deadline is December 1; you apply through AcademicJobsOnline rather than by emailing me as in past years.</p>



<hr class="wp-block-separator has-alpha-channel-opacity"/>



<p>The big news in AI and complexity theory this week was DeepMind&#8217;s <a href="https://www.deepmind.com/blog/discovering-novel-algorithms-with-alphatensor">AlphaTensor</a>, and its automated discovery of new algorithms for matrix multiplication.  (<a href="https://www.nature.com/articles/s41586-022-05172-4">See here for the <em>Nature</em> paper.</a>)  More concretely, they&#8217;ve used AI to discover (among other things) an algorithm for multiplying 4×4 matrices, over finite fields of characteristic 2, using only 47 scalar multiplications.  This beats the 49=7×7 that you&#8217;d get from <a href="https://en.wikipedia.org/wiki/Strassen_algorithm">Strassen&#8217;s algorithm</a>.  There are other improvements for other matrix dimensions, many of which work over fields of other characteristics.</p>



<p>Since I&#8217;ve seen confusion about the point on social media: this does <em>not</em> improve over the best known asymptotic exponent for matrix multiplication, which over any field, still stands at the human-discovered 2.373 (meaning, we know how to multiply two N×N matrices in O(N<sup>2.373</sup>) time, but not faster).  But it <em>does</em> asymptotically improve over Strassen&#8217;s O(N<sup>2.81</sup>) algorithm from 1968, conceivably even in a way that could have practical relevance for multiplying hundreds-by-hundreds or thousands-by-thousands matrices over F<sub>2</sub>.</p>



<p>Way back in 2007, I <a href="http://www.scottaaronson.com/talks/wildidea.ppt">gave a talk</a> at MIT CSAIL&#8217;s &#8220;Wild and Crazy Ideas Session,&#8221; where I explicitly proposed to use computer search to look for faster algorithms for 4×4 and 5×5 matrix multiplication.  The response I got at the time was that it was hopeless, since the search space was already too huge.  Of course, that was before the deep learning revolution.</p>



<hr class="wp-block-separator has-alpha-channel-opacity"/>



<p>This morning, the <em>Wall Street Journal</em> published an <a href="https://www.wsj.com/articles/china-competing-us-quantum-computing-11664997892">article by Karen Hao</a> about competition between China and the US in quantum computing.  Unfortunately paywalled, but includes the following passage:</p>



<blockquote class="wp-block-quote"><p>Meanwhile, American academics say it’s gotten harder for Chinese students to obtain visas to conduct quantum research in the U.S. “It’s become common knowledge that when Chinese students or postdocs come to the U.S., they can’t say they’re doing quantum computing,” says Scott Aaronson, director of the Quantum Information Center at the University of Texas, Austin.</p></blockquote>
<p class="authors">By Scott</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-07T16:01:53Z">Friday, October 07 2022, 16:01</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='https://cstheory-jobs.org/2022/10/07/faculty-at-university-of-cambridge-apply-by-november-28-2022/'>Faculty at University of Cambridge (apply by November 28, 2022)</a></h3>
          <p class='item-feed'>from <a href='https://cstheory-jobs.org'>CCI: jobs</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          The Department of Computer Science and Technology at the University of Cambridge is seeking to recruit a new faculty member at the Assistant or Associate Professor level who can contribute to research and teaching in the area of Algorithms and Complexity. The appointment will be from 1 September 2023 or as soon as possible thereafter. [&#8230;]
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p>The Department of Computer Science and Technology at the University of Cambridge is seeking to recruit a new faculty member at the Assistant or Associate Professor level who can contribute to research and teaching in the area of Algorithms and Complexity.</p>
<p>The appointment will be from 1 September 2023 or as soon as possible thereafter.</p>
<p>Website: <a href="https://www.jobs.cam.ac.uk/job/37368/">https://www.jobs.cam.ac.uk/job/37368/</a><br />
Email: anuj.dawar@cl.cam.ac.uk</p>
<p class="authors">By shacharlovett</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-07T10:57:47Z">Friday, October 07 2022, 10:57</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='https://cstheory-jobs.org/2022/10/07/postdoc-positions-in-algorithms-and-complexity-at-algorithms-and-compleixty-group-irif-paris-france-apply-by-november-1-2022/'>postdoc positions in Algorithms and Complexity at Algorithms and Compleixty Group, IRIF, Paris, France (apply by November 1, 2022)</a></h3>
          <p class='item-feed'>from <a href='https://cstheory-jobs.org'>CCI: jobs</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          The Algorithms and Complexity group of IRIF ( www.irif.fr/en/equipes/algocomp/index ), Paris, France, is seeking excellent candidates for one or more postdoctoral positions in classical and quantum computing, with a usual starting date of September-October 2023 (but possibly negotiable). Knowledge of French is not necessary. Website: www.irif.fr/en/postes/postdoc Email: adiro@irif.fr
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p>The Algorithms and Complexity group of IRIF ( <a href="https://www.irif.fr/en/equipes/algocomp/index">https://www.irif.fr/en/equipes/algocomp/index</a> ), Paris, France, is seeking excellent candidates for one or more postdoctoral positions in classical and quantum computing, with a usual starting date of September-October 2023 (but possibly negotiable). Knowledge of French is not necessary.</p>
<p>Website: <a href="https://www.irif.fr/en/postes/postdoc">https://www.irif.fr/en/postes/postdoc</a><br />
Email: adiro@irif.fr</p>
<p class="authors">By shacharlovett</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-07T08:36:39Z">Friday, October 07 2022, 08:36</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.02671'>Transformers Implement First-Order Logic with Majority Quantifiers</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: William Merrill, Ashish Sabharwal</p><p>Characterizing the implicit structure of the computation within neural
networks is a foundational problem in the area of deep learning
interpretability. Can their inner decision process be captured symbolically in
some familiar logic? We show that any transformer neural network can be
translated into an equivalent fixed-size first-order logic formula which may
also use majority quantifiers. The idea is to simulate transformers with highly
uniform threshold circuits and leverage known theoretical connections between
circuits and logic. Our findings also reveal the surprising fact that the
entire transformer computation can be reduced merely to the division of two
(large) integers. While our results are most pertinent for transformers, they
apply equally to a broader class of neural network architectures, namely those
with a fixed-depth uniform computation graph made up of standard neural net
components, which includes feedforward and convolutional networks.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Merrill_W/0/1/0/all/0/1">William Merrill</a>, <a href="http://arxiv.org/find/cs/1/au:+Sabharwal_A/0/1/0/all/0/1">Ashish Sabharwal</a></p><p>Characterizing the implicit structure of the computation within neural
networks is a foundational problem in the area of deep learning
interpretability. Can their inner decision process be captured symbolically in
some familiar logic? We show that any transformer neural network can be
translated into an equivalent fixed-size first-order logic formula which may
also use majority quantifiers. The idea is to simulate transformers with highly
uniform threshold circuits and leverage known theoretical connections between
circuits and logic. Our findings also reveal the surprising fact that the
entire transformer computation can be reduced merely to the division of two
(large) integers. While our results are most pertinent for transformers, they
apply equally to a broader class of neural network architectures, namely those
with a fixed-depth uniform computation graph made up of standard neural net
components, which includes feedforward and convolutional networks.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-07T00:30:00Z">Friday, October 07 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.02999'>NLTS Hamiltonians from classical LTCs</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Zhiyang He, Chinmay Nirkhe</p><p>We provide a completely self-contained construction of a family of NLTS
Hamiltonians [Freedman and Hastings, 2014] based on ideas from [Anshu,
Breuckmann, and Nirkhe, 2022], [Cross, He, Natarajan, Szegedy, and Zhu, 2022]
and [Eldar and Harrow, 2017]. Crucially, it does not require optimal-parameter
quantum LDPC codes and can be built from simple classical LTCs such as the
repetition code on an expander graph. Furthermore, it removes the constant-rate
requirement from the construction of Anshu, Breuckmann, and Nirkhe.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/quant-ph/1/au:+He_Z/0/1/0/all/0/1">Zhiyang He</a>, <a href="http://arxiv.org/find/quant-ph/1/au:+Nirkhe_C/0/1/0/all/0/1">Chinmay Nirkhe</a></p><p>We provide a completely self-contained construction of a family of NLTS
Hamiltonians [Freedman and Hastings, 2014] based on ideas from [Anshu,
Breuckmann, and Nirkhe, 2022], [Cross, He, Natarajan, Szegedy, and Zhu, 2022]
and [Eldar and Harrow, 2017]. Crucially, it does not require optimal-parameter
quantum LDPC codes and can be built from simple classical LTCs such as the
repetition code on an expander graph. Furthermore, it removes the constant-rate
requirement from the construction of Anshu, Breuckmann, and Nirkhe.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-07T00:30:00Z">Friday, October 07 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.02582'>Romeo and Juliet Meeting in Forest Like Regions</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Neeldhara Misra, Manas Mulpuri, Prafullkumar Tale, Gaurav Viramgami</p><p>The game of rendezvous with adversaries is a game on a graph played by two
players: Facilitator and Divider. Facilitator has two agents and Divider has a
team of $k \ge 1$ agents. While the initial positions of Facilitator's agents
are fixed, Divider gets to select the initial positions of his agents. Then,
they take turns to move their agents to adjacent vertices (or stay put) with
Facilitator's goal to bring both her agents at same vertex and Divider's goal
to prevent it. The computational question of interest is to determine if
Facilitator has a winning strategy against Divider with $k$ agents. Fomin,
Golovach, and Thilikos [WG, 2021] introduced this game and proved that it is
PSPACE-hard and co-W[2]-hard parameterized by the number of agents.
</p>
<p>This hardness naturally motivates the structural parameterization of the
problem. The authors proved that it admits an FPT algorithm when parameterized
by the modular width and the number of allowed rounds. However, they left open
the complexity of the problem from the perspective of other structural
parameters. In particular, they explicitly asked whether the problem admits an
FPT or XP-algorithm with respect to the treewidth of the input graph. We answer
this question in the negative and show that Rendezvous is co-NP-hard even for
graphs of constant treewidth. Further, we show that the problem is co-W[1]-hard
when parameterized by the feedback vertex set number and the number of agents,
and is unlikely to admit a polynomial kernel when parameterized by the vertex
cover number and the number of agents. Complementing these hardness results, we
show that the Rendezvous is FPT when parameterized by both the vertex cover
number and the solution size. Finally, for graphs of treewidth at most two and
girds, we show that the problem can be solved in polynomial time.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Misra_N/0/1/0/all/0/1">Neeldhara Misra</a>, <a href="http://arxiv.org/find/cs/1/au:+Mulpuri_M/0/1/0/all/0/1">Manas Mulpuri</a>, <a href="http://arxiv.org/find/cs/1/au:+Tale_P/0/1/0/all/0/1">Prafullkumar Tale</a>, <a href="http://arxiv.org/find/cs/1/au:+Viramgami_G/0/1/0/all/0/1">Gaurav Viramgami</a></p><p>The game of rendezvous with adversaries is a game on a graph played by two
players: Facilitator and Divider. Facilitator has two agents and Divider has a
team of $k \ge 1$ agents. While the initial positions of Facilitator's agents
are fixed, Divider gets to select the initial positions of his agents. Then,
they take turns to move their agents to adjacent vertices (or stay put) with
Facilitator's goal to bring both her agents at same vertex and Divider's goal
to prevent it. The computational question of interest is to determine if
Facilitator has a winning strategy against Divider with $k$ agents. Fomin,
Golovach, and Thilikos [WG, 2021] introduced this game and proved that it is
PSPACE-hard and co-W[2]-hard parameterized by the number of agents.
</p>
<p>This hardness naturally motivates the structural parameterization of the
problem. The authors proved that it admits an FPT algorithm when parameterized
by the modular width and the number of allowed rounds. However, they left open
the complexity of the problem from the perspective of other structural
parameters. In particular, they explicitly asked whether the problem admits an
FPT or XP-algorithm with respect to the treewidth of the input graph. We answer
this question in the negative and show that Rendezvous is co-NP-hard even for
graphs of constant treewidth. Further, we show that the problem is co-W[1]-hard
when parameterized by the feedback vertex set number and the number of agents,
and is unlikely to admit a polynomial kernel when parameterized by the vertex
cover number and the number of agents. Complementing these hardness results, we
show that the Rendezvous is FPT when parameterized by both the vertex cover
number and the solution size. Finally, for graphs of treewidth at most two and
girds, we show that the problem can be solved in polynomial time.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-07T00:30:00Z">Friday, October 07 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.02611'>$(1-\epsilon)$-approximate fully dynamic densest subgraph: linear space and faster update time</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Chandra Chekuri, Kent Quanrud</p><p>We consider the problem of maintaining a $(1-\epsilon)$-approximation to the
densest subgraph (DSG) in an undirected multigraph as it undergoes edge
insertions and deletions (the fully dynamic setting). Sawlani and Wang [SW20]
developed a data structure that, for any given $\epsilon &gt; 0$, maintains a
$(1-\epsilon)$-approximation with $O(\log^4 n/\epsilon^6)$ worst-case update
time for edge operations, and $O(1)$ query time for reporting the density
value. Their data structure was the first to achieve near-optimal
approximation, and improved previous work that maintained a $(1/4 - \epsilon)$
approximation in amortized polylogarithmic update time [BHNT15]. In this paper
we develop a data structure for $(1-\epsilon)$-approximate DSG that improves
the one from [SW20] in two aspects. First, the data structure uses linear space
improving the space bound in [SW20] by a logarithmic factor. Second, the data
structure maintains a $(1-\epsilon)$-approximation in amortized $O(\log^2
n/\epsilon^4)$ time per update while simultaneously guaranteeing that the worst
case update time is $O(\log^3 n \log \log n/\epsilon^6)$. We believe that the
space and update time improvements are valuable for current large scale graph
data sets. The data structure extends in a natural fashion to hypergraphs and
yields improvements in space and update times over recent work [BBCG22] that
builds upon [SW20].
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Chekuri_C/0/1/0/all/0/1">Chandra Chekuri</a>, <a href="http://arxiv.org/find/cs/1/au:+Quanrud_K/0/1/0/all/0/1">Kent Quanrud</a></p><p>We consider the problem of maintaining a $(1-\epsilon)$-approximation to the
densest subgraph (DSG) in an undirected multigraph as it undergoes edge
insertions and deletions (the fully dynamic setting). Sawlani and Wang [SW20]
developed a data structure that, for any given $\epsilon &gt; 0$, maintains a
$(1-\epsilon)$-approximation with $O(\log^4 n/\epsilon^6)$ worst-case update
time for edge operations, and $O(1)$ query time for reporting the density
value. Their data structure was the first to achieve near-optimal
approximation, and improved previous work that maintained a $(1/4 - \epsilon)$
approximation in amortized polylogarithmic update time [BHNT15]. In this paper
we develop a data structure for $(1-\epsilon)$-approximate DSG that improves
the one from [SW20] in two aspects. First, the data structure uses linear space
improving the space bound in [SW20] by a logarithmic factor. Second, the data
structure maintains a $(1-\epsilon)$-approximation in amortized $O(\log^2
n/\epsilon^4)$ time per update while simultaneously guaranteeing that the worst
case update time is $O(\log^3 n \log \log n/\epsilon^6)$. We believe that the
space and update time improvements are valuable for current large scale graph
data sets. The data structure extends in a natural fashion to hypergraphs and
yields improvements in space and update times over recent work [BBCG22] that
builds upon [SW20].
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-07T00:30:00Z">Friday, October 07 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.02628'>Cooperative Coverage with a Leader and a Wingmate in Communication-Constrained Environments</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Sai Krishna Kanth Hari, Sivakumar Rathinam, Swaroop Darbha, David W. Casbeer</p><p>We consider a mission framework in which two unmanned vehicles (UVs), a
leader and a wingmate, are required to provide cooperative coverage of an
environment while being within a short communication range. This framework
finds applications in underwater and/or military domains, where certain
constraints are imposed on communication by either the application or the
environment. An important objective of missions within this framework is to
minimize the total travel and communication costs of the leader-wingmate duo.
In this paper, we propose and formulate the problem of finding routes for the
UVs that minimize the sum of their travel and communication costs as a network
optimization problem of the form of a binary program (BP). The BP is
computationally expensive, with the time required to compute optimal solutions
increasing rapidly with the problem size. To address this challenge, here, we
propose two algorithms, an approximation algorithm and a heuristic algorithm,
to solve large-scale instances of the problem swiftly. We demonstrate the
effectiveness and the scalability of these algorithms through an analysis of
extensive numerical simulations performed over 500 instances, with the number
of targets in the instances ranging from 6 to 100.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Hari_S/0/1/0/all/0/1">Sai Krishna Kanth Hari</a>, <a href="http://arxiv.org/find/cs/1/au:+Rathinam_S/0/1/0/all/0/1">Sivakumar Rathinam</a>, <a href="http://arxiv.org/find/cs/1/au:+Darbha_S/0/1/0/all/0/1">Swaroop Darbha</a>, <a href="http://arxiv.org/find/cs/1/au:+Casbeer_D/0/1/0/all/0/1">David W. Casbeer</a></p><p>We consider a mission framework in which two unmanned vehicles (UVs), a
leader and a wingmate, are required to provide cooperative coverage of an
environment while being within a short communication range. This framework
finds applications in underwater and/or military domains, where certain
constraints are imposed on communication by either the application or the
environment. An important objective of missions within this framework is to
minimize the total travel and communication costs of the leader-wingmate duo.
In this paper, we propose and formulate the problem of finding routes for the
UVs that minimize the sum of their travel and communication costs as a network
optimization problem of the form of a binary program (BP). The BP is
computationally expensive, with the time required to compute optimal solutions
increasing rapidly with the problem size. To address this challenge, here, we
propose two algorithms, an approximation algorithm and a heuristic algorithm,
to solve large-scale instances of the problem swiftly. We demonstrate the
effectiveness and the scalability of these algorithms through an analysis of
extensive numerical simulations performed over 500 instances, with the number
of targets in the instances ranging from 6 to 100.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-07T00:30:00Z">Friday, October 07 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.02638'>What Can We Compute in a Single Round of the Congested Clique?</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Peter Robinson</p><p>We study the computational power of one-round distributed algorithms in the
congested clique model. We show that any one-round algorithm that computes a
minimum spanning tree (MST) in the unicast congested clique must use a link
bandwidth of $\Omega(\log^3 n)$ bits in the worst case. This is the first round
complexity lower bound in the unicast congested clique for a problem where the
output size is small, i.e., $O(n\log n)$ bits. Our main technical contribution
is to investigate one-round algorithms in the broadcast congested clique and,
equivalently, the distributed graph sketching model where the nodes send their
message to a referee who computes the output. First, we present a tight lower
bound of $\Omega(n)$ bits for the message size of computing a breadth-first
search tree. Then, we prove that computing a $k$-edge connected spanning
subgraph ($k$-ECSS) requires messages of size at least $\Omega \left(
k\log^2(n/k) \right)$. We also show that verifying whether a given vertex
coloring forms a weak 2-coloring of the input graph requires messages of
$\Omega(n^{1/3}\log^{2/3}n)$ bits, and the same lower bound holds for verifying
whether a subset of nodes forms a maximal independent set or a minimal
dominating set. Interestingly, it turns out that the same class of lower bound
graphs for the distributed sketching model is versatile enough to yield a space
lower bound of $\Omega(n^2)$ bits for verifying symmetry breaking problems such
as weak $2$-coloring in the fully dynamic turnstile model, where the input
arrives as a stream of edges. We also (nearly) settle the space complexity of
the $k$-ECSS problem in the streaming model by extending the work of Kapralov
et al. (FOCS 2017): We prove a communication complexity lower bound for a
direct sum variant of the $\text{UR}_k^{\subset}$ problem and show that this
implies $\Omega(k\,n\log^2(n/k))$ bits of memory for computing a $k$-ECSS.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Robinson_P/0/1/0/all/0/1">Peter Robinson</a></p><p>We study the computational power of one-round distributed algorithms in the
congested clique model. We show that any one-round algorithm that computes a
minimum spanning tree (MST) in the unicast congested clique must use a link
bandwidth of $\Omega(\log^3 n)$ bits in the worst case. This is the first round
complexity lower bound in the unicast congested clique for a problem where the
output size is small, i.e., $O(n\log n)$ bits. Our main technical contribution
is to investigate one-round algorithms in the broadcast congested clique and,
equivalently, the distributed graph sketching model where the nodes send their
message to a referee who computes the output. First, we present a tight lower
bound of $\Omega(n)$ bits for the message size of computing a breadth-first
search tree. Then, we prove that computing a $k$-edge connected spanning
subgraph ($k$-ECSS) requires messages of size at least $\Omega \left(
k\log^2(n/k) \right)$. We also show that verifying whether a given vertex
coloring forms a weak 2-coloring of the input graph requires messages of
$\Omega(n^{1/3}\log^{2/3}n)$ bits, and the same lower bound holds for verifying
whether a subset of nodes forms a maximal independent set or a minimal
dominating set. Interestingly, it turns out that the same class of lower bound
graphs for the distributed sketching model is versatile enough to yield a space
lower bound of $\Omega(n^2)$ bits for verifying symmetry breaking problems such
as weak $2$-coloring in the fully dynamic turnstile model, where the input
arrives as a stream of edges. We also (nearly) settle the space complexity of
the $k$-ECSS problem in the streaming model by extending the work of Kapralov
et al. (FOCS 2017): We prove a communication complexity lower bound for a
direct sum variant of the $\text{UR}_k^{\subset}$ problem and show that this
implies $\Omega(k\,n\log^2(n/k))$ bits of memory for computing a $k$-ECSS.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-07T00:30:00Z">Friday, October 07 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.02672'>Orthogonal Non-negative Matrix Factorization: a Maximum-Entropy-Principle Approach</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Salar Basiri, Mustafa Kapadia, Srinivasa Salapaka</p><p>In this paper, we introduce a new methodology to solve the orthogonal
non-negative matrix factorization (ONMF) problem, where the objective is to
approximate an input data matrix by the product of two non-negative matrices,
the features matrix and the mixing matrix, while one of them is orthogonal. We
show how the ONMF can be interpreted as a specific facility-location problem
(FLP), and adapt a maximum-entropy-principle based solution for FLP to the ONMF
problem. The proposed approach guarantees orthogonality of the features or the
mixing matrix, while ensuring that both of the matrix factors are non-negative.
Also, the features (mixing) matrix has exactly one non-zero element across each
row (column), providing the maximum sparsity of the orthogonal factor. This
enables a semantic interpretation of the underlying data matrix using
non-overlapping features. The experiments on synthetic data and a standard
microarray dataset demonstrate significant improvements in terms of sparsity
and orthogonality scores of features (mixing) matrices, while achieving
approximately the same or better (up to 3%) reconstruction errors.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Basiri_S/0/1/0/all/0/1">Salar Basiri</a>, <a href="http://arxiv.org/find/cs/1/au:+Kapadia_M/0/1/0/all/0/1">Mustafa Kapadia</a>, <a href="http://arxiv.org/find/cs/1/au:+Salapaka_S/0/1/0/all/0/1">Srinivasa Salapaka</a></p><p>In this paper, we introduce a new methodology to solve the orthogonal
non-negative matrix factorization (ONMF) problem, where the objective is to
approximate an input data matrix by the product of two non-negative matrices,
the features matrix and the mixing matrix, while one of them is orthogonal. We
show how the ONMF can be interpreted as a specific facility-location problem
(FLP), and adapt a maximum-entropy-principle based solution for FLP to the ONMF
problem. The proposed approach guarantees orthogonality of the features or the
mixing matrix, while ensuring that both of the matrix factors are non-negative.
Also, the features (mixing) matrix has exactly one non-zero element across each
row (column), providing the maximum sparsity of the orthogonal factor. This
enables a semantic interpretation of the underlying data matrix using
non-overlapping features. The experiments on synthetic data and a standard
microarray dataset demonstrate significant improvements in terms of sparsity
and orthogonality scores of features (mixing) matrices, while achieving
approximately the same or better (up to 3%) reconstruction errors.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-07T00:30:00Z">Friday, October 07 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.02775'>Paging with Succinct Predictions</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Antonios Antoniadis, Joan Boyar, Marek Eli&#xe1;&#x161;, Lene M. Favrholdt, Ruben Hoeksma, Kim S. Larsen, Adam Polak, Bertrand Simon</p><p>Paging is a prototypical problem in the area of online algorithms. It has
also played a central role in the development of learning-augmented algorithms
-- a recent line of research that aims to ameliorate the shortcomings of
classical worst-case analysis by giving algorithms access to predictions. Such
predictions can typically be generated using a machine learning approach, but
they are inherently imperfect. Previous work on learning-augmented paging has
investigated predictions on (i) when the current page will be requested again
(reoccurrence predictions), (ii) the current state of the cache in an optimal
algorithm (state predictions), (iii) all requests until the current page gets
requested again, and (iv) the relative order in which pages are requested.
</p>
<p>We study learning-augmented paging from the new perspective of requiring the
least possible amount of predicted information. More specifically, the
predictions obtained alongside each page request are limited to one bit only.
We consider two natural such setups: (i) discard predictions, in which the
predicted bit denotes whether or not it is ``safe'' to evict this page, and
(ii) phase predictions, where the bit denotes whether the current page will be
requested in the next phase (for an appropriate partitioning of the input into
phases). We develop algorithms for each of the two setups that satisfy all
three desirable properties of learning-augmented algorithms -- that is, they
are consistent, robust and smooth -- despite being limited to a one-bit
prediction per request. We also present lower bounds establishing that our
algorithms are essentially best possible.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Antoniadis_A/0/1/0/all/0/1">Antonios Antoniadis</a>, <a href="http://arxiv.org/find/cs/1/au:+Boyar_J/0/1/0/all/0/1">Joan Boyar</a>, <a href="http://arxiv.org/find/cs/1/au:+Elias_M/0/1/0/all/0/1">Marek Eli&#xe1;&#x161;</a>, <a href="http://arxiv.org/find/cs/1/au:+Favrholdt_L/0/1/0/all/0/1">Lene M. Favrholdt</a>, <a href="http://arxiv.org/find/cs/1/au:+Hoeksma_R/0/1/0/all/0/1">Ruben Hoeksma</a>, <a href="http://arxiv.org/find/cs/1/au:+Larsen_K/0/1/0/all/0/1">Kim S. Larsen</a>, <a href="http://arxiv.org/find/cs/1/au:+Polak_A/0/1/0/all/0/1">Adam Polak</a>, <a href="http://arxiv.org/find/cs/1/au:+Simon_B/0/1/0/all/0/1">Bertrand Simon</a></p><p>Paging is a prototypical problem in the area of online algorithms. It has
also played a central role in the development of learning-augmented algorithms
-- a recent line of research that aims to ameliorate the shortcomings of
classical worst-case analysis by giving algorithms access to predictions. Such
predictions can typically be generated using a machine learning approach, but
they are inherently imperfect. Previous work on learning-augmented paging has
investigated predictions on (i) when the current page will be requested again
(reoccurrence predictions), (ii) the current state of the cache in an optimal
algorithm (state predictions), (iii) all requests until the current page gets
requested again, and (iv) the relative order in which pages are requested.
</p>
<p>We study learning-augmented paging from the new perspective of requiring the
least possible amount of predicted information. More specifically, the
predictions obtained alongside each page request are limited to one bit only.
We consider two natural such setups: (i) discard predictions, in which the
predicted bit denotes whether or not it is ``safe'' to evict this page, and
(ii) phase predictions, where the bit denotes whether the current page will be
requested in the next phase (for an appropriate partitioning of the input into
phases). We develop algorithms for each of the two setups that satisfy all
three desirable properties of learning-augmented algorithms -- that is, they
are consistent, robust and smooth -- despite being limited to a one-bit
prediction per request. We also present lower bounds establishing that our
algorithms are essentially best possible.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-07T00:30:00Z">Friday, October 07 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.02835'>Sequentially Swapping Tokens: Further on Graph Classes</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Hironori Kiya, Yuto Okada, Hirotaka Ono, Yota Otachi</p><p>We study the following variant of the 15 puzzle. Given a graph and two token
placements on the vertices, we want to find a walk of the minimum length (if
any exists) such that the sequence of token swappings along the walk obtains
one of the given token placements from the other one. This problem was
introduced as Sequential Token Swapping by Yamanaka et al. [JGAA 2019], who
showed that the problem is intractable in general but polynomial-time solvable
for trees, complete graphs, and cycles. In this paper, we present a
polynomial-time algorithm for block-cactus graphs, which include all previously
known cases. We also present general tools for showing the hardness of problem
on restricted graph classes such as chordal graphs and chordal bipartite
graphs. We also show that the problem is hard on grids and king's graphs, which
are the graphs corresponding to the 15 puzzle and its variant with relaxed
moves.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Kiya_H/0/1/0/all/0/1">Hironori Kiya</a>, <a href="http://arxiv.org/find/cs/1/au:+Okada_Y/0/1/0/all/0/1">Yuto Okada</a>, <a href="http://arxiv.org/find/cs/1/au:+Ono_H/0/1/0/all/0/1">Hirotaka Ono</a>, <a href="http://arxiv.org/find/cs/1/au:+Otachi_Y/0/1/0/all/0/1">Yota Otachi</a></p><p>We study the following variant of the 15 puzzle. Given a graph and two token
placements on the vertices, we want to find a walk of the minimum length (if
any exists) such that the sequence of token swappings along the walk obtains
one of the given token placements from the other one. This problem was
introduced as Sequential Token Swapping by Yamanaka et al. [JGAA 2019], who
showed that the problem is intractable in general but polynomial-time solvable
for trees, complete graphs, and cycles. In this paper, we present a
polynomial-time algorithm for block-cactus graphs, which include all previously
known cases. We also present general tools for showing the hardness of problem
on restricted graph classes such as chordal graphs and chordal bipartite
graphs. We also show that the problem is hard on grids and king's graphs, which
are the graphs corresponding to the 15 puzzle and its variant with relaxed
moves.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-07T00:30:00Z">Friday, October 07 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.03048'>Scalable Experimental Bounds for Entangled Quantum State Fidelities</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Shamminuj Aktar, Andreas B&#xe4;rtschi, Abdel-Hameed A. Badawy, Stephan Eidenbenz</p><p>Estimating the state preparation fidelity of highly entangled states on noisy
intermediate-scale quantum (NISQ) devices is an important task for benchmarking
and application considerations. Unfortunately, exact fidelity measurements
quickly become prohibitively expensive, as they scale exponentially as O(3^N)
for N-qubit states, using full state tomography with measurements in all Pauli
bases combinations.
</p>
<p>However, it is known [Somma et.al. 2006] that the complexity can be
drastically reduced when looking at fidelity lower bounds for states that
exhibit symmetries, such as Dicke States and GHZ States. For larger states,
these bounds have so far not been tight enough to provide reasonable
estimations on today's (2022) NISQ devices. In this work, for the first time
and more than 15 years after the theoretical introduction, we report meaningful
lower bounds for the state preparation fidelity of all Dicke States up to N=10
and all GHZ states up to N=20 on Quantinuum H1 ion-trap systems using efficient
implementations of recently proposed scalable circuits for these states.
</p>
<p>For example, we give state preparation fidelity lower bounds of (i) 0.46 for
the Dicke State |D10,5&gt; and (ii) 0.73 for the GHZ State |G20&gt;. These match or
exceed exact fidelity records recently achieved on superconducting systems for
the much smaller states |D6,3&gt; and |G5&gt;, respectively. Furthermore, we provide
evidence that for large Dicke States |DN,N/2&gt;, we can resort to a GHZ-based
approximate state preparation to achieve better fidelity.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/quant-ph/1/au:+Aktar_S/0/1/0/all/0/1">Shamminuj Aktar</a>, <a href="http://arxiv.org/find/quant-ph/1/au:+Bartschi_A/0/1/0/all/0/1">Andreas B&#xe4;rtschi</a>, <a href="http://arxiv.org/find/quant-ph/1/au:+Badawy_A/0/1/0/all/0/1">Abdel-Hameed A. Badawy</a>, <a href="http://arxiv.org/find/quant-ph/1/au:+Eidenbenz_S/0/1/0/all/0/1">Stephan Eidenbenz</a></p><p>Estimating the state preparation fidelity of highly entangled states on noisy
intermediate-scale quantum (NISQ) devices is an important task for benchmarking
and application considerations. Unfortunately, exact fidelity measurements
quickly become prohibitively expensive, as they scale exponentially as O(3^N)
for N-qubit states, using full state tomography with measurements in all Pauli
bases combinations.
</p>
<p>However, it is known [Somma et.al. 2006] that the complexity can be
drastically reduced when looking at fidelity lower bounds for states that
exhibit symmetries, such as Dicke States and GHZ States. For larger states,
these bounds have so far not been tight enough to provide reasonable
estimations on today's (2022) NISQ devices. In this work, for the first time
and more than 15 years after the theoretical introduction, we report meaningful
lower bounds for the state preparation fidelity of all Dicke States up to N=10
and all GHZ states up to N=20 on Quantinuum H1 ion-trap systems using efficient
implementations of recently proposed scalable circuits for these states.
</p>
<p>For example, we give state preparation fidelity lower bounds of (i) 0.46 for
the Dicke State |D10,5&gt; and (ii) 0.73 for the GHZ State |G20&gt;. These match or
exceed exact fidelity records recently achieved on superconducting systems for
the much smaller states |D6,3&gt; and |G5&gt;, respectively. Furthermore, we provide
evidence that for large Dicke States |DN,N/2&gt;, we can resort to a GHZ-based
approximate state preparation to achieve better fidelity.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-07T00:30:00Z">Friday, October 07 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    
    <h2 class='new-date'>
      <i class='icon-calendar-empty'></i> Thursday, October 06
    </h2>
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='https://gilkalai.wordpress.com/2022/10/07/the-google-supremacy-experiment-data-information-discussions-and-three-questions/'>The Google Supremacy Experiment: Data, Information, Discussions, and Three Questions.</a></h3>
          <p class='item-feed'>from <a href='https://gilkalai.wordpress.com'>Gil Kalai</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          Yosi Rinott, Tomer Shoham, and I  wrote a manuscript regarding our study of the Google 2019 supremacy experiment. This is still a draft and comments or corrections are most welcome. (The paper already incorporates a few comments by the Google &#8230; Continue reading &#8594;
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p></p>


<p>Yosi Rinott, Tomer Shoham, and I  wrote a manuscript regarding our study of the Google 2019 supremacy experiment. This is still a draft and comments or corrections are most welcome. (The paper already incorporates a few comments by the Google team; October 11, 2022: a new version is posted based on  excellent comments and many corrections by Carsten <span class="qu" role="gridcell"><span class="gD">Voelkmann.</span></span>)</p>
<h3><a href="https://gilkalai.files.wordpress.com/2022/10/cc22a19.pdf"><span dir="ltr" role="presentation">Google’s 2019 “Quantum Supremacy” Claims: </span><span dir="ltr" role="presentation">Data, Documentation, &amp; Discussion</span></a></h3>
<p>by Gil Kalai, Yosef Rinott, and Tomer Shoham</p>
<blockquote>
<p><em><span dir="ltr" role="presentation"><strong>Abstract:</strong> In October 2019, </span></em><span dir="ltr" role="presentation">Nature </span><em><span dir="ltr" role="presentation">published a paper describing an exper</span><span dir="ltr" role="presentation">imental work that took place at Google. The paper claims to demon</span><span dir="ltr" role="presentation">strate quantum (computational) supremacy on a 53-qubit quantum </span><span dir="ltr" role="presentation">computer.</span> <span dir="ltr" role="presentation">Since September 2019 the authors have been involved in </span><span dir="ltr" role="presentation">a long-term project to study various statistical aspects of the Google </span><span dir="ltr" role="presentation">experiment.</span> <span dir="ltr" role="presentation">In particular, we have been trying to gather the rele</span><span dir="ltr" role="presentation">vant data and information, to reconstruct and verify those parts of </span><span dir="ltr" role="presentation">the Google 2019 supremacy experiments that are based on classical </span><span dir="ltr" role="presentation">computations (unless they require too heavy computation), and to </span><span dir="ltr" role="presentation">put the data under statistical analysis. We have now (August 2022) </span><span dir="ltr" role="presentation">concluded the part relating to the gathering of data and information </span><span dir="ltr" role="presentation">needed for our study of the 2019 Google experiment, and this docu</span><span dir="ltr" role="presentation">ment describes the available data and information for the Google 2019 </span><span dir="ltr" role="presentation">experiment and some of our results and plans.</span></em></p>
</blockquote>
<p>The manuscript describes the stage of gathering data and information needed for our study and our analysis based on this data will be described separately. Statistical analysis of the Google experiment is already described in our Statistical Science paper  <a href="https://gilkalai.files.wordpress.com/2022/08/sts836.pdf">Statistical Aspects of the Quantum Supremacy Demonstration.</a> (In this paper we mainly rely on data of 12-qubit and 14-qubit circuits.) Some preliminary statistical analysis is also given in Sections 6 and 7 of my paper  <a href="https://gilkalai.files.wordpress.com/2020/08/laws-blog2.pdf">The argument against quantum computers, the quantum laws of nature, and Google’s supremacy claims</a>.</p>
<h2><em>Quo Vadis</em> random circuit sampling<em><span dir="ltr">?</span></em></h2>
<p><span dir="ltr" role="presentation">Here are three concrete questions about </span><span dir="ltr" role="presentation">random circuit sampling of a quantum circuit</span> <span dir="ltr" role="presentation">C</span> <span dir="ltr" role="presentation">of the kind discussed in the Google </span><span dir="ltr" role="presentation">paper <span style="color:#ff0000;"><strong>with</strong></span></span><span style="color:#ff0000;"><strong> <span dir="ltr" role="presentation">22 qubits and depth</span> </strong></span><span dir="ltr" role="presentation"><span style="color:#ff0000;"><strong>14</strong></span>. These three questions refer, of course, to the ability of current <span style="color:#0000ff;">quantum computers</span>  (it is quite easy to achieve them with classical simulations). <br /></span></p>
<blockquote>
<p><br role="presentation" /><em><strong><span dir="ltr" role="presentation">1. Can humanity produce at present samples which are good approxima</span><span dir="ltr" role="presentation">tions of the Google noise model or any other specific noise model?</span></strong></em></p>
<p><em><strong><span dir="ltr" role="presentation">2. Has humanity reached the ability to produce samples for quantum circuit </span><span dir="ltr" role="presentation">C</span> <span dir="ltr" role="presentation">with</span> fidelity according to the <span dir="ltr" role="presentation">linear cross entropy</span> <span dir="ltr" role="presentation">fidelity-estimator above 0.15?</span></strong></em></p>
<p><em><strong><span dir="ltr" role="presentation">3. Has humanity reached the ability to predict, for a quantum circuit</span> <span dir="ltr" role="presentation">C</span><span dir="ltr" role="presentation">, </span><span dir="ltr" role="presentation">with good accuracy, the</span> <span dir="ltr" role="presentation">linear cross entropy</span> <span dir="ltr" role="presentation">fidelity estimator based on the fidelity </span><span dir="ltr" role="presentation">of the individual components of this circuit?</span></strong></em></p>
</blockquote>
<p><span dir="ltr" role="presentation">The findings of our Statistical Science paper </span><span dir="ltr" role="presentation">indicate that the answer to the first ques</span><span dir="ltr" role="presentation">tion is negative. The Google supremacy paper itself and subsequent confirmations </span><span dir="ltr" role="presentation">present a strong case for a positive answer to the other two questions (even for larger circuits). However, </span><span dir="ltr" role="presentation">there are remaining doubts and concerns that need to be carefully checked, </span><span dir="ltr" role="presentation">and not enough replications to regard the answer as a solid yes.</span></p>
<h2>How to check a 20-qubit quantum computer?</h2>
<p><a href="https://www.gov.il/en/departments/general/iia-to-establish-israeli-quantum-computing-center-17-jul-2022">It was announced</a> recently that Israel is going to build a quantum computer. It is an interesting question to find a methodology to confirm that a 10-qubit, 20-qubit or 50-qubit quantum computer genuinely performs quantum computation or rather that the experimental data represents classical computation. In our Statistical Science paper we offered a certain blind experiment mechanism, but it still requires that classical simulation be much slower than quantum computing.</p>
<p>In the new paper we also propose a mechanism for letting other groups test calibration methods (which are crucial ingredients in such experiments) on the Sycamore QC or other NISQ computers. In our discussions, the Google team endorsed both these proposals for future experiments. (See Section 5 of the new manuscript.)</p>
<p> </p><p class="authors">By Gil Kalai</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-06T21:26:21Z">Thursday, October 06 2022, 21:26</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='https://cstheory-jobs.org/2022/10/06/postdoc-at-ist-austria-apply-by-november-15-2022/'>Postdoc at IST Austria (apply by November 15, 2022)</a></h3>
          <p class='item-feed'>from <a href='https://cstheory-jobs.org'>CCI: jobs</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          We are looking for three outstanding, highly-motivated postdoctoral researchers interested in working on combinatorial algorithm, especially in dynamic settings. Website: ist.ac.at/en/job/postdoc-research-group-monika-henzinger/ Email: monika.henzinger@ist.ac.at
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p>We are looking for three outstanding, highly-motivated postdoctoral researchers interested in working on combinatorial algorithm, especially in dynamic settings.</p>
<p>Website: <a href="https://ist.ac.at/en/job/postdoc-research-group-monika-henzinger/">https://ist.ac.at/en/job/postdoc-research-group-monika-henzinger/</a><br />
Email: monika.henzinger@ist.ac.at</p>
<p class="authors">By shacharlovett</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-06T19:12:28Z">Thursday, October 06 2022, 19:12</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://blog.computationalcomplexity.org/2022/10/art-and-technology.html'>Art and Technology</a></h3>
          <p class='item-feed'>from <a href='http://blog.computationalcomplexity.org/'>Computational Complexity</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Last weekend I went to one of Chicago's jewels, the Art Institute, and saw the opening of a new exhibit by Berlin-based artist Josephine Pryde entitled The Vibrating Slab&nbsp;referring mainly to the phone that constantly tries to gain our attention. The exhibit used photographs and sculptures to tie smart phones to prehistoric rocks. No pictures here because ironically they didn't allow us to take photos with our "slabs".</p><p>After I saw the Pryde exhibit I went to see the artist herself give a presentation. She related a story where she talked about going to the movies and seeing Top Gun: Maverick, not knowing it is a new release. Tom Cruise, who&nbsp;controlled a computer with hand movements&nbsp;in Minority Report, goes old-school in Maverick. Cruise and several young actors, through various plot contrivances, flew 20th century planes in a movie that could have taken place in the 90s. According to IMBD, at the insistence of Tom Cruise, minimal green screen and CGI aerial shots exist in the film, and even the close up cockpit shots were taken during real in-flight sequences. Old school indeed. Kind of the opposite of say the Disney series The Mandalorian&nbsp;filmed in a soundstage with everything generated by CGI.</p><p>Pryde's exhibit looked at the interaction with technology as art. Upstairs from Pryde's exhibit was art from technology, a series of prints that David Hockney created on another slab, the iPad, in Normandy during the early days of the Covid pandemic.&nbsp;</p>♦No. 340, 21st May 2020 - David Hockney<p>On the way from Pryde's exhibit to the lecture I passed through the Art Institute's impressionism collection and compared real Monets with the fake one I created with Dall-E. Monet manages to capture a detailed scene with broad brush strokes--if you zoom in the detail disappears. Dall-E can't quite pull that off.</p>♦Vétheuil&nbsp;by Monet<br><br>♦Monet Dagsthul by Dall-E<p><br></p><p>By Lance Fortnow</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p>Last weekend I went to one of Chicago's jewels, the Art Institute, and saw the opening of a new exhibit by Berlin-based artist Josephine Pryde entitled <a href="https://www.artic.edu/exhibitions/2932/the-vibrating-slab">The Vibrating Slab</a>&nbsp;referring mainly to the phone that constantly tries to gain our attention. The exhibit used photographs and sculptures to tie smart phones to prehistoric rocks. No pictures here because ironically they didn't allow us to take photos with our "slabs".</p><p>After I saw the Pryde exhibit I went to see the artist herself give a presentation. She related a story where she talked about going to the movies and seeing <a href="https://www.imdb.com/title/tt1745960">Top Gun: Maverick</a>, not knowing it is a new release. Tom Cruise, who&nbsp;<a href="https://www.youtube.com/watch?v=PJqbivkm0Ms">controlled a computer with hand movements</a>&nbsp;in Minority Report, goes old-school in Maverick. Cruise and several young actors, through various plot contrivances, flew 20th century planes in a movie that could have taken place in the 90s. According to IMBD, at the insistence of Tom Cruise, minimal green screen and CGI aerial shots exist in the film, and even the close up cockpit shots were taken during real in-flight sequences. Old school indeed. Kind of the opposite of say the Disney series <a href="https://www.imdb.com/title/tt8111088/">The Mandalorian</a>&nbsp;filmed in a soundstage with everything generated by CGI.</p><p>Pryde's exhibit looked at the interaction with technology as art. Upstairs from Pryde's exhibit was art from technology, a <a href="https://www.artic.edu/exhibitions/9705/david-hockney-the-arrival-of-spring-normandy-2020">series of prints</a> that David Hockney created on another slab, the iPad, in Normandy during the early days of the Covid pandemic.&nbsp;</p><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto;"><tbody><tr><td style="text-align: center;"><a href="https://artic-web.imgix.net/b8c0f3d0-2abc-4c17-9aba-629d8536e90d/IPD-2221.jpg?rect=0%2C0%2C3564%2C2490&amp;auto=format%2Ccompress&amp;q=80&amp;fit=crop&amp;crop=faces%2Cedges%2Centropy&amp;w=1600&amp;h=1118" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="559" data-original-width="800" height="280" src="https://artic-web.imgix.net/b8c0f3d0-2abc-4c17-9aba-629d8536e90d/IPD-2221.jpg?rect=0%2C0%2C3564%2C2490&amp;auto=format%2Ccompress&amp;q=80&amp;fit=crop&amp;crop=faces%2Cedges%2Centropy&amp;w=1600&amp;h=1118" width="400" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">No. 340, 21st May 2020 - David Hockney</td></tr></tbody></table><div><p>On the way from Pryde's exhibit to the lecture I passed through the Art Institute's impressionism collection and compared real Monets with the fake one I created with Dall-E. Monet manages to capture a detailed scene with broad brush strokes--if you zoom in the detail disappears. Dall-E can't quite pull that off.</p><table cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="https://www.artic.edu/iiif/2/d39b1026-7d8d-6e6a-738e-8a136b1a0033/full/843,/0/default.jpg" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" data-original-height="770" data-original-width="800" height="308" src="https://www.artic.edu/iiif/2/d39b1026-7d8d-6e6a-738e-8a136b1a0033/full/843,/0/default.jpg" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;"><a href="https://www.artic.edu/artworks/14634/vetheuil">Vétheuil</a>&nbsp;by Monet<br /><br /></td></tr></tbody></table><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto;"><tbody><tr><td style="text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjZ6-EWvauVOODiC3Q6NtPqk34MFd8yF-m0Pr8qms48vtunPrdnclEYpSdFnlm691u7vTf4qU7EkPCOSaY8NSmfxh6FYsgKUN5QWaAzirVQDaX_Y9kZarqcyCtUafapja3KIy3k6bUd9SrlL83yCOnayQgseDMD3xcCwfPzvb0kimeKIr8FDw/s1024/DALL%C2%B7E%202022-09-17%2014.00.36%20-%20Schloss%20Dagstuhl%20in%20the%20style%20of%20monet.png" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="1024" data-original-width="1024" height="320" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjZ6-EWvauVOODiC3Q6NtPqk34MFd8yF-m0Pr8qms48vtunPrdnclEYpSdFnlm691u7vTf4qU7EkPCOSaY8NSmfxh6FYsgKUN5QWaAzirVQDaX_Y9kZarqcyCtUafapja3KIy3k6bUd9SrlL83yCOnayQgseDMD3xcCwfPzvb0kimeKIr8FDw/w320-h320/DALL%C2%B7E%202022-09-17%2014.00.36%20-%20Schloss%20Dagstuhl%20in%20the%20style%20of%20monet.png" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Monet Dagsthul by Dall-E</td></tr></tbody></table><p><br /></p></div><p class="authors">By Lance Fortnow</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-06T13:40:00Z">Thursday, October 06 2022, 13:40</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.02035'>A Counterexample to a Directed KKL Inequality</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Quentin Dubroff, Shivam Nadimpalli, Bhargav Narayanan</p><p>We show that the natural directed analogues of the KKL theorem [KKL88] and
the Eldan--Gross inequality [EG20] from the analysis of Boolean functions fail
to hold. This is in contrast to several other isoperimetric inequalities on the
Boolean hypercube (such as the Poincare inequality, Margulis's inequality
[Mar74] and Talagrand's inequality [Tal93]) for which directed strengthenings
have recently been established.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/math/1/au:+Dubroff_Q/0/1/0/all/0/1">Quentin Dubroff</a>, <a href="http://arxiv.org/find/math/1/au:+Nadimpalli_S/0/1/0/all/0/1">Shivam Nadimpalli</a>, <a href="http://arxiv.org/find/math/1/au:+Narayanan_B/0/1/0/all/0/1">Bhargav Narayanan</a></p><p>We show that the natural directed analogues of the KKL theorem [KKL88] and
the Eldan--Gross inequality [EG20] from the analysis of Boolean functions fail
to hold. This is in contrast to several other isoperimetric inequalities on the
Boolean hypercube (such as the Poincare inequality, Margulis's inequality
[Mar74] and Talagrand's inequality [Tal93]) for which directed strengthenings
have recently been established.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-06T00:30:00Z">Thursday, October 06 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.02288'>On Convexity in Split graphs: Complexity of Steiner tree and Domination</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: A Mohanapriya, P Renjith, N Sadagopan</p><p>Given a graph $G$ with a terminal set $R \subseteq V(G)$, the Steiner tree
problem (STREE) asks for a set $S\subseteq V(G) \setminus R$ such that the
graph induced on $S\cup R$ is connected. A split graph is a graph which can be
partitioned into a clique and an independent set. It is known that STREE is
NP-complete on split graphs \cite{white1985steiner}. To strengthen this result,
we introduce convex ordering on one of the partitions (clique or independent
set), and prove that STREE is polynomial-time solvable for tree-convex split
graphs with convexity on clique ($K$), whereas STREE is NP-complete on
tree-convex split graphs with convexity on independent set ($I$). We further
strengthen our NP-complete result by establishing a dichotomy which says that
for unary-tree-convex split graphs (path-convex split graphs), STREE is
polynomial-time solvable, and NP-complete for binary-tree-convex split graphs
(comb-convex split graphs). We also show that STREE is polynomial-time solvable
for triad-convex split graphs with convexity on $I$, and circular-convex split
graphs. Further, we show that STREE can be used as a framework for the
dominating set problem (DS) on split graphs, and hence the classical complexity
(P vs NPC) of STREE and DS is the same for all these subclasses of split
graphs. Furthermore, it is important to highlight that in
\cite{CHLEBIK20081264}, it is incorrectly claimed that the problem of finding a
minimum dominating set on split graphs cannot be approximated within
$(1-\epsilon)\ln |V(G)|$ in polynomial-time for any $\epsilon &gt;0$ unless NP
$\subseteq$ DTIME $n^{O(\log \log n)}$. When the input is restricted to split
graphs, we show that the minimum dominating set problem has
$2-\frac{1}{|I|}$-approximation algorithm that runs in polynomial time.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Mohanapriya_A/0/1/0/all/0/1">A Mohanapriya</a>, <a href="http://arxiv.org/find/cs/1/au:+Renjith_P/0/1/0/all/0/1">P Renjith</a>, <a href="http://arxiv.org/find/cs/1/au:+Sadagopan_N/0/1/0/all/0/1">N Sadagopan</a></p><p>Given a graph $G$ with a terminal set $R \subseteq V(G)$, the Steiner tree
problem (STREE) asks for a set $S\subseteq V(G) \setminus R$ such that the
graph induced on $S\cup R$ is connected. A split graph is a graph which can be
partitioned into a clique and an independent set. It is known that STREE is
NP-complete on split graphs \cite{white1985steiner}. To strengthen this result,
we introduce convex ordering on one of the partitions (clique or independent
set), and prove that STREE is polynomial-time solvable for tree-convex split
graphs with convexity on clique ($K$), whereas STREE is NP-complete on
tree-convex split graphs with convexity on independent set ($I$). We further
strengthen our NP-complete result by establishing a dichotomy which says that
for unary-tree-convex split graphs (path-convex split graphs), STREE is
polynomial-time solvable, and NP-complete for binary-tree-convex split graphs
(comb-convex split graphs). We also show that STREE is polynomial-time solvable
for triad-convex split graphs with convexity on $I$, and circular-convex split
graphs. Further, we show that STREE can be used as a framework for the
dominating set problem (DS) on split graphs, and hence the classical complexity
(P vs NPC) of STREE and DS is the same for all these subclasses of split
graphs. Furthermore, it is important to highlight that in
\cite{CHLEBIK20081264}, it is incorrectly claimed that the problem of finding a
minimum dominating set on split graphs cannot be approximated within
$(1-\epsilon)\ln |V(G)|$ in polynomial-time for any $\epsilon &gt;0$ unless NP
$\subseteq$ DTIME $n^{O(\log \log n)}$. When the input is restricted to split
graphs, we show that the minimum dominating set problem has
$2-\frac{1}{|I|}$-approximation algorithm that runs in polynomial time.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-06T00:30:00Z">Thursday, October 06 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.02167'>Faster parameterized algorithms for modification problems to minor-closed classes</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Laure Morelle, Ignasi Sau, Giannos Stamoulis, Dimitrios M. Thilikos</p><p>Let ${\cal G}$ be a minor-closed graph class and let $G$ be an $n$-vertex
graph. We say that $G$ is a $k$-apex of ${\cal G}$ if $G$ contains a set $S$ of
at most $k$ vertices such that $G\setminus S$ belongs to ${\cal G}$. Our first
result is an algorithm that decides whether $G$ is a $k$-apex of ${\cal G}$ in
time $2^{{\sf poly}(k)}\cdot n^2$, where ${\sf poly}$ is a polynomial function
depending on ${\cal G}$. This algorithm improves the previous one, given by
Sau, Stamoulis, and Thilikos [ICALP 2020], whose running time was $2^{{\sf
poly}(k)}\cdot n^3$. The elimination distance of $G$ to ${\cal G}$, denoted by
${\sf ed}_{\cal G}(G)$, is the minimum number of rounds required to reduce each
connected component of $G$ to a graph in ${\cal G}$ by removing one vertex from
each connected component in each round. Bulian and Dawar [Algorithmica 2017]
provided an FPT-algorithm, with parameter $k$, to decide whether ${\sf
ed}_{\cal G}(G)\leq k$. However, its dependence on $k$ is not explicit. We
extend the techniques used in the first algorithm to decide whether ${\sf
ed}_{\cal G}(G)\leq k$ in time $2^{2^{2^{{\sf poly}(k)}}}\cdot n^2$. This is
the first algorithm for this problem with an explicit parametric dependence in
$k$. In the special case where ${\cal G}$ excludes some apex-graph as a minor,
we give two alternative algorithms, running in time $2^{2^{{\cal O}(k^2\log
k)}}\cdot n^2$ and $2^{{\sf poly}(k)}\cdot n^3$ respectively, where $c$ and
${\sf poly}$ depend on ${\cal G}$. As a stepping stone for these algorithms, we
provide an algorithm that decides whether ${\sf ed}_{\cal G}(G)\leq k$ in time
$2^{{\cal O}({\sf tw}\cdot k+{\sf tw}\log{\sf tw})}\cdot n$, where ${\sf tw}$
is the treewidth of $G$. Finally, we provide explicit upper bounds on the size
of the graphs in the minor-obstruction set of the class of graphs ${\cal
E}_k({\cal G})=\{G\mid{\sf ed}_{\cal G}(G)\leq k\}$.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Morelle_L/0/1/0/all/0/1">Laure Morelle</a>, <a href="http://arxiv.org/find/cs/1/au:+Sau_I/0/1/0/all/0/1">Ignasi Sau</a>, <a href="http://arxiv.org/find/cs/1/au:+Stamoulis_G/0/1/0/all/0/1">Giannos Stamoulis</a>, <a href="http://arxiv.org/find/cs/1/au:+Thilikos_D/0/1/0/all/0/1">Dimitrios M. Thilikos</a></p><p>Let ${\cal G}$ be a minor-closed graph class and let $G$ be an $n$-vertex
graph. We say that $G$ is a $k$-apex of ${\cal G}$ if $G$ contains a set $S$ of
at most $k$ vertices such that $G\setminus S$ belongs to ${\cal G}$. Our first
result is an algorithm that decides whether $G$ is a $k$-apex of ${\cal G}$ in
time $2^{{\sf poly}(k)}\cdot n^2$, where ${\sf poly}$ is a polynomial function
depending on ${\cal G}$. This algorithm improves the previous one, given by
Sau, Stamoulis, and Thilikos [ICALP 2020], whose running time was $2^{{\sf
poly}(k)}\cdot n^3$. The elimination distance of $G$ to ${\cal G}$, denoted by
${\sf ed}_{\cal G}(G)$, is the minimum number of rounds required to reduce each
connected component of $G$ to a graph in ${\cal G}$ by removing one vertex from
each connected component in each round. Bulian and Dawar [Algorithmica 2017]
provided an FPT-algorithm, with parameter $k$, to decide whether ${\sf
ed}_{\cal G}(G)\leq k$. However, its dependence on $k$ is not explicit. We
extend the techniques used in the first algorithm to decide whether ${\sf
ed}_{\cal G}(G)\leq k$ in time $2^{2^{2^{{\sf poly}(k)}}}\cdot n^2$. This is
the first algorithm for this problem with an explicit parametric dependence in
$k$. In the special case where ${\cal G}$ excludes some apex-graph as a minor,
we give two alternative algorithms, running in time $2^{2^{{\cal O}(k^2\log
k)}}\cdot n^2$ and $2^{{\sf poly}(k)}\cdot n^3$ respectively, where $c$ and
${\sf poly}$ depend on ${\cal G}$. As a stepping stone for these algorithms, we
provide an algorithm that decides whether ${\sf ed}_{\cal G}(G)\leq k$ in time
$2^{{\cal O}({\sf tw}\cdot k+{\sf tw}\log{\sf tw})}\cdot n$, where ${\sf tw}$
is the treewidth of $G$. Finally, we provide explicit upper bounds on the size
of the graphs in the minor-obstruction set of the class of graphs ${\cal
E}_k({\cal G})=\{G\mid{\sf ed}_{\cal G}(G)\leq k\}$.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-06T00:30:00Z">Thursday, October 06 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.01849'>Link Partitioning on Simplicial Complexes Using Higher-Order Laplacians</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Xinyi Wu, Arnab Sarker, Ali Jadbabaie</p><p>Link partitioning is a popular approach in network science used for
discovering overlapping communities by identifying clusters of strongly
connected links. Current link partitioning methods are specifically designed
for networks modelled by graphs representing pairwise relationships. Therefore,
these methods are incapable of utilizing higher-order information about group
interactions in network data which is increasingly available. Simplicial
complexes extend the dyadic model of graphs and can model polyadic
relationships which are ubiquitous and crucial in many complex social and
technological systems. In this paper, we introduce a link partitioning method
that leverages higher-order (i.e. triadic and higher) information in simplicial
complexes for better community detection. Our method utilizes a novel random
walk on links of simplicial complexes defined by the higher-order Laplacian--a
generalization of the graph Laplacian that incorporates polyadic relationships
of the network. We transform this random walk into a graph-based random walk on
a lifted line graph--a dual graph in which links are nodes while nodes and
higher-order connections are links--and optimize for the standard notion of
modularity. We show that our method is guaranteed to provide interpretable link
partitioning results under mild assumptions. We also offer new theoretical
results on the spectral properties of simplicial complexes by studying the
spectrum of the link random walk. Experiment results on real-world community
detection tasks show that our higher-order approach significantly outperforms
existing graph-based link partitioning methods.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Wu_X/0/1/0/all/0/1">Xinyi Wu</a>, <a href="http://arxiv.org/find/cs/1/au:+Sarker_A/0/1/0/all/0/1">Arnab Sarker</a>, <a href="http://arxiv.org/find/cs/1/au:+Jadbabaie_A/0/1/0/all/0/1">Ali Jadbabaie</a></p><p>Link partitioning is a popular approach in network science used for
discovering overlapping communities by identifying clusters of strongly
connected links. Current link partitioning methods are specifically designed
for networks modelled by graphs representing pairwise relationships. Therefore,
these methods are incapable of utilizing higher-order information about group
interactions in network data which is increasingly available. Simplicial
complexes extend the dyadic model of graphs and can model polyadic
relationships which are ubiquitous and crucial in many complex social and
technological systems. In this paper, we introduce a link partitioning method
that leverages higher-order (i.e. triadic and higher) information in simplicial
complexes for better community detection. Our method utilizes a novel random
walk on links of simplicial complexes defined by the higher-order Laplacian--a
generalization of the graph Laplacian that incorporates polyadic relationships
of the network. We transform this random walk into a graph-based random walk on
a lifted line graph--a dual graph in which links are nodes while nodes and
higher-order connections are links--and optimize for the standard notion of
modularity. We show that our method is guaranteed to provide interpretable link
partitioning results under mild assumptions. We also offer new theoretical
results on the spectral properties of simplicial complexes by studying the
spectrum of the link random walk. Experiment results on real-world community
detection tasks show that our higher-order approach significantly outperforms
existing graph-based link partitioning methods.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-06T00:30:00Z">Thursday, October 06 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.01888'>Bicriteria Approximation Algorithms for Priority Matroid Median</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Tanvi Bajpai, Chandra Chekuri</p><p>Fairness considerations have motivated new clustering problems and algorithms
in recent years. In this paper we consider the Priority Matroid Median problem
which generalizes the Priority $k$-Median problem that has recently been
studied. The input consists of a set of facilities $\mathcal{F}$ and a set of
clients $\mathcal{C}$ that lie in a metric space $(\mathcal{F} \cup
\mathcal{C},d)$, and a matroid $\mathcal{M}=(\mathcal{F},\mathcal{I})$ over the
facilities. In addition each client $j$ has a specified radius $r_j \ge 0$ and
each facility $i \in \mathcal{F}$ has an opening cost $f_i$. The goal is to
choose a subset $S \subseteq \mathcal{F}$ of facilities to minimize the
$\sum_{i \in \mathcal{F}} f_i + \sum_{j \in \mathcal{C}} d(j,S)$ subject to two
constraints: (i) $S$ is an independent set in $\mathcal{M}$ (that is $S \in
\mathcal{I}$) and (ii) for each client $j$, its distance to an open facility is
at most $r_j$ (that is, $d(j,S) \le r_j$). For this problem we describe the
first bicriteria $(c_1,c_2)$ approximations for fixed constants $c_1,c_2$: the
radius constraints of the clients are violated by at most a factor of $c_1$ and
the objective cost is at most $c_2$ times the optimum cost. We also improve the
previously known bicriteria approximation for the uniform radius setting ($r_j
:= L$ $\forall j \in \mathcal{C}$).
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Bajpai_T/0/1/0/all/0/1">Tanvi Bajpai</a>, <a href="http://arxiv.org/find/cs/1/au:+Chekuri_C/0/1/0/all/0/1">Chandra Chekuri</a></p><p>Fairness considerations have motivated new clustering problems and algorithms
in recent years. In this paper we consider the Priority Matroid Median problem
which generalizes the Priority $k$-Median problem that has recently been
studied. The input consists of a set of facilities $\mathcal{F}$ and a set of
clients $\mathcal{C}$ that lie in a metric space $(\mathcal{F} \cup
\mathcal{C},d)$, and a matroid $\mathcal{M}=(\mathcal{F},\mathcal{I})$ over the
facilities. In addition each client $j$ has a specified radius $r_j \ge 0$ and
each facility $i \in \mathcal{F}$ has an opening cost $f_i$. The goal is to
choose a subset $S \subseteq \mathcal{F}$ of facilities to minimize the
$\sum_{i \in \mathcal{F}} f_i + \sum_{j \in \mathcal{C}} d(j,S)$ subject to two
constraints: (i) $S$ is an independent set in $\mathcal{M}$ (that is $S \in
\mathcal{I}$) and (ii) for each client $j$, its distance to an open facility is
at most $r_j$ (that is, $d(j,S) \le r_j$). For this problem we describe the
first bicriteria $(c_1,c_2)$ approximations for fixed constants $c_1,c_2$: the
radius constraints of the clients are violated by at most a factor of $c_1$ and
the objective cost is at most $c_2$ times the optimum cost. We also improve the
previously known bicriteria approximation for the uniform radius setting ($r_j
:= L$ $\forall j \in \mathcal{C}$).
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-06T00:30:00Z">Thursday, October 06 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.01897'>The DAG Visit approach for Pebbling and I/O Lower Bounds</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Gianfranco Bilardi, Lorenzo De Stefani</p><p>We introduce the notion of an $r$-visit of a Directed Acyclic Graph DAG
$G=(V,E)$, a sequence of the vertices of the DAG complying with a given rule
$r$. A rule $r$ specifies for each vertex $v\in V$ a family of $r$-enabling
sets of (immediate) predecessors: before visiting $v$, at least one of its
enabling sets must have been visited. Special cases are the $r^{(top)}$-rule
(or, topological rule), for which the only enabling set is the set of all
predecessors and the $r^{(sin)}$-rule (or, singleton rule), for which the
enabling sets are the singletons containing exactly one predecessor. The
$r$-boundary complexity of a DAG $G$, $b_{r}\left(G\right)$, is the minimum
integer $b$ such that there is an $r$-visit where, at each stage, for at most
$b$ of the vertices yet to be visited an enabling set has already been visited.
By a reformulation of known results, it is shown that the boundary complexity
of a DAG $G$ is a lower bound to the pebbling number of the reverse DAG, $G^R$.
Several known pebbling lower bounds can be cast in terms of the
$r^{(sin)}$-boundary complexity.
</p>
<p>A visit partition technique for I/O lower bounds, which generalizes the
$S$-partition I/O technique introduced by Hong and Kung in their classic paper
"I/O complexity: The Red-Blue pebble game". The visit partition approach yields
tight I/O bounds for some DAGs for which the $S$-partition technique can only
yield an $\Omega(1)$ lower bound.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Bilardi_G/0/1/0/all/0/1">Gianfranco Bilardi</a>, <a href="http://arxiv.org/find/cs/1/au:+Stefani_L/0/1/0/all/0/1">Lorenzo De Stefani</a></p><p>We introduce the notion of an $r$-visit of a Directed Acyclic Graph DAG
$G=(V,E)$, a sequence of the vertices of the DAG complying with a given rule
$r$. A rule $r$ specifies for each vertex $v\in V$ a family of $r$-enabling
sets of (immediate) predecessors: before visiting $v$, at least one of its
enabling sets must have been visited. Special cases are the $r^{(top)}$-rule
(or, topological rule), for which the only enabling set is the set of all
predecessors and the $r^{(sin)}$-rule (or, singleton rule), for which the
enabling sets are the singletons containing exactly one predecessor. The
$r$-boundary complexity of a DAG $G$, $b_{r}\left(G\right)$, is the minimum
integer $b$ such that there is an $r$-visit where, at each stage, for at most
$b$ of the vertices yet to be visited an enabling set has already been visited.
By a reformulation of known results, it is shown that the boundary complexity
of a DAG $G$ is a lower bound to the pebbling number of the reverse DAG, $G^R$.
Several known pebbling lower bounds can be cast in terms of the
$r^{(sin)}$-boundary complexity.
</p>
<p>A visit partition technique for I/O lower bounds, which generalizes the
$S$-partition I/O technique introduced by Hong and Kung in their classic paper
"I/O complexity: The Red-Blue pebble game". The visit partition approach yields
tight I/O bounds for some DAGs for which the $S$-partition technique can only
yield an $\Omega(1)$ lower bound.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-06T00:30:00Z">Thursday, October 06 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.01954'>Rectangular Ruler Wrapping</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Xing Lyu, Travis Gagie</p><p>In 1985 Hopcroft, Joseph and Whitesides introduced the problem of folding a
carpenter's ruler with $n$ hinged segments of lengths $\ell_1, \ldots, \ell_n$
into an interval of a given length $k$. By {\em folding} we mean that each
hinge must be either straight or folded 180 degrees, with folded hinges
alternating between being folded clockwise and counterclockwise. They showed
this problem is NP-hard in the weak sense by a reduction from {\sc Partition},
gave a pseudo-polynomial-time algorithm for it, and gave an $O (n)$-time
2-approximation algorithm. Gagie, Saeidi and Sapucaia recently considered the
related problem of wrapping the ruler into the interval instead of folding it.
By {\em wrapping} we mean that all the folded hinges must be folded 180 degrees
clockwise. They gave an $O (n)$-time algorithm for this problem, based on the
$O (n \log n)$-time algorithm for {\sc Longest Increasing Subsequence} that
Fredman analyzed and attributed to Knuth, thus answering a question posed by
O'Rourke during the open-problems session of CCCG '21.
</p>
<p>Hopcroft et al.\ and Gagie et al.\ assume the ruler's segments are lines and
its hinges are points, so a folded ruler has length but zero width. As anyone
who has ever folded something knows, however, making perfect 180-degree folds
is not always possible. In this paper we initiate the study of {\em
rectangular} ruler wrapping, for which all folded hinges are to be folded 90
degrees clockwise instead of 180 degrees and we want the wrapped ruler to fit
in a rectangle of height $h$ and width $w$. We give a quartic algorithm and
then an $O (n^2\,\mathrm{polylog} (n))$-time algorithm.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Lyu_X/0/1/0/all/0/1">Xing Lyu</a>, <a href="http://arxiv.org/find/cs/1/au:+Gagie_T/0/1/0/all/0/1">Travis Gagie</a></p><p>In 1985 Hopcroft, Joseph and Whitesides introduced the problem of folding a
carpenter's ruler with $n$ hinged segments of lengths $\ell_1, \ldots, \ell_n$
into an interval of a given length $k$. By {\em folding} we mean that each
hinge must be either straight or folded 180 degrees, with folded hinges
alternating between being folded clockwise and counterclockwise. They showed
this problem is NP-hard in the weak sense by a reduction from {\sc Partition},
gave a pseudo-polynomial-time algorithm for it, and gave an $O (n)$-time
2-approximation algorithm. Gagie, Saeidi and Sapucaia recently considered the
related problem of wrapping the ruler into the interval instead of folding it.
By {\em wrapping} we mean that all the folded hinges must be folded 180 degrees
clockwise. They gave an $O (n)$-time algorithm for this problem, based on the
$O (n \log n)$-time algorithm for {\sc Longest Increasing Subsequence} that
Fredman analyzed and attributed to Knuth, thus answering a question posed by
O'Rourke during the open-problems session of CCCG '21.
</p>
<p>Hopcroft et al.\ and Gagie et al.\ assume the ruler's segments are lines and
its hinges are points, so a folded ruler has length but zero width. As anyone
who has ever folded something knows, however, making perfect 180-degree folds
is not always possible. In this paper we initiate the study of {\em
rectangular} ruler wrapping, for which all folded hinges are to be folded 90
degrees clockwise instead of 180 degrees and we want the wrapped ruler to fit
in a rectangle of height $h$ and width $w$. We give a quartic algorithm and
then an $O (n^2\,\mathrm{polylog} (n))$-time algorithm.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-06T00:30:00Z">Thursday, October 06 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.02000'>Internal Longest Palindrome Queries in Optimal Time</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Kazuki Mitani, Takuya Mieno, Kazuhisa Seto, Takashi Horiyama</p><p>Palindromes are strings that read the same forward and backward. Problems of
computing palindromic structures in strings have been studied for many years
with a motivation of their application to biology. The longest palindrome
problem is one of the most important and classical problems regarding
palindromic structures, that is, to compute the longest palindrome appearing in
a string $T$ of length $n$. The problem can be solved in $\mathcal{O}(n)$ time
by the famous algorithm of Manacher [Journal of the ACM, 1975]. In this paper,
we consider the problem in the internal model. The internal longest palindrome
query is, given a substring $T[i..j]$ of $T$ as a query, to compute the longest
palindrome appearing in $T[i.. j]$. The best known data structure for this
problem is the one proposed by Amir et al. [Algorithmica, 2020], which can
answer any query in $\mathcal{O}(\log n)$ time. In this paper, we propose a
linear-size data structure that can answer any internal longest palindrome
query in constant time. Also, given the input string $T$, our data structure
can be constructed in $\mathcal{O}(n)$ time.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Mitani_K/0/1/0/all/0/1">Kazuki Mitani</a>, <a href="http://arxiv.org/find/cs/1/au:+Mieno_T/0/1/0/all/0/1">Takuya Mieno</a>, <a href="http://arxiv.org/find/cs/1/au:+Seto_K/0/1/0/all/0/1">Kazuhisa Seto</a>, <a href="http://arxiv.org/find/cs/1/au:+Horiyama_T/0/1/0/all/0/1">Takashi Horiyama</a></p><p>Palindromes are strings that read the same forward and backward. Problems of
computing palindromic structures in strings have been studied for many years
with a motivation of their application to biology. The longest palindrome
problem is one of the most important and classical problems regarding
palindromic structures, that is, to compute the longest palindrome appearing in
a string $T$ of length $n$. The problem can be solved in $\mathcal{O}(n)$ time
by the famous algorithm of Manacher [Journal of the ACM, 1975]. In this paper,
we consider the problem in the internal model. The internal longest palindrome
query is, given a substring $T[i..j]$ of $T$ as a query, to compute the longest
palindrome appearing in $T[i.. j]$. The best known data structure for this
problem is the one proposed by Amir et al. [Algorithmica, 2020], which can
answer any query in $\mathcal{O}(\log n)$ time. In this paper, we propose a
linear-size data structure that can answer any internal longest palindrome
query in constant time. Also, given the input string $T$, our data structure
can be constructed in $\mathcal{O}(n)$ time.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-06T00:30:00Z">Thursday, October 06 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.02067'>Computing maximal generalized palindromes</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Mitsuru Funakoshi, Takuya Mieno, Yuto Nakashima, Shunsuke Inenaga, Hideo Bannai, Masayuki Takeda</p><p>Palindromes are popular and important objects in textual data processing,
bioinformatics, and combinatorics on words. Let $S = XaY$ be a string, where
$X$ and $Y$ are of the same length and $a$ is either a single character or the
empty string. Then, there exist two alternative definitions for palindromes:
$S$ is said to be a palindrome if: Reversal-based definition: $S$ is equal to
its reversal $S^R$; Symmetry-based definition: its left-arm $X$ is equal to the
reversal of its right-arm $Y^R$. It is clear that if the "equality" ($\approx$)
used in both definitions is exact character matching ($=$), then the two
definitions are the same. However, if we apply other string-equality criteria
$\approx$, including the complementary model for biological sequences, the
parameterized model [Baker, JCSS 1996], the order-preserving model [Kim et al.,
TCS 2014], the Cartesian-tree model [Park et al., TCS 2020], and the
palindromic-structure model [I et al., TCS 2013], then are the reversal-based
palindromes and the symmetry-based palindromes the same? To the best of our
knowledge, no previous work has considered or answered this natural question.
In this paper, we first provide answers to this question, and then present
efficient algorithms for computing all maximal generalized palindromes that
occur in a given string. After confirming that Gusfield's offline suffix-tree
based algorithm for computing maximal symmetry-based palindromes can be readily
extended to the aforementioned matching models, we show how to extend
Manacher's online algorithm for computing maximal reversal-based palindromes in
linear time for all the aforementioned matching models.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Funakoshi_M/0/1/0/all/0/1">Mitsuru Funakoshi</a>, <a href="http://arxiv.org/find/cs/1/au:+Mieno_T/0/1/0/all/0/1">Takuya Mieno</a>, <a href="http://arxiv.org/find/cs/1/au:+Nakashima_Y/0/1/0/all/0/1">Yuto Nakashima</a>, <a href="http://arxiv.org/find/cs/1/au:+Inenaga_S/0/1/0/all/0/1">Shunsuke Inenaga</a>, <a href="http://arxiv.org/find/cs/1/au:+Bannai_H/0/1/0/all/0/1">Hideo Bannai</a>, <a href="http://arxiv.org/find/cs/1/au:+Takeda_M/0/1/0/all/0/1">Masayuki Takeda</a></p><p>Palindromes are popular and important objects in textual data processing,
bioinformatics, and combinatorics on words. Let $S = XaY$ be a string, where
$X$ and $Y$ are of the same length and $a$ is either a single character or the
empty string. Then, there exist two alternative definitions for palindromes:
$S$ is said to be a palindrome if: Reversal-based definition: $S$ is equal to
its reversal $S^R$; Symmetry-based definition: its left-arm $X$ is equal to the
reversal of its right-arm $Y^R$. It is clear that if the "equality" ($\approx$)
used in both definitions is exact character matching ($=$), then the two
definitions are the same. However, if we apply other string-equality criteria
$\approx$, including the complementary model for biological sequences, the
parameterized model [Baker, JCSS 1996], the order-preserving model [Kim et al.,
TCS 2014], the Cartesian-tree model [Park et al., TCS 2020], and the
palindromic-structure model [I et al., TCS 2013], then are the reversal-based
palindromes and the symmetry-based palindromes the same? To the best of our
knowledge, no previous work has considered or answered this natural question.
In this paper, we first provide answers to this question, and then present
efficient algorithms for computing all maximal generalized palindromes that
occur in a given string. After confirming that Gusfield's offline suffix-tree
based algorithm for computing maximal symmetry-based palindromes can be readily
extended to the aforementioned matching models, we show how to extend
Manacher's online algorithm for computing maximal reversal-based palindromes in
linear time for all the aforementioned matching models.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-06T00:30:00Z">Thursday, October 06 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.02117'>Tight Lower Bounds for Problems Parameterized by Rank-width</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Benjamin Bergougnoux, Tuukka Korhonen, Jesper Nederlof</p><p>We show that there is no $2^{o(k^2)} n^{O(1)}$ time algorithm for Independent
Set on $n$-vertex graphs with rank-width $k$, unless the Exponential Time
Hypothesis (ETH) fails. Our lower bound matches the $2^{O(k^2)} n^{O(1)}$ time
algorithm given by Bui-Xuan, Telle, and Vatshelle [Discret.~Appl.~Math., 2010]
and it answers the open question of Bergougnoux and Kant\'{e} [SIAM J. Discret.
Math.,~2021]. We also show that the known $2^{O(k^2)} n^{O(1)}$ time algorithms
for Weighted Dominating Set, Maximum Induced Matching and Feedback Vertex Set
parameterized by rank-width $k$ are optimal assuming ETH. Our results are the
first tight ETH lower bounds parameterized by rank-width that do not follow
directly from lower bounds for $n$-vertex graphs.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Bergougnoux_B/0/1/0/all/0/1">Benjamin Bergougnoux</a>, <a href="http://arxiv.org/find/cs/1/au:+Korhonen_T/0/1/0/all/0/1">Tuukka Korhonen</a>, <a href="http://arxiv.org/find/cs/1/au:+Nederlof_J/0/1/0/all/0/1">Jesper Nederlof</a></p><p>We show that there is no $2^{o(k^2)} n^{O(1)}$ time algorithm for Independent
Set on $n$-vertex graphs with rank-width $k$, unless the Exponential Time
Hypothesis (ETH) fails. Our lower bound matches the $2^{O(k^2)} n^{O(1)}$ time
algorithm given by Bui-Xuan, Telle, and Vatshelle [Discret.~Appl.~Math., 2010]
and it answers the open question of Bergougnoux and Kant\'{e} [SIAM J. Discret.
Math.,~2021]. We also show that the known $2^{O(k^2)} n^{O(1)}$ time algorithms
for Weighted Dominating Set, Maximum Induced Matching and Feedback Vertex Set
parameterized by rank-width $k$ are optimal assuming ETH. Our results are the
first tight ETH lower bounds parameterized by rank-width that do not follow
directly from lower bounds for $n$-vertex graphs.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-06T00:30:00Z">Thursday, October 06 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.02292'>Double-Ended Palindromic Trees: A Linear-Time Data Structure and Its Applications</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Qisheng Wang, Ming Yang, Xinrui Zhu</p><p>The palindromic tree (a.k.a. eertree) is a linear-size data structure that
provides access to all palindromic substrings of a string. In this paper, we
propose a generalized version of eertree, called double-ended eertree, which
supports linear-time online double-ended queue operations on the stored string.
At the heart of our construction, is a class of substrings, called surfaces, of
independent interest. Namely, surfaces are neither prefixes nor suffixes of any
other palindromic substrings and characterize the link structure of all
palindromic substrings in the eertree.
</p>
<p>As an application, we develop a framework for range queries involving
palindromes on strings, including counting distinct palindromic substrings, and
finding the longest palindromic substring, shortest unique palindromic
substring and shortest absent palindrome of any substring. In particular,
offline queries only use linear space. Apart from range queries, we enumerate
palindromic rich strings with a given word in linear time on the length of the
given word.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Wang_Q/0/1/0/all/0/1">Qisheng Wang</a>, <a href="http://arxiv.org/find/cs/1/au:+Yang_M/0/1/0/all/0/1">Ming Yang</a>, <a href="http://arxiv.org/find/cs/1/au:+Zhu_X/0/1/0/all/0/1">Xinrui Zhu</a></p><p>The palindromic tree (a.k.a. eertree) is a linear-size data structure that
provides access to all palindromic substrings of a string. In this paper, we
propose a generalized version of eertree, called double-ended eertree, which
supports linear-time online double-ended queue operations on the stored string.
At the heart of our construction, is a class of substrings, called surfaces, of
independent interest. Namely, surfaces are neither prefixes nor suffixes of any
other palindromic substrings and characterize the link structure of all
palindromic substrings in the eertree.
</p>
<p>As an application, we develop a framework for range queries involving
palindromes on strings, including counting distinct palindromic substrings, and
finding the longest palindromic substring, shortest unique palindromic
substring and shortest absent palindrome of any substring. In particular,
offline queries only use linear space. Apart from range queries, we enumerate
palindromic rich strings with a given word in linear time on the length of the
given word.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-06T00:30:00Z">Thursday, October 06 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.02361'>The Power of Duality: Response Time Analysis meets Integer Programming</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Max A. Deppert, Klaus Jansen</p><p>We study a mutually enriching connection between response time analysis in
real-time systems and the mixing set problem. Thereby generalizing over known
results we present a new approach to the computation of response times in
fixed-priority uniprocessor real-time scheduling. We even allow that the tasks
are delayed by some period-constrained release jitter. By studying a dual
problem formulation of the decision problem as an integer linear program we
show that worst-case response times can be computed by algorithmically
exploiting a conditional reduction to an instance of the mixing set problem. In
the important case of harmonic periods our new technique admits a
near-quadratic algorithm to the exact computation of worst-case response times.
We show that generally, a smaller utilization leads to more efficient
algorithms even in fixed-priority scheduling. Our technique can be reversed to
solve the mixing set problem by computing worst-case response times to
associated real-time scheduling task systems. Finally, we also apply our
optimization technique to solve 4-block integer programs with simple objective
functions.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Deppert_M/0/1/0/all/0/1">Max A. Deppert</a>, <a href="http://arxiv.org/find/cs/1/au:+Jansen_K/0/1/0/all/0/1">Klaus Jansen</a></p><p>We study a mutually enriching connection between response time analysis in
real-time systems and the mixing set problem. Thereby generalizing over known
results we present a new approach to the computation of response times in
fixed-priority uniprocessor real-time scheduling. We even allow that the tasks
are delayed by some period-constrained release jitter. By studying a dual
problem formulation of the decision problem as an integer linear program we
show that worst-case response times can be computed by algorithmically
exploiting a conditional reduction to an instance of the mixing set problem. In
the important case of harmonic periods our new technique admits a
near-quadratic algorithm to the exact computation of worst-case response times.
We show that generally, a smaller utilization leads to more efficient
algorithms even in fixed-priority scheduling. Our technique can be reversed to
solve the mixing set problem by computing worst-case response times to
associated real-time scheduling task systems. Finally, we also apply our
optimization technique to solve 4-block integer programs with simple objective
functions.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-06T00:30:00Z">Thursday, October 06 2022, 00:30</time>
        </div>
      </div>
    </article>
  
  </div>

  <script src='js/jquery-2.0.3.min.js'></script>
  <script src="js/jquery.timeago.js" type="text/javascript"></script>
  <script>
    jQuery(document).ready(function() {
      jQuery("time.timeago").timeago();
    });
  </script>
  <script src='js/blank.js'></script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>
