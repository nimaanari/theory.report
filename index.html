<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-0RQ5M78VX5"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-0RQ5M78VX5');
  </script>

  <meta charset='utf-8'>
  <meta name='generator' content='Pluto 1.6.2 on Ruby 3.0.6 (2023-03-30) [x86_64-linux]'>

  <title>Theory of Computing Report</title>

  <link rel="alternate" type="application/rss+xml" title="Posts (RSS)" href="rss20.xml" />
  <link rel="alternate" type="application/atom+xml" title="Posts (Atom)" href="atom.xml" />
  
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/solid.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/regular.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/fontawesome.min.css">
  <link rel='stylesheet' type='text/css' href='css/theory.css'>
</head>
<body>
  <details class="tr-panel" open>
    <summary>
      <span>Last Update</span>
      <div class="tr-small">
        
          <time class='timeago' datetime="2023-04-11T11:30:28Z">Tuesday, April 11 2023, 11:30</time>
        
      </div>
      <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
    </summary>
    <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

    <ul class='tr-subscriptions tr-small' >
    
      <li>
        <a href='http://arxiv.org/rss/cs.CC'><img src='icon/feed.png'></a>
        <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a>
      </li>
    
      <li>
        <a href='http://arxiv.org/rss/cs.CG'><img src='icon/feed.png'></a>
        <a href='https://arxiv.org/list/cs.CG/recent'>arXiv: Computational Geometry</a>
      </li>
    
      <li>
        <a href='http://arxiv.org/rss/cs.DS'><img src='icon/feed.png'></a>
        <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a>
      </li>
    
      <li>
        <a href='http://aaronsadventures.blogspot.com/feeds/posts/default'><img src='icon/feed.png'></a>
        <a href='http://aaronsadventures.blogspot.com/'>Aaron Roth</a>
      </li>
    
      <li>
        <a href='https://adamsheffer.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://adamsheffer.wordpress.com'>Adam Sheffer</a>
      </li>
    
      <li>
        <a href='https://adamdsmith.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://adamdsmith.wordpress.com'>Adam Smith</a>
      </li>
    
      <li>
        <a href='https://polylogblog.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://polylogblog.wordpress.com'>Andrew McGregor</a>
      </li>
    
      <li>
        <a href='https://corner.mimuw.edu.pl/?feed=rss2'><img src='icon/feed.png'></a>
        <a href='https://corner.mimuw.edu.pl'>Banach's Algorithmic Corner</a>
      </li>
    
      <li>
        <a href='http://www.argmin.net/feed.xml'><img src='icon/feed.png'></a>
        <a href='http://benjamin-recht.github.io/'>Ben Recht</a>
      </li>
    
      <li>
        <a href='http://bit-player.org/feed/atom/'><img src='icon/feed.png'></a>
        <a href='http://bit-player.org'>bit-player</a>
      </li>
    
      <li>
        <a href='https://cstheory-jobs.org/feed/'><img src='icon/feed.png'></a>
        <a href='https://cstheory-jobs.org'>CCI: jobs</a>
      </li>
    
      <li>
        <a href='https://cstheory-events.org/feed/'><img src='icon/feed.png'></a>
        <a href='https://cstheory-events.org'>CS Theory Events</a>
      </li>
    
      <li>
        <a href='http://blog.computationalcomplexity.org/feeds/posts/default'><img src='icon/feed.png'></a>
        <a href='http://blog.computationalcomplexity.org/'>Computational Complexity</a>
      </li>
    
      <li>
        <a href='https://11011110.github.io/blog/feed.xml'><img src='icon/feed.png'></a>
        <a href='https://11011110.github.io/blog/'>David Eppstein</a>
      </li>
    
      <li>
        <a href='https://daveagp.wordpress.com/category/toc/feed/'><img src='icon/feed.png'></a>
        <a href='https://daveagp.wordpress.com'>David Pritchard</a>
      </li>
    
      <li>
        <a href='https://decentdescent.org/feed.xml'><img src='icon/feed.png'></a>
        <a href='https://decentdescent.org/'>Decent Descent</a>
      </li>
    
      <li>
        <a href='https://decentralizedthoughts.github.io/feed'><img src='icon/feed.png'></a>
        <a href='https://decentralizedthoughts.github.io'>Decentralized Thoughts</a>
      </li>
    
      <li>
        <a href='https://differentialprivacy.org/feed.xml'><img src='icon/feed.png'></a>
        <a href='https://differentialprivacy.org'>DifferentialPrivacy.org</a>
      </li>
    
      <li>
        <a href='https://eccc.weizmann.ac.il//feeds/reports/'><img src='icon/feed.png'></a>
        <a href='https://eccc.weizmann.ac.il/'>ECCC Papers</a>
      </li>
    
      <li>
        <a href='https://emanueleviola.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://emanueleviola.wordpress.com'>Emanuele Viola</a>
      </li>
    
      <li>
        <a href='https://3dpancakes.typepad.com/ernie/atom.xml'><img src='icon/feed.png'></a>
        <a href='https://3dpancakes.typepad.com/ernie/'>Ernie's 3D Pancakes</a>
      </li>
    
      <li>
        <a href='https://dstheory.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://dstheory.wordpress.com'>Foundation of Data Science - Virtual Talk Series</a>
      </li>
    
      <li>
        <a href='https://francisbach.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://francisbach.com'>Francis Bach</a>
      </li>
    
      <li>
        <a href='https://gilkalai.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://gilkalai.wordpress.com'>Gil Kalai</a>
      </li>
    
      <li>
        <a href='https://blogs.oregonstate.edu:443/glencora/tag/tcs/feed/'><img src='icon/feed.png'></a>
        <a href='https://blogs.oregonstate.edu/glencora'>Glencora Borradaile</a>
      </li>
    
      <li>
        <a href='https://research.googleblog.com/feeds/posts/default/-/Algorithms'><img src='icon/feed.png'></a>
        <a href='https://research.googleblog.com/search/label/Algorithms'>Google Research Blog: Algorithms</a>
      </li>
    
      <li>
        <a href='https://gradientscience.org/feed.xml'><img src='icon/feed.png'></a>
        <a href='https://gradientscience.org/'>Gradient Science</a>
      </li>
    
      <li>
        <a href='http://grigory.us/blog/feed.xml'><img src='icon/feed.png'></a>
        <a href='http://grigory.github.io/blog'>Grigory Yaroslavtsev</a>
      </li>
    
      <li>
        <a href='https://minorfree.github.io/feed.xml'><img src='icon/feed.png'></a>
        <a href='https://minorfree.github.io'>Hung Le</a>
      </li>
    
      <li>
        <a href='https://tcsmath.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://tcsmath.wordpress.com'>James R. Lee</a>
      </li>
    
      <li>
        <a href='https://kamathematics.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://kamathematics.wordpress.com'>Kamathematics</a>
      </li>
    
      <li>
        <a href='http://processalgebra.blogspot.com/feeds/posts/default'><img src='icon/feed.png'></a>
        <a href='http://processalgebra.blogspot.com/'>Luca Aceto</a>
      </li>
    
      <li>
        <a href='https://lucatrevisan.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://lucatrevisan.wordpress.com'>Luca Trevisan</a>
      </li>
    
      <li>
        <a href='https://mittheory.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://mittheory.wordpress.com'>MIT CSAIL Student Blog</a>
      </li>
    
      <li>
        <a href='http://mybiasedcoin.blogspot.com/feeds/posts/default'><img src='icon/feed.png'></a>
        <a href='http://mybiasedcoin.blogspot.com/'>Michael Mitzenmacher</a>
      </li>
    
      <li>
        <a href='http://blog.mrtz.org/feed.xml'><img src='icon/feed.png'></a>
        <a href='http://blog.mrtz.org/'>Moritz Hardt</a>
      </li>
    
      <li>
        <a href='http://mysliceofpizza.blogspot.com/feeds/posts/default/-/aggregator'><img src='icon/feed.png'></a>
        <a href='http://mysliceofpizza.blogspot.com/search/label/aggregator'>Muthu Muthukrishnan</a>
      </li>
    
      <li>
        <a href='https://nisheethvishnoi.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://nisheethvishnoi.wordpress.com'>Nisheeth Vishnoi</a>
      </li>
    
      <li>
        <a href='http://www.solipsistslog.com/feed/'><img src='icon/feed.png'></a>
        <a href='http://www.solipsistslog.com'>Noah Stephens-Davidowitz</a>
      </li>
    
      <li>
        <a href='http://www.offconvex.org/feed.xml'><img src='icon/feed.png'></a>
        <a href='http://offconvex.github.io/'>Off the Convex Path</a>
      </li>
    
      <li>
        <a href='http://paulwgoldberg.blogspot.com/feeds/posts/default/-/aggregator'><img src='icon/feed.png'></a>
        <a href='http://paulwgoldberg.blogspot.com/search/label/aggregator'>Paul Goldberg</a>
      </li>
    
      <li>
        <a href='https://ptreview.sublinear.info/?feed=rss2'><img src='icon/feed.png'></a>
        <a href='https://ptreview.sublinear.info'>Property Testing Review</a>
      </li>
    
      <li>
        <a href='https://rjlipton.wpcomstaging.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://rjlipton.wpcomstaging.com'>Richard Lipton</a>
      </li>
    
      <li>
        <a href='https://blogs.princeton.edu/imabandit/feed/'><img src='icon/feed.png'></a>
        <a href='https://blogs.princeton.edu/imabandit'>Sébastien Bubeck</a>
      </li>
    
      <li>
        <a href='https://scottaaronson.blog/?feed=atom'><img src='icon/feed.png'></a>
        <a href='https://scottaaronson.blog'>Scott Aaronson</a>
      </li>
    
      <li>
        <a href='https://blog.simons.berkeley.edu/feed/'><img src='icon/feed.png'></a>
        <a href='https://blog.simons.berkeley.edu'>Simons Institute Blog</a>
      </li>
    
      <li>
        <a href='https://tcsplus.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://tcsplus.wordpress.com'>TCS+ Seminar Series</a>
      </li>
    
      <li>
        <a href='https://toc4fairness.org/feed/'><img src='icon/feed.png'></a>
        <a href='https://toc4fairness.org'>TOC for Fairness</a>
      </li>
    
      <li>
        <a href='http://www.blogger.com/feeds/6555947/posts/default?alt=atom'><img src='icon/feed.png'></a>
        <a href='http://blog.geomblog.org/'>The Geomblog</a>
      </li>
    
      <li>
        <a href='https://www.let-all.com/blog/feed/'><img src='icon/feed.png'></a>
        <a href='https://www.let-all.com/blog'>The Learning Theory Alliance Blog</a>
      </li>
    
      <li>
        <a href='https://theorydish.blog/feed/'><img src='icon/feed.png'></a>
        <a href='https://theorydish.blog'>Theory Dish: Stanford Blog</a>
      </li>
    
      <li>
        <a href='https://thmatters.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://thmatters.wordpress.com'>Theory Matters</a>
      </li>
    
      <li>
        <a href='https://mycqstate.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://mycqstate.wordpress.com'>Thomas Vidick</a>
      </li>
    
      <li>
        <a href='https://agtb.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://agtb.wordpress.com'>Turing's Invisible Hand</a>
      </li>
    
      <li>
        <a href='https://windowsontheory.org/feed/'><img src='icon/feed.png'></a>
        <a href='https://windowsontheory.org'>Windows on Theory</a>
      </li>
    
    </ul>

    <p class='tr-small'><a href="opml.xml">OPML feed</a> of all feeds.</p>
    <p class='tr-small'>Subscribe to the <a href="atom.xml">Atom feed</a>, <a href="rss20.xml">RSS feed</a>, or follow on <a href="https://twitter.com/cstheory">Twitter</a>, to stay up to date.</p>
    <p class='tr-small'>Source on <a href="https://github.com/nimaanari/theory.report">GitHub</a>.</p>
    <p class='tr-small'>Maintained by Nima Anari, Arnab Bhattacharyya, Gautam Kamath.</p>
    <p class='tr-small'>Powered by <a href='https://github.com/feedreader'>Pluto</a>.</p>
  </details>

  <div class="tr-opts">
    <i id='tr-show-headlines' class="fa-solid fa-fw fa-window-minimize tr-button" title='Show Headlines Only'></i>
    <i id='tr-show-snippets' class="fa-solid fa-fw fa-compress tr-button" title='Show Snippets'></i>
    <i id='tr-show-fulltext' class="fa-solid fa-fw fa-expand tr-button" title='Show Full Text'></i>
  </div>

  <h1>Theory of Computing Report</h1>

  <div class="tr-articles tr-shrink">
    
    
    <h2 class='tr-new-date'>
      <i class='fa-regular fa-calendar'></i> Tuesday, April 11
    </h2>
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.03960'>No-Existence Of Generalize Diffusion</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: David Ponarovsky</p><p>We show that there is no operator that given two state
$|\psi\rangle,|\phi\rangle$ compute the transformation:
$D|\psi\rangle|\phi\rangle = |\psi\rangle\bigl( \mathbb{I} - 2
|\psi\rangle\langle\psi| \bigr)|\phi\rangle$ The contradiction of the existence
follows by showing that using $D$ two players can compute the disjoints of
their sets in single round and $O\left( \sqrt{n} \right)$ communication
complexity, which shown by Braverman to be impossible \cite{Braverman}.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Ponarovsky_D/0/1/0/all/0/1">David Ponarovsky</a></p><p>We show that there is no operator that given two state
$|\psi\rangle,|\phi\rangle$ compute the transformation:
$D|\psi\rangle|\phi\rangle = |\psi\rangle\bigl( \mathbb{I} - 2
|\psi\rangle\langle\psi| \bigr)|\phi\rangle$ The contradiction of the existence
follows by showing that using $D$ two players can compute the disjoints of
their sets in single round and $O\left( \sqrt{n} \right)$ communication
complexity, which shown by Braverman to be impossible \cite{Braverman}.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-11T00:30:00Z">Tuesday, April 11 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.03965'>The $n$-vehicle exploration problem is NP-complete</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Jinchuan Cui, Xiaoya Li</p><p>The $n$-vehicle exploration problem (NVEP) is a combinatorial optimization
problem, which tries to find an optimal permutation of a fleet to maximize the
length traveled by the last vehicle. NVEP has a fractional form of objective
function, and its computational complexity of general case remains open. We
show that Hamiltonian Path $\leq_P$ NVEP, and prove that NVEP is NP-complete.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Cui_J/0/1/0/all/0/1">Jinchuan Cui</a>, <a href="http://arxiv.org/find/cs/1/au:+Li_X/0/1/0/all/0/1">Xiaoya Li</a></p><p>The $n$-vehicle exploration problem (NVEP) is a combinatorial optimization
problem, which tries to find an optimal permutation of a fleet to maximize the
length traveled by the last vehicle. NVEP has a fractional form of objective
function, and its computational complexity of general case remains open. We
show that Hamiltonian Path $\leq_P$ NVEP, and prove that NVEP is NP-complete.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-11T00:30:00Z">Tuesday, April 11 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.04095'>A Simple Proof of the Mixing of Metropolis-Adjusted Langevin Algorithm under Smoothness and Isoperimetry</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Yuansi Chen, Khashayar Gatmiry</p><p>We study the mixing time of Metropolis-Adjusted Langevin algorithm (MALA) for
sampling a target density on $\mathbb{R}^d$. We assume that the target density
satisfies $\psi_\mu$-isoperimetry and that the operator norm and trace of its
Hessian are bounded by $L$ and $\Upsilon$ respectively. Our main result
establishes that, from a warm start, to achieve $\epsilon$-total variation
distance to the target density, MALA mixes in
$O\left(\frac{(L\Upsilon)^{\frac12}}{\psi_\mu^2}
\log\left(\frac{1}{\epsilon}\right)\right)$ iterations. Notably, this result
holds beyond the log-concave sampling setting and the mixing time depends on
only $\Upsilon$ rather than its upper bound $L d$. In the $m$-strongly
logconcave and $L$-log-smooth sampling setting, our bound recovers the previous
minimax mixing bound of MALA~\cite{wu2021minimax}.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/stat/1/au:+Chen_Y/0/1/0/all/0/1">Yuansi Chen</a>, <a href="http://arxiv.org/find/stat/1/au:+Gatmiry_K/0/1/0/all/0/1">Khashayar Gatmiry</a></p><p>We study the mixing time of Metropolis-Adjusted Langevin algorithm (MALA) for
sampling a target density on $\mathbb{R}^d$. We assume that the target density
satisfies $\psi_\mu$-isoperimetry and that the operator norm and trace of its
Hessian are bounded by $L$ and $\Upsilon$ respectively. Our main result
establishes that, from a warm start, to achieve $\epsilon$-total variation
distance to the target density, MALA mixes in
$O\left(\frac{(L\Upsilon)^{\frac12}}{\psi_\mu^2}
\log\left(\frac{1}{\epsilon}\right)\right)$ iterations. Notably, this result
holds beyond the log-concave sampling setting and the mixing time depends on
only $\Upsilon$ rather than its upper bound $L d$. In the $m$-strongly
logconcave and $L$-log-smooth sampling setting, our bound recovers the previous
minimax mixing bound of MALA~\cite{wu2021minimax}.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-11T00:30:00Z">Tuesday, April 11 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.03828'>TDANetVis: Suggesting temporal resolutions for graph visualization using zigzag persistent homology</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CG/recent'>arXiv: Computational Geometry</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Rapha&#xeb;l Tinarrage, Jean R. Ponciano, Claudio D. G. Linhares, Agma J. M. Traina, Jorge Poco</p><p>Temporal graphs are commonly used to represent complex systems and track the
evolution of their constituents over time. Visualizing these graphs is crucial
as it allows one to quickly identify anomalies, trends, patterns, and other
properties leading to better decision-making. In this context, the
to-be-adopted temporal resolution is crucial in constructing and analyzing the
layout visually. The choice of a resolution is critical, e.g., when dealing
with temporally sparse graphs. In such cases, changing the temporal resolution
by grouping events (i.e., edges) from consecutive timestamps, a technique known
as timeslicing, can aid in the analysis and reveal patterns that might not be
discernible otherwise. However, choosing a suitable temporal resolution is not
trivial. In this paper, we propose TDANetVis, a methodology that suggests
temporal resolutions potentially relevant for analyzing a given graph, i.e.,
resolutions that lead to substantial topological changes in the graph
structure. To achieve this goal, TDANetVis leverages zigzag persistent
homology, a well-established technique from Topological Data Analysis (TDA). To
enhance visual graph analysis, TDANetVis also incorporates the colored barcode,
a novel timeline-based visualization built on the persistence barcodes commonly
used in TDA. We demonstrate the usefulness and effectiveness of TDANetVis
through a usage scenario and a user study involving 27 participants.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Tinarrage_R/0/1/0/all/0/1">Rapha&#xeb;l Tinarrage</a>, <a href="http://arxiv.org/find/cs/1/au:+Ponciano_J/0/1/0/all/0/1">Jean R. Ponciano</a>, <a href="http://arxiv.org/find/cs/1/au:+Linhares_C/0/1/0/all/0/1">Claudio D. G. Linhares</a>, <a href="http://arxiv.org/find/cs/1/au:+Traina_A/0/1/0/all/0/1">Agma J. M. Traina</a>, <a href="http://arxiv.org/find/cs/1/au:+Poco_J/0/1/0/all/0/1">Jorge Poco</a></p><p>Temporal graphs are commonly used to represent complex systems and track the
evolution of their constituents over time. Visualizing these graphs is crucial
as it allows one to quickly identify anomalies, trends, patterns, and other
properties leading to better decision-making. In this context, the
to-be-adopted temporal resolution is crucial in constructing and analyzing the
layout visually. The choice of a resolution is critical, e.g., when dealing
with temporally sparse graphs. In such cases, changing the temporal resolution
by grouping events (i.e., edges) from consecutive timestamps, a technique known
as timeslicing, can aid in the analysis and reveal patterns that might not be
discernible otherwise. However, choosing a suitable temporal resolution is not
trivial. In this paper, we propose TDANetVis, a methodology that suggests
temporal resolutions potentially relevant for analyzing a given graph, i.e.,
resolutions that lead to substantial topological changes in the graph
structure. To achieve this goal, TDANetVis leverages zigzag persistent
homology, a well-established technique from Topological Data Analysis (TDA). To
enhance visual graph analysis, TDANetVis also incorporates the colored barcode,
a novel timeline-based visualization built on the persistence barcodes commonly
used in TDA. We demonstrate the usefulness and effectiveness of TDANetVis
through a usage scenario and a user study involving 27 participants.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-11T00:30:00Z">Tuesday, April 11 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.03920'>Improved estimates on the number of unit perimeter triangles</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CG/recent'>arXiv: Computational Geometry</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Ritesh Goenka, Kenneth Moore, Ethan Patrick White</p><p>We obtain new upper and lower bounds on the number of unit perimeter
triangles spanned by points in the plane. We also establish improved bounds in
the special case where the point set is a section of the integer grid.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/math/1/au:+Goenka_R/0/1/0/all/0/1">Ritesh Goenka</a>, <a href="http://arxiv.org/find/math/1/au:+Moore_K/0/1/0/all/0/1">Kenneth Moore</a>, <a href="http://arxiv.org/find/math/1/au:+White_E/0/1/0/all/0/1">Ethan Patrick White</a></p><p>We obtain new upper and lower bounds on the number of unit perimeter
triangles spanned by points in the plane. We also establish improved bounds in
the special case where the point set is a section of the integer grid.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-11T00:30:00Z">Tuesday, April 11 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.04079'>Convex Hulls: Surface Mapping onto a Sphere</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CG/recent'>arXiv: Computational Geometry</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Ben Kenwright</p><p>Writing an uncomplicated, robust, and scalable three-dimensional convex hull
algorithm is challenging and problematic. This includes, coplanar and collinear
issues, numerical accuracy, performance, and complexity trade-offs. While there
are a number of methods available for finding the convex hull based on
geometric calculations, such as, the distance between points, but do not
address the technical challenges when implementing a usable solution (e.g.,
numerical issues and degenerate cloud points). We explain some common algorithm
pitfalls and engineering modifications to overcome and solve these limitations.
We present a novel iterative method using support mapping and surface
projection to create an uncomplicated and robust 2d and 3d convex hull
algorithm.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Kenwright_B/0/1/0/all/0/1">Ben Kenwright</a></p><p>Writing an uncomplicated, robust, and scalable three-dimensional convex hull
algorithm is challenging and problematic. This includes, coplanar and collinear
issues, numerical accuracy, performance, and complexity trade-offs. While there
are a number of methods available for finding the convex hull based on
geometric calculations, such as, the distance between points, but do not
address the technical challenges when implementing a usable solution (e.g.,
numerical issues and degenerate cloud points). We explain some common algorithm
pitfalls and engineering modifications to overcome and solve these limitations.
We present a novel iterative method using support mapping and surface
projection to create an uncomplicated and robust 2d and 3d convex hull
algorithm.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-11T00:30:00Z">Tuesday, April 11 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.03810'>On Testability of First-Order Properties in Bounded-Degree Graphs and Connections to Proximity-Oblivious Testing</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Isolde Adler, Noleen K&#xf6;hler, Pan Peng</p><p>We study property testing of properties that are definable in first-order
logic (FO) in the bounded-degree graph and relational structure models. We show
that any FO property that is defined by a formula with quantifier prefix
$\exists^*\forall^*$ is testable (i.e., testable with constant query
complexity), while there exists an FO property that is expressible by a formula
with quantifier prefix $\forall^*\exists^*$ that is not testable. In the dense
graph model, a similar picture is long known (Alon, Fischer, Krivelevich,
Szegedy, Combinatorica 2000), despite the very different nature of the two
models. In particular, we obtain our lower bound by an FO formula that defines
a class of bounded-degree expanders, based on zig-zag products of graphs. We
expect this to be of independent interest.
</p>
<p>We then use our class of FO definable bounded-degree expanders to answer a
long-standing open problem for proximity-oblivious testers (POTs). POTs are a
class of particularly simple testing algorithms, where a basic test is
performed a number of times that may depend on the proximity parameter, but the
basic test itself is independent of the proximity parameter. In their seminal
work, Goldreich and Ron [STOC 2009; SICOMP 2011] show that the graph properties
that are constant-query proximity-oblivious testable in the bounded-degree
model are precisely the properties that can be expressed as a generalised
subgraph freeness (GSF) property that satisfies the non-propagation condition.
It is left open whether the non-propagation condition is necessary. We give a
negative answer by showing that our property is a GSF property which is
propagating. Hence in particular, our property does not admit a POT. For this
result we establish a new connection between FO properties and GSF-local
properties via neighbourhood profiles.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Adler_I/0/1/0/all/0/1">Isolde Adler</a>, <a href="http://arxiv.org/find/cs/1/au:+Kohler_N/0/1/0/all/0/1">Noleen K&#xf6;hler</a>, <a href="http://arxiv.org/find/cs/1/au:+Peng_P/0/1/0/all/0/1">Pan Peng</a></p><p>We study property testing of properties that are definable in first-order
logic (FO) in the bounded-degree graph and relational structure models. We show
that any FO property that is defined by a formula with quantifier prefix
$\exists^*\forall^*$ is testable (i.e., testable with constant query
complexity), while there exists an FO property that is expressible by a formula
with quantifier prefix $\forall^*\exists^*$ that is not testable. In the dense
graph model, a similar picture is long known (Alon, Fischer, Krivelevich,
Szegedy, Combinatorica 2000), despite the very different nature of the two
models. In particular, we obtain our lower bound by an FO formula that defines
a class of bounded-degree expanders, based on zig-zag products of graphs. We
expect this to be of independent interest.
</p>
<p>We then use our class of FO definable bounded-degree expanders to answer a
long-standing open problem for proximity-oblivious testers (POTs). POTs are a
class of particularly simple testing algorithms, where a basic test is
performed a number of times that may depend on the proximity parameter, but the
basic test itself is independent of the proximity parameter. In their seminal
work, Goldreich and Ron [STOC 2009; SICOMP 2011] show that the graph properties
that are constant-query proximity-oblivious testable in the bounded-degree
model are precisely the properties that can be expressed as a generalised
subgraph freeness (GSF) property that satisfies the non-propagation condition.
It is left open whether the non-propagation condition is necessary. We give a
negative answer by showing that our property is a GSF property which is
propagating. Hence in particular, our property does not admit a POT. For this
result we establish a new connection between FO properties and GSF-local
properties via neighbourhood profiles.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-11T00:30:00Z">Tuesday, April 11 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.03838'>Improving Identity-Robustness for Face Models</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Qi Qi, Shervin Ardeshir</p><p>Despite the success of deep-learning models in many tasks, there have been
concerns about such models learning shortcuts, and their lack of robustness to
irrelevant confounders. When it comes to models directly trained on human
faces, a sensitive confounder is that of human identities. Many face-related
tasks should ideally be identity-independent, and perform uniformly across
different individuals (i.e. be fair). One way to measure and enforce such
robustness and performance uniformity is through enforcing it during training,
assuming identity-related information is available at scale. However, due to
privacy concerns and also the cost of collecting such information, this is
often not the case, and most face datasets simply contain input images and
their corresponding task-related labels. Thus, improving identity-related
robustness without the need for such annotations is of great importance. Here,
we explore using face-recognition embedding vectors, as proxies for identities,
to enforce such robustness. We propose to use the structure in the
face-recognition embedding space, to implicitly emphasize rare samples within
each class. We do so by weighting samples according to their conditional
inverse density (CID) in the proxy embedding space. Our experiments suggest
that such a simple sample weighting scheme, not only improves the training
robustness, it often improves the overall performance as a result of such
robustness. We also show that employing such constraints during training
results in models that are significantly less sensitive to different levels of
bias in the dataset.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Qi_Q/0/1/0/all/0/1">Qi Qi</a>, <a href="http://arxiv.org/find/cs/1/au:+Ardeshir_S/0/1/0/all/0/1">Shervin Ardeshir</a></p><p>Despite the success of deep-learning models in many tasks, there have been
concerns about such models learning shortcuts, and their lack of robustness to
irrelevant confounders. When it comes to models directly trained on human
faces, a sensitive confounder is that of human identities. Many face-related
tasks should ideally be identity-independent, and perform uniformly across
different individuals (i.e. be fair). One way to measure and enforce such
robustness and performance uniformity is through enforcing it during training,
assuming identity-related information is available at scale. However, due to
privacy concerns and also the cost of collecting such information, this is
often not the case, and most face datasets simply contain input images and
their corresponding task-related labels. Thus, improving identity-related
robustness without the need for such annotations is of great importance. Here,
we explore using face-recognition embedding vectors, as proxies for identities,
to enforce such robustness. We propose to use the structure in the
face-recognition embedding space, to implicitly emphasize rare samples within
each class. We do so by weighting samples according to their conditional
inverse density (CID) in the proxy embedding space. Our experiments suggest
that such a simple sample weighting scheme, not only improves the training
robustness, it often improves the overall performance as a result of such
robustness. We also show that employing such constraints during training
results in models that are significantly less sensitive to different levels of
bias in the dataset.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-11T00:30:00Z">Tuesday, April 11 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.03985'>On Rotation Distance of Rank Bounded Trees</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Anoop S. K. M., Jayalal Sarma</p><p>Computing the rotation distance between two binary trees with $n$ internal
nodes efficiently (in $poly(n)$ time) is a long standing open question in the
study of height balancing in tree data structures. In this paper, we initiate
the study of this problem bounding the rank of the trees given at the input
(defined by Ehrenfeucht and Haussler (1989) in the context of decision trees).
We define the rank-bounded rotation distance between two given binary trees
$T_1$ and $T_2$ (with $n$ internal nodes) of rank at most $r$, denoted by
$d_r(T_1,T_2)$, as the length of the shortest sequence of rotations that
transforms $T_1$ to $T_2$ with the restriction that the intermediate trees must
be of rank at most $r$. We show that the rotation distance problem reduces in
polynomial time to the rank bounded rotation distance problem. This motivates
the study of the problem in the combinatorial and algorithmic frontiers.
Observing that trees with rank $1$ coincide exactly with skew trees (binary
trees where every internal node has at least one leaf as a child), we show the
following results in this frontier :
</p>
<p>We present an $O(n^2)$ time algorithm for computing $d_1(T_1,T_2)$. That is,
when the given trees are skew trees (we call this variant as skew rotation
distance problem) - where the intermediate trees are restricted to be skew as
well. In particular, our techniques imply that for any two skew trees
$d(T_1,T_2) \le n^2$.
</p>
<p>We show the following upper bound : for any two trees $T_1$ and $T_2$ of rank
at most $r_1$ and $r_2$ respectively, we have that: $d_r(T_1,T_2) \le n^2
(1+(2n+1)(r_1+r_2-2))$ where $r = max\{r_1,r_2\}$. This bound is asymptotically
tight for $r=1$.
</p>
<p>En route our proof of the above theorems, we associate binary trees to
permutations and bivariate polynomials, and prove several characterizations in
the case of skew trees.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+M%2E_A/0/1/0/all/0/1">Anoop S. K. M.</a>, <a href="http://arxiv.org/find/cs/1/au:+Sarma_J/0/1/0/all/0/1">Jayalal Sarma</a></p><p>Computing the rotation distance between two binary trees with $n$ internal
nodes efficiently (in $poly(n)$ time) is a long standing open question in the
study of height balancing in tree data structures. In this paper, we initiate
the study of this problem bounding the rank of the trees given at the input
(defined by Ehrenfeucht and Haussler (1989) in the context of decision trees).
We define the rank-bounded rotation distance between two given binary trees
$T_1$ and $T_2$ (with $n$ internal nodes) of rank at most $r$, denoted by
$d_r(T_1,T_2)$, as the length of the shortest sequence of rotations that
transforms $T_1$ to $T_2$ with the restriction that the intermediate trees must
be of rank at most $r$. We show that the rotation distance problem reduces in
polynomial time to the rank bounded rotation distance problem. This motivates
the study of the problem in the combinatorial and algorithmic frontiers.
Observing that trees with rank $1$ coincide exactly with skew trees (binary
trees where every internal node has at least one leaf as a child), we show the
following results in this frontier :
</p>
<p>We present an $O(n^2)$ time algorithm for computing $d_1(T_1,T_2)$. That is,
when the given trees are skew trees (we call this variant as skew rotation
distance problem) - where the intermediate trees are restricted to be skew as
well. In particular, our techniques imply that for any two skew trees
$d(T_1,T_2) \le n^2$.
</p>
<p>We show the following upper bound : for any two trees $T_1$ and $T_2$ of rank
at most $r_1$ and $r_2$ respectively, we have that: $d_r(T_1,T_2) \le n^2
(1+(2n+1)(r_1+r_2-2))$ where $r = max\{r_1,r_2\}$. This bound is asymptotically
tight for $r=1$.
</p>
<p>En route our proof of the above theorems, we associate binary trees to
permutations and bivariate polynomials, and prove several characterizations in
the case of skew trees.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-11T00:30:00Z">Tuesday, April 11 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.04024'>Prophet Inequalities: Separating Random Order from Order Selection</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Giordano Giambartolomei, Frederik Mallmann-Trenn, Raimundo Saona</p><p>Prophet inequalities are a central object of study in optimal stopping
theory. A gambler is sent values online, sampled from an instance of
independent distributions, in an adversarial, random or selected order,
depending on the model. When observing each value, the gambler either accepts
it as a reward or irrevocably rejects it and proceeds to observe the next
value. The goal of the gambler, who cannot see the future, is maximising the
expected value of the reward while competing against the expectation of a
prophet (the offline maximum). In other words, one seeks to maximise the
gambler-to-prophet ratio of the expectations.
</p>
<p>The model, in which the gambler selects the arrival order first, and then
observes the values, is known as Order Selection. Recently it has been shown
that in this model a ratio of $0.7251$ can be attained for any instance. If the
gambler chooses the arrival order (uniformly) at random, we obtain the Random
Order model. The worst case ratio over all possible instances has been
extensively studied for at least $40$ years. Still, it is not known if
carefully choosing the order, or simply taking it at random, benefits the
gambler. We prove that, in the Random Order model, no algorithm can achieve a
ratio larger than $0.7235$, thus showing for the first time that there is a
real benefit in choosing the order.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Giambartolomei_G/0/1/0/all/0/1">Giordano Giambartolomei</a>, <a href="http://arxiv.org/find/cs/1/au:+Mallmann_Trenn_F/0/1/0/all/0/1">Frederik Mallmann-Trenn</a>, <a href="http://arxiv.org/find/cs/1/au:+Saona_R/0/1/0/all/0/1">Raimundo Saona</a></p><p>Prophet inequalities are a central object of study in optimal stopping
theory. A gambler is sent values online, sampled from an instance of
independent distributions, in an adversarial, random or selected order,
depending on the model. When observing each value, the gambler either accepts
it as a reward or irrevocably rejects it and proceeds to observe the next
value. The goal of the gambler, who cannot see the future, is maximising the
expected value of the reward while competing against the expectation of a
prophet (the offline maximum). In other words, one seeks to maximise the
gambler-to-prophet ratio of the expectations.
</p>
<p>The model, in which the gambler selects the arrival order first, and then
observes the values, is known as Order Selection. Recently it has been shown
that in this model a ratio of $0.7251$ can be attained for any instance. If the
gambler chooses the arrival order (uniformly) at random, we obtain the Random
Order model. The worst case ratio over all possible instances has been
extensively studied for at least $40$ years. Still, it is not known if
carefully choosing the order, or simply taking it at random, benefits the
gambler. We prove that, in the Random Order model, no algorithm can achieve a
ratio larger than $0.7235$, thus showing for the first time that there is a
real benefit in choosing the order.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-11T00:30:00Z">Tuesday, April 11 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.04196'>A simple and efficient preprocessing step for convex hull problem</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Mohammad Heydari, Ashkan Khalifeh</p><p>The present paper is concerned with a recursive algorithm as a preprocessing
step to find the convex hull of $n$ random points uniformly distributed in the
plane. For such a set of points, it is shown that eliminating all but $O(\log
n)$ of points can derive the same convex hull as the input set. Finally it will
be shown that the running time of the algorithm is $O(n)
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Heydari_M/0/1/0/all/0/1">Mohammad Heydari</a>, <a href="http://arxiv.org/find/cs/1/au:+Khalifeh_A/0/1/0/all/0/1">Ashkan Khalifeh</a></p><p>The present paper is concerned with a recursive algorithm as a preprocessing
step to find the convex hull of $n$ random points uniformly distributed in the
plane. For such a set of points, it is shown that eliminating all but $O(\log
n)$ of points can derive the same convex hull as the input set. Finally it will
be shown that the running time of the algorithm is $O(n)
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-11T00:30:00Z">Tuesday, April 11 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.04318'>On Extend-Only Directed Posets and Derived Byzantine-Tolerant Replicated Data Types (Extended Version)</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Florian Jacob, Hannes Hartenstein</p><p>We uncover the extend-only directed posets (EDP) structure as a unification
of recently discussed DAG-based Byzantine-tolerant conflict-free replicated
data types (CRDT). We also show how a key-value map model can be derived from
the EDP formulation, and give an outlook on an EDP-based systemic access
control CRDT as a formalization of the CRDT used in the Matrix messaging
system.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Jacob_F/0/1/0/all/0/1">Florian Jacob</a>, <a href="http://arxiv.org/find/cs/1/au:+Hartenstein_H/0/1/0/all/0/1">Hannes Hartenstein</a></p><p>We uncover the extend-only directed posets (EDP) structure as a unification
of recently discussed DAG-based Byzantine-tolerant conflict-free replicated
data types (CRDT). We also show how a key-value map model can be derived from
the EDP formulation, and give an outlook on an EDP-based systemic access
control CRDT as a formalization of the CRDT used in the Matrix messaging
system.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-11T00:30:00Z">Tuesday, April 11 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.04397'>Randomized and Deterministic Attention Sparsification Algorithms for Over-parameterized Feature Dimension</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Yichuan Deng, Sridhar Mahadevan, Zhao Song</p><p>Large language models (LLMs) have shown their power in different areas.
Attention computation, as an important subroutine of LLMs, has also attracted
interests in theory. Recently the static computation and dynamic maintenance of
attention matrix has been studied by [Alman and Song 2023] and [Brand, Song and
Zhou 2023] from both algorithmic perspective and hardness perspective. In this
work, we consider the sparsification of the attention problem. We make one
simplification which is the logit matrix is symmetric. Let $n$ denote the
length of sentence, let $d$ denote the embedding dimension. Given a matrix $X
\in \mathbb{R}^{n \times d}$, suppose $d \gg n$ and $\| X X^\top \|_{\infty} &lt;
r$ with $r \in (0,0.1)$, then we aim for finding $Y \in \mathbb{R}^{n \times
m}$ (where $m\ll d$) such that \begin{align*} \| D(Y)^{-1} \exp( Y Y^\top ) -
D(X)^{-1} \exp( X X^\top) \|_{\infty} \leq O(r) \end{align*} We provide two
results for this problem.
</p>
<p>$\bullet$ Our first result is a randomized algorithm. It runs in
$\widetilde{O}(\mathrm{nnz}(X) + n^{\omega} ) $ time, has $1-\delta$ succeed
probability, and chooses $m = O(n \log(n/\delta))$. Here $\mathrm{nnz}(X)$
denotes the number of non-zero entries in $X$. We use $\omega$ to denote the
exponent of matrix multiplication. Currently $\omega \approx 2.373$.
</p>
<p>$\bullet$ Our second result is a deterministic algorithm. It runs in
$\widetilde{O}(\min\{\sum_{i\in[d]}\mathrm{nnz}(X_i)^2, dn^{\omega-1}\} +
n^{\omega+1})$ time and chooses $m = O(n)$. Here $X_i$ denote the $i$-th column
of matrix $X$.
</p>
<p>Our main findings have the following implication for applied LLMs task: for
any super large feature dimension, we can reduce it down to the size nearly
linear in length of sentence.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Deng_Y/0/1/0/all/0/1">Yichuan Deng</a>, <a href="http://arxiv.org/find/cs/1/au:+Mahadevan_S/0/1/0/all/0/1">Sridhar Mahadevan</a>, <a href="http://arxiv.org/find/cs/1/au:+Song_Z/0/1/0/all/0/1">Zhao Song</a></p><p>Large language models (LLMs) have shown their power in different areas.
Attention computation, as an important subroutine of LLMs, has also attracted
interests in theory. Recently the static computation and dynamic maintenance of
attention matrix has been studied by [Alman and Song 2023] and [Brand, Song and
Zhou 2023] from both algorithmic perspective and hardness perspective. In this
work, we consider the sparsification of the attention problem. We make one
simplification which is the logit matrix is symmetric. Let $n$ denote the
length of sentence, let $d$ denote the embedding dimension. Given a matrix $X
\in \mathbb{R}^{n \times d}$, suppose $d \gg n$ and $\| X X^\top \|_{\infty} &lt;
r$ with $r \in (0,0.1)$, then we aim for finding $Y \in \mathbb{R}^{n \times
m}$ (where $m\ll d$) such that \begin{align*} \| D(Y)^{-1} \exp( Y Y^\top ) -
D(X)^{-1} \exp( X X^\top) \|_{\infty} \leq O(r) \end{align*} We provide two
results for this problem.
</p>
<p>$\bullet$ Our first result is a randomized algorithm. It runs in
$\widetilde{O}(\mathrm{nnz}(X) + n^{\omega} ) $ time, has $1-\delta$ succeed
probability, and chooses $m = O(n \log(n/\delta))$. Here $\mathrm{nnz}(X)$
denotes the number of non-zero entries in $X$. We use $\omega$ to denote the
exponent of matrix multiplication. Currently $\omega \approx 2.373$.
</p>
<p>$\bullet$ Our second result is a deterministic algorithm. It runs in
$\widetilde{O}(\min\{\sum_{i\in[d]}\mathrm{nnz}(X_i)^2, dn^{\omega-1}\} +
n^{\omega+1})$ time and chooses $m = O(n)$. Here $X_i$ denote the $i$-th column
of matrix $X$.
</p>
<p>Our main findings have the following implication for applied LLMs task: for
any super large feature dimension, we can reduce it down to the size nearly
linear in length of sentence.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-11T00:30:00Z">Tuesday, April 11 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    
    <h2 class='tr-new-date'>
      <i class='fa-regular fa-calendar'></i> Monday, April 10
    </h2>
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='https://blog.computationalcomplexity.org/2023/04/complexity-and-generative-ai.html'>Complexity and Explainable AI</a></h3>
        <p class='tr-article-feed'>from <a href='http://blog.computationalcomplexity.org/'>Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>About six years ago, I posted&nbsp;on why it was important to understand machine learning, mentioning trust, fairness, security and causality. But I then I brought in complexity.</p><p></p><blockquote>What if P = NP? Would that help. Actually it would makes things worse. If you had a quick algorithm for NP-complete problems, you could use it to find the smallest possible circuit for say matching or traveling salesman but you would have no clue why that circuit works.&nbsp;</blockquote><p>Ryan Williams countered</p><p></p><blockquote>If P=NP you could also find the shortest proof in your favorite formal system that the smallest possible circuit does what you wanted it to do, as well as any other claim you are wondering that may be true about the circuit. That proof might not be comprehensible to you, but it could be written in a format where proof assistant software such as HOL or Coq could parse it and convince you it is correct. So if P=NP (with feasible low constants) I think that would definitely help.</blockquote><p>So if P = NP maybe you couldn't understand how the circuit works but any question about how it works you could answer.&nbsp;</p><p>While we don't live in a world where P = NP, we are in a world where we can produce very strong learning algorithms where we can't understand the programs they produce. They are now powerful enough to apply Ryan's idea and use the algorithms themselves to understand the decisions they make.</p><p>For example I tried using Google Translate on a Hungarian obituary of Vera&nbsp;Sós. Hungarian does not use gendered pronouns and and the translation incorrectly produced male pronouns. I then fed the translation into ChatGPT which translated with the correct female pronouns.&nbsp;</p><p>You can speculate why Google Translate uses male pronouns but you can't ask it why. But you can ask ChatGPT.</p><p></p><blockquote>I used female pronouns in the translation because Vera T. Sós is a female name. Vera is a feminine given name, and since the context of the original text is about her life and accomplishments, it is appropriate to use female pronouns in the English translation to maintain clarity and accurately convey information about her.</blockquote><p>So perhaps if you want to understand how ML works, perhaps we should seek stronger algorithms, not weaker ones, algorithms that can explain themselves. As they say, a dull knife is more dangerous than a sharp one.</p><p></p><p></p><p></p><p></p><p>By Lance Fortnow</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p>About six years ago, I <a href="https://blog.computationalcomplexity.org/2017/04/understanding-machine-learning.html">posted</a>&nbsp;on why it was important to understand machine learning, mentioning trust, fairness, security and causality. But I then I brought in complexity.</p><p></p><blockquote>What if P = NP? Would that help. Actually it would makes things worse. If you had a quick algorithm for NP-complete problems, you could use it to find the smallest possible circuit for say matching or traveling salesman but you would have no clue why that circuit works.&nbsp;</blockquote><p>Ryan Williams <a href="https://blog.computationalcomplexity.org/2017/04/understanding-machine-learning.html?showComment=1492464695392#c7595821335622802218">countered</a></p><p></p><blockquote>If P=NP you could also find the shortest proof in your favorite formal system that the smallest possible circuit does what you wanted it to do, as well as any other claim you are wondering that may be true about the circuit. That proof might not be comprehensible to you, but it could be written in a format where proof assistant software such as HOL or Coq could parse it and convince you it is correct. So if P=NP (with feasible low constants) I think that would definitely help.</blockquote><p>So if P = NP maybe you couldn't understand how the circuit works but any question about how it works you could answer.&nbsp;</p><p>While we don't live in a world where P = NP, we are in a world where we can produce very strong learning algorithms where we can't understand the programs they produce. They are now powerful enough to apply Ryan's idea and use the algorithms themselves to understand the decisions they make.</p><p>For example I tried using Google Translate on a <a href="https://mta.hu/mta_hirei/elhunyt-t-sos-vera-matematikus-az-mta-rendes-tagja-112809">Hungarian obituary</a> of Vera&nbsp;Sós. Hungarian does not use gendered pronouns and and the translation incorrectly produced male pronouns. I then fed the translation into ChatGPT which translated with the correct female pronouns.&nbsp;</p><p>You can speculate why Google Translate uses male pronouns but you can't ask it why. But you can ask ChatGPT.</p><p></p><blockquote>I used female pronouns in the translation because Vera T. Sós is a female name. Vera is a feminine given name, and since the context of the original text is about her life and accomplishments, it is appropriate to use female pronouns in the English translation to maintain clarity and accurately convey information about her.</blockquote><p>So perhaps if you want to understand how ML works, perhaps we should seek stronger algorithms, not weaker ones, algorithms that can explain themselves. As <a href="https://knivesengraved.com/blogs/news/why-sharp-knives-are-safer-than-dull-knives">they say</a>, a dull knife is more dangerous than a sharp one.</p><p></p><p></p><p></p><p></p><p class="authors">By Lance Fortnow</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-10T17:37:00Z">Monday, April 10 2023, 17:37</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.03448'>Quantum delegation with an off-the-shelf device</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Anne Broadbent, Arthur Mehta, Yuming Zhao</p><p>Given that reliable cloud quantum computers are becoming closer to reality,
the concept of delegation of quantum computations and its verifiability is of
central interest. Many models have been proposed, each with specific strengths
and weaknesses. Here, we put forth a new model where the client trusts only its
classical processing, makes no computational assumptions, and interacts with a
quantum server in a single round. In addition, during a set-up phase, the
client specifies the size $n$ of the computation and receives an untrusted,
off-the-shelf (OTS) quantum device that is used to report the outcome of a
single constant-sized measurement from a predetermined logarithmic-sized input.
In the OTS model, we thus picture that a single quantum server does the bulk of
the computations, while the OTS device is used as an untrusted and generic
verification device, all in a single round.
</p>
<p>We show how to delegate polynomial-time quantum computations in the OTS
model. Scaling up the technique also yields an interactive proof system for all
of QMA, which, furthermore, we show can be accomplished in statistical
zero-knowledge. This yields the first relativistic (one-round), two-prover
zero-knowledge proof system for QMA.
</p>
<p>As a proof approach, we provide a new self-test for $n$-EPR pairs using only
constant-sized Pauli measurements, and show how it provides a new avenue for
the use of simulatable codes for local Hamiltonian verification. Along the way,
we also provide an enhanced version of a well-known stability result due to
Gowers and Hatami and show how it completes a common argument used in
self-testing.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/quant-ph/1/au:+Broadbent_A/0/1/0/all/0/1">Anne Broadbent</a>, <a href="http://arxiv.org/find/quant-ph/1/au:+Mehta_A/0/1/0/all/0/1">Arthur Mehta</a>, <a href="http://arxiv.org/find/quant-ph/1/au:+Zhao_Y/0/1/0/all/0/1">Yuming Zhao</a></p><p>Given that reliable cloud quantum computers are becoming closer to reality,
the concept of delegation of quantum computations and its verifiability is of
central interest. Many models have been proposed, each with specific strengths
and weaknesses. Here, we put forth a new model where the client trusts only its
classical processing, makes no computational assumptions, and interacts with a
quantum server in a single round. In addition, during a set-up phase, the
client specifies the size $n$ of the computation and receives an untrusted,
off-the-shelf (OTS) quantum device that is used to report the outcome of a
single constant-sized measurement from a predetermined logarithmic-sized input.
In the OTS model, we thus picture that a single quantum server does the bulk of
the computations, while the OTS device is used as an untrusted and generic
verification device, all in a single round.
</p>
<p>We show how to delegate polynomial-time quantum computations in the OTS
model. Scaling up the technique also yields an interactive proof system for all
of QMA, which, furthermore, we show can be accomplished in statistical
zero-knowledge. This yields the first relativistic (one-round), two-prover
zero-knowledge proof system for QMA.
</p>
<p>As a proof approach, we provide a new self-test for $n$-EPR pairs using only
constant-sized Pauli measurements, and show how it provides a new avenue for
the use of simulatable codes for local Hamiltonian verification. Along the way,
we also provide an enhanced version of a well-known stability result due to
Gowers and Hatami and show how it completes a common argument used in
self-testing.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-10T00:30:00Z">Monday, April 10 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.03484'>Maximal Distortion of Geodesic Diameters in Polygonal Domains</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CG/recent'>arXiv: Computational Geometry</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Adrian Dumitrescu, Csaba D. T&#xf3;th</p><p>For a polygon $P$ with holes in the plane, we denote by $\varrho(P)$ the
ratio between the geodesic and the Euclidean diameters of $P$. It is shown that
over all convex polygons with $h$~convex holes, the supremum of $\varrho(P)$ is
between $\Omega(h^{1/3})$ and $O(h^{1/2})$. The upper bound improves to
$O(1+\min\{h^{3/4}\Delta,h^{1/2}\Delta^{1/2}\})$ if every hole has diameter at
most $\Delta\cdot {\rm diam}_2(P)$; and to $O(1)$ if every hole is a \emph{fat}
convex polygon. Furthermore, we show that the function $g(h)=\sup_P \varrho(P)$
over convex polygons with $h$ convex holes has the same growth rate as an
analogous quantity over geometric triangulations with $h$ vertices when
$h\rightarrow \infty$.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Dumitrescu_A/0/1/0/all/0/1">Adrian Dumitrescu</a>, <a href="http://arxiv.org/find/cs/1/au:+Toth_C/0/1/0/all/0/1">Csaba D. T&#xf3;th</a></p><p>For a polygon $P$ with holes in the plane, we denote by $\varrho(P)$ the
ratio between the geodesic and the Euclidean diameters of $P$. It is shown that
over all convex polygons with $h$~convex holes, the supremum of $\varrho(P)$ is
between $\Omega(h^{1/3})$ and $O(h^{1/2})$. The upper bound improves to
$O(1+\min\{h^{3/4}\Delta,h^{1/2}\Delta^{1/2}\})$ if every hole has diameter at
most $\Delta\cdot {\rm diam}_2(P)$; and to $O(1)$ if every hole is a \emph{fat}
convex polygon. Furthermore, we show that the function $g(h)=\sup_P \varrho(P)$
over convex polygons with $h$ convex holes has the same growth rate as an
analogous quantity over geometric triangulations with $h$ vertices when
$h\rightarrow \infty$.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-10T00:30:00Z">Monday, April 10 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.03377'>Leveraging Reusability: Improved Competitive Ratio of Greedy for Reusable Resources</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Jackie Baek, Shixin Wang</p><p>We study online weighted bipartite matching of reusable resources where an
adversarial sequence of requests for resources arrive over time. A resource
that is matched is 'used' for a random duration, drawn independently from a
resource-dependent distribution, after which it returns and is able to be
matched again. We study the performance of the greedy policy, which matches
requests to the resource that yields the highest reward. Previously, it was
known that the greedy policy is 1/2 competitive against a clairvoyant benchmark
that knows the request sequence in advance. In this work, we improve this
result by introducing a parameter that quantifies the degree of reusability of
the resources. Specifically, if p represents the smallest probability over the
usage distributions that a matched resource returns in one time step, the
greedy policy achieves a competitive ratio of $1/(2-p)$. Furthermore, when the
usage distributions are geometric, we establish a stronger competitive ratio of
$(1+p)/2$, which we demonstrate to be tight. Both of these results align with
the known results in the two extreme scenarios: p = 0 corresponds to
non-reusable resources, where 1/2 is known to be tight, while p = 1 corresponds
to every resource returning immediately, where greedy is the optimal policy and
hence the competitive ratio is 1. Finally, we show that both results are robust
to approximations of the greedy policy. Our work demonstrates that the
reusability of resources can enhance performance compared to the non-reusable
setting, and that a simple greedy policy suffices when the degree of
reusability is high. Our insights contribute to the understanding of how
resource reusability can influence the performance of online algorithms, and
highlight the potential for improved performance as the degree of reusability
increases.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Baek_J/0/1/0/all/0/1">Jackie Baek</a>, <a href="http://arxiv.org/find/cs/1/au:+Wang_S/0/1/0/all/0/1">Shixin Wang</a></p><p>We study online weighted bipartite matching of reusable resources where an
adversarial sequence of requests for resources arrive over time. A resource
that is matched is 'used' for a random duration, drawn independently from a
resource-dependent distribution, after which it returns and is able to be
matched again. We study the performance of the greedy policy, which matches
requests to the resource that yields the highest reward. Previously, it was
known that the greedy policy is 1/2 competitive against a clairvoyant benchmark
that knows the request sequence in advance. In this work, we improve this
result by introducing a parameter that quantifies the degree of reusability of
the resources. Specifically, if p represents the smallest probability over the
usage distributions that a matched resource returns in one time step, the
greedy policy achieves a competitive ratio of $1/(2-p)$. Furthermore, when the
usage distributions are geometric, we establish a stronger competitive ratio of
$(1+p)/2$, which we demonstrate to be tight. Both of these results align with
the known results in the two extreme scenarios: p = 0 corresponds to
non-reusable resources, where 1/2 is known to be tight, while p = 1 corresponds
to every resource returning immediately, where greedy is the optimal policy and
hence the competitive ratio is 1. Finally, we show that both results are robust
to approximations of the greedy policy. Our work demonstrates that the
reusability of resources can enhance performance compared to the non-reusable
setting, and that a simple greedy policy suffices when the degree of
reusability is high. Our insights contribute to the understanding of how
resource reusability can influence the performance of online algorithms, and
highlight the potential for improved performance as the degree of reusability
increases.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-10T00:30:00Z">Monday, April 10 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.03426'>Convex Minimization with Integer Minima in $\widetilde O(n^4)$ Time</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Haotian Jiang, Yin Tat Lee, Zhao Song, Lichen Zhang</p><p>Given a convex function $f$ on $\mathbb{R}^n$ with an integer minimizer, we
show how to find an exact minimizer of $f$ using $O(n^2 \log n)$ calls to a
separation oracle and $O(n^4 \log n)$ time. The previous best polynomial time
algorithm for this problem given in [Jiang, SODA 2021, JACM 2022] achieves
$\widetilde{O}(n^2)$ oracle complexity. However, the overall runtime of Jiang's
algorithm is at least $\widetilde{\Omega}(n^8)$, due to expensive sub-routines
such as the Lenstra-Lenstra-Lov\'asz (LLL) algorithm [Lenstra, Lenstra,
Lov\'asz, Math. Ann. 1982] and random walk based cutting plane method
[Bertsimas, Vempala, JACM 2004]. Our significant speedup is obtained by a
nontrivial combination of a faster version of the LLL algorithm due to
[Neumaier, Stehl\'e, ISSAC 2016] that gives similar guarantees, the volumetric
center cutting plane method (CPM) by [Vaidya, FOCS 1989] and its fast
implementation given in [Jiang, Lee, Song, Wong, STOC 2020].
</p>
<p>For the special case of submodular function minimization (SFM), our result
implies a strongly polynomial time algorithm for this problem using $O(n^3 \log
n)$ calls to an evaluation oracle and $O(n^4 \log n)$ additional arithmetic
operations. Both the oracle complexity and the number of arithmetic operations
of our more general algorithm are better than the previous best-known runtime
algorithms for this specific problem given in [Lee, Sidford, Wong, FOCS 2015]
and [Dadush, V\'egh, Zambelli, SODA 2018, MOR 2021].
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Jiang_H/0/1/0/all/0/1">Haotian Jiang</a>, <a href="http://arxiv.org/find/cs/1/au:+Lee_Y/0/1/0/all/0/1">Yin Tat Lee</a>, <a href="http://arxiv.org/find/cs/1/au:+Song_Z/0/1/0/all/0/1">Zhao Song</a>, <a href="http://arxiv.org/find/cs/1/au:+Zhang_L/0/1/0/all/0/1">Lichen Zhang</a></p><p>Given a convex function $f$ on $\mathbb{R}^n$ with an integer minimizer, we
show how to find an exact minimizer of $f$ using $O(n^2 \log n)$ calls to a
separation oracle and $O(n^4 \log n)$ time. The previous best polynomial time
algorithm for this problem given in [Jiang, SODA 2021, JACM 2022] achieves
$\widetilde{O}(n^2)$ oracle complexity. However, the overall runtime of Jiang's
algorithm is at least $\widetilde{\Omega}(n^8)$, due to expensive sub-routines
such as the Lenstra-Lenstra-Lov\'asz (LLL) algorithm [Lenstra, Lenstra,
Lov\'asz, Math. Ann. 1982] and random walk based cutting plane method
[Bertsimas, Vempala, JACM 2004]. Our significant speedup is obtained by a
nontrivial combination of a faster version of the LLL algorithm due to
[Neumaier, Stehl\'e, ISSAC 2016] that gives similar guarantees, the volumetric
center cutting plane method (CPM) by [Vaidya, FOCS 1989] and its fast
implementation given in [Jiang, Lee, Song, Wong, STOC 2020].
</p>
<p>For the special case of submodular function minimization (SFM), our result
implies a strongly polynomial time algorithm for this problem using $O(n^3 \log
n)$ calls to an evaluation oracle and $O(n^4 \log n)$ additional arithmetic
operations. Both the oracle complexity and the number of arithmetic operations
of our more general algorithm are better than the previous best-known runtime
algorithms for this specific problem given in [Lee, Sidford, Wong, FOCS 2015]
and [Dadush, V\'egh, Zambelli, SODA 2018, MOR 2021].
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-10T00:30:00Z">Monday, April 10 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.03567'>Temporalizing digraphs via linear-size balanced bi-trees</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: St&#xe9;phane Bessy, St&#xe9;phan Thomass&#xe9;, Laurent Viennot</p><p>In a directed graph $D$ on vertex set $v_1,\dots ,v_n$, a \emph{forward arc}
is an arc $v_iv_j$ where $i&lt;j$. A pair $v_i,v_j$ is \emph{forward connected} if
there is a directed path from $v_i$ to $v_j$ consisting of forward arcs. In the
{\tt Forward Connected Pairs Problem} ({\tt FCPP}), the input is a strongly
connected digraph $D$, and the output is the maximum number of forward
connected pairs in some vertex enumeration of $D$. We show that {\tt FCPP} is
in APX, as one can efficiently enumerate the vertices of $D$ in order to
achieve a quadratic number of forward connected pairs. For this, we construct a
linear size balanced bi-tree $T$ (an out-tree and an in-tree with same size
which roots are identified). The existence of such a $T$ was left as an open
problem motivated by the study of temporal paths in temporal networks. More
precisely, $T$ can be constructed in quadratic time (in the number of vertices)
and has size at least $n/3$. The algorithm involves a particular depth-first
search tree (Left-DFS) of independent interest, and shows that every strongly
connected directed graph has a balanced separator which is a circuit.
Remarkably, in the request version {\tt RFCPP} of {\tt FCPP}, where the input
is a strong digraph $D$ and a set of requests $R$ consisting of pairs
$\{x_i,y_i\}$, there is no constant $c&gt;0$ such that one can always find an
enumeration realizing $c.|R|$ forward connected pairs $\{x_i,y_i\}$ (in either
direction).
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/math/1/au:+Bessy_S/0/1/0/all/0/1">St&#xe9;phane Bessy</a>, <a href="http://arxiv.org/find/math/1/au:+Thomasse_S/0/1/0/all/0/1">St&#xe9;phan Thomass&#xe9;</a>, <a href="http://arxiv.org/find/math/1/au:+Viennot_L/0/1/0/all/0/1">Laurent Viennot</a></p><p>In a directed graph $D$ on vertex set $v_1,\dots ,v_n$, a \emph{forward arc}
is an arc $v_iv_j$ where $i&lt;j$. A pair $v_i,v_j$ is \emph{forward connected} if
there is a directed path from $v_i$ to $v_j$ consisting of forward arcs. In the
{\tt Forward Connected Pairs Problem} ({\tt FCPP}), the input is a strongly
connected digraph $D$, and the output is the maximum number of forward
connected pairs in some vertex enumeration of $D$. We show that {\tt FCPP} is
in APX, as one can efficiently enumerate the vertices of $D$ in order to
achieve a quadratic number of forward connected pairs. For this, we construct a
linear size balanced bi-tree $T$ (an out-tree and an in-tree with same size
which roots are identified). The existence of such a $T$ was left as an open
problem motivated by the study of temporal paths in temporal networks. More
precisely, $T$ can be constructed in quadratic time (in the number of vertices)
and has size at least $n/3$. The algorithm involves a particular depth-first
search tree (Left-DFS) of independent interest, and shows that every strongly
connected directed graph has a balanced separator which is a circuit.
Remarkably, in the request version {\tt RFCPP} of {\tt FCPP}, where the input
is a strong digraph $D$ and a set of requests $R$ consisting of pairs
$\{x_i,y_i\}$, there is no constant $c&gt;0$ such that one can always find an
enumeration realizing $c.|R|$ forward connected pairs $\{x_i,y_i\}$ (in either
direction).
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-10T00:30:00Z">Monday, April 10 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    
    <h2 class='tr-new-date'>
      <i class='fa-regular fa-calendar'></i> Sunday, April 09
    </h2>
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='https://eccc.weizmann.ac.il/report/2023/044'>TR23-044 |  Separations between Combinatorial Measures for Transitive Functions | 

	Sourav Chakraborty, 

	Chandrima Kayal, 

	Manaswi Paraashar</a></h3>
        <p class='tr-article-feed'>from <a href='https://eccc.weizmann.ac.il/'>ECCC Papers</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          The role of symmetry in Boolean functions $f:\{0,1\}^n \to \{0,1\}$ has been extensively studied in complexity theory. 
For example, symmetric functions, that is, functions that are invariant under the action of $S_n$ is an important class of functions in the study of Boolean functions.
A function $f:\{0,1\}^n \to \{0,1\}$ is called transitive (or weakly-symmetric) if there exists a transitive group $G$ of $S_n$ such that $f$ is invariant under the action of $G$. In other words, the value of a transitive function remains unchanged even after the input bits of $f$ are moved around according to some permutation $\sigma \in G$. Understanding various complexity measures of transitive functions has been a rich area of research for the past few decades.



In this work, we study transitive functions in light of several combinatorial measures. The question that we try to address in this paper is what is the maximum separations between various pairs of combinatorial measures for transitive functions. Such study for general Boolean functions has been going on for the past many years. The current best-known results for general Boolean functions have been nicely compiled by Aaronson et~al.~(STOC, 2021). But before this paper, no such systematic study has been done for the case of transitive functions. 

 
The separation between a pair of combinatorial measures is shown by constructing interesting functions that demonstrate the separation. Over the past three decades, various interesting classes of functions have been designed for this purpose. In this context, one of the celebrated classes of functions is the class of ``pointer functions&#39;&#39;.
Ambainis et al.~(JACM, 2017) constructed several functions, which are modifications of the pointer function, first introduced in G{\&quot;{o}}{\&quot;{o}}s et~al.~(SICOMP, 2018 / FOCS, 2015), to demonstrate separation between various pairs of measures. In the last few years, pointer functions have been used to show separation between  various other pairs of measures (for example, Mukhopadhyay et~al.~(FSTTCS, 2015), Ben-David et~al.~(ITCS, 2017), G{\&quot;{o}}{\&quot;{o}}s et~al.~(ToCT, 2018 / ICALP, 2017)).  

However, the pointer functions themselves are not transitive. 
Based on the various kinds of pointer functions, we construct new transitive functions whose deterministic query complexity, randomized query complexity, zero-error randomized query complexity, quantum query complexity, degree, and approximate degree are similar to that of the original pointer functions. Thus we demonstrate that even for transitive functions similar separations between pairs of combinatorial measures can be achieved.  

Our constructions of transitive functions depend crucially on construction of particular classes of transitive groups, whose actions, though involved, helps to preserve certain structural features of the input strings.  The transitive groups we construct may be of independent interest in other areas of mathematics and theoretical computer science. 

We summarize the current knowledge of relations between various combinatorial measures of transitive functions in a table similar to the table compiled by Aaronson et~al.~(STOC, 2021) for general functions.
        
        </div>

        <div class='tr-article-summary'>
        
          
          The role of symmetry in Boolean functions $f:\{0,1\}^n \to \{0,1\}$ has been extensively studied in complexity theory. 
For example, symmetric functions, that is, functions that are invariant under the action of $S_n$ is an important class of functions in the study of Boolean functions.
A function $f:\{0,1\}^n \to \{0,1\}$ is called transitive (or weakly-symmetric) if there exists a transitive group $G$ of $S_n$ such that $f$ is invariant under the action of $G$. In other words, the value of a transitive function remains unchanged even after the input bits of $f$ are moved around according to some permutation $\sigma \in G$. Understanding various complexity measures of transitive functions has been a rich area of research for the past few decades.



In this work, we study transitive functions in light of several combinatorial measures. The question that we try to address in this paper is what is the maximum separations between various pairs of combinatorial measures for transitive functions. Such study for general Boolean functions has been going on for the past many years. The current best-known results for general Boolean functions have been nicely compiled by Aaronson et~al.~(STOC, 2021). But before this paper, no such systematic study has been done for the case of transitive functions. 

 
The separation between a pair of combinatorial measures is shown by constructing interesting functions that demonstrate the separation. Over the past three decades, various interesting classes of functions have been designed for this purpose. In this context, one of the celebrated classes of functions is the class of ``pointer functions&#39;&#39;.
Ambainis et al.~(JACM, 2017) constructed several functions, which are modifications of the pointer function, first introduced in G{\&quot;{o}}{\&quot;{o}}s et~al.~(SICOMP, 2018 / FOCS, 2015), to demonstrate separation between various pairs of measures. In the last few years, pointer functions have been used to show separation between  various other pairs of measures (for example, Mukhopadhyay et~al.~(FSTTCS, 2015), Ben-David et~al.~(ITCS, 2017), G{\&quot;{o}}{\&quot;{o}}s et~al.~(ToCT, 2018 / ICALP, 2017)).  

However, the pointer functions themselves are not transitive. 
Based on the various kinds of pointer functions, we construct new transitive functions whose deterministic query complexity, randomized query complexity, zero-error randomized query complexity, quantum query complexity, degree, and approximate degree are similar to that of the original pointer functions. Thus we demonstrate that even for transitive functions similar separations between pairs of combinatorial measures can be achieved.  

Our constructions of transitive functions depend crucially on construction of particular classes of transitive groups, whose actions, though involved, helps to preserve certain structural features of the input strings.  The transitive groups we construct may be of independent interest in other areas of mathematics and theoretical computer science. 

We summarize the current knowledge of relations between various combinatorial measures of transitive functions in a table similar to the table compiled by Aaronson et~al.~(STOC, 2021) for general functions.
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-09T11:26:00Z">Sunday, April 09 2023, 11:26</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='https://eccc.weizmann.ac.il/report/2023/043'>TR23-043 |  Coboundary and cosystolic expansion without dependence on dimension or degree | 

	Yotam Dikstein, 

	Irit Dinur</a></h3>
        <p class='tr-article-feed'>from <a href='https://eccc.weizmann.ac.il/'>ECCC Papers</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          We give new bounds on the cosystolic expansion constants of several families of high dimensional expanders, and the known coboundary expansion constants of order complexes of homogeneous geometric lattices, including the spherical building of $SL_n(F_q)$. The improvement applies to the high dimensional expanders constructed by Lubotzky, Samuels and Vishne, and by Kaufman and Oppenheim.

Our new expansion constants do not depend on the degree of the complex nor on its dimension, nor on the group of coefficients. This implies improved bounds on Gromov’s topological overlap constant, and on Dinur and Meshulam’s cover stability, which may have applications for agreement testing. In comparison, existing bounds decay exponentially with the ambient dimension (for spherical buildings) and in addition decay linearly with the degree (for all known bounded-degree high dimensional expanders).

Our results are based on several new techniques:

– We develop a new “color-restriction” technique which enables proving dimension-free expansion by restricting a multi-partite complex to small random subsets of its color classes.

– We give a new “spectral” proof for Evra and Kaufman’s local-to-global theorem, deriving better bounds and getting rid of the dependence on the degree. This theorem bounds the cosystolic expansion of a complex using coboundary expansion and spectral expansion of the links.

– We derive absolute bounds on the coboundary expansion of the spherical building (and any order complex of a homogeneous geometric lattice) by constructing a novel family of very short cones.
        
        </div>

        <div class='tr-article-summary'>
        
          
          We give new bounds on the cosystolic expansion constants of several families of high dimensional expanders, and the known coboundary expansion constants of order complexes of homogeneous geometric lattices, including the spherical building of $SL_n(F_q)$. The improvement applies to the high dimensional expanders constructed by Lubotzky, Samuels and Vishne, and by Kaufman and Oppenheim.

Our new expansion constants do not depend on the degree of the complex nor on its dimension, nor on the group of coefficients. This implies improved bounds on Gromov’s topological overlap constant, and on Dinur and Meshulam’s cover stability, which may have applications for agreement testing. In comparison, existing bounds decay exponentially with the ambient dimension (for spherical buildings) and in addition decay linearly with the degree (for all known bounded-degree high dimensional expanders).

Our results are based on several new techniques:

– We develop a new “color-restriction” technique which enables proving dimension-free expansion by restricting a multi-partite complex to small random subsets of its color classes.

– We give a new “spectral” proof for Evra and Kaufman’s local-to-global theorem, deriving better bounds and getting rid of the dependence on the degree. This theorem bounds the cosystolic expansion of a complex using coboundary expansion and spectral expansion of the links.

– We derive absolute bounds on the coboundary expansion of the spherical building (and any order complex of a homogeneous geometric lattice) by constructing a novel family of very short cones.
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-09T06:09:10Z">Sunday, April 09 2023, 06:09</time>
        </div>
      </div>
    </details>
  
    
    <h2 class='tr-new-date'>
      <i class='fa-regular fa-calendar'></i> Friday, April 07
    </h2>
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='https://ptreview.sublinear.info/2023/04/news-for-march-2023/'>News for March 2023</a></h3>
        <p class='tr-article-feed'>from <a href='https://ptreview.sublinear.info'>Property Testing Review</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          I never thought this day would come. For the first time in PTReview history, there is no paper to report. Nada. Zilch. The calm before the storm&#8230;?
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p>I never thought this day would come.</p>



<p>For the first time in PTReview history, there is no paper to report. Nada. Zilch.</p>



<p>The calm before the storm&#8230;?</p>
<p class="authors">By Seshadhri</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-07T16:45:00Z">Friday, April 07 2023, 16:45</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.02770'>Tight Correlation Bounds for Circuits Between AC0 and TC0</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Vinayak M. Kumar</p><p>We initiate the study of generalized AC0 circuits comprised of negations and
arbitrary unbounded fan-in gates that only need to be constant over inputs of
Hamming weight $\ge k$, which we denote GC0$(k)$. The gate set of this class
includes biased LTFs like the $k$-$OR$ (output $1$ iff $\ge k$ bits are 1) and
$k$-$AND$ (output $0$ iff $\ge k$ bits are 0), and thus can be seen as an
interpolation between AC0 and TC0. We establish a tight multi-switching lemma
for GC0$(k)$ circuits, which bounds the probability that several depth-2
GC0$(k)$ circuits do not simultaneously simplify under a random restriction. We
also establish a new depth reduction lemma such that coupled with our
multi-switching lemma, we can show many results obtained from the
multi-switching lemma for depth-$d$ size-$s$ AC0 circuits lifts to depth-$d$
size-$s^{.99}$ GC0$(.01\log s)$ circuits with no loss in parameters (other than
hidden constants). Our result has the following applications:
</p>
<p>1.Size-$2^{\Omega(n^{1/d})}$ depth-$d$ GC0$(\Omega(n^{1/d}))$ circuits do not
correlate with parity (extending a result of H{\aa}stad (SICOMP, 2014)).
</p>
<p>2. Size-$n^{\Omega(\log n)}$ GC0$(\Omega(\log^2 n))$ circuits with $n^{.249}$
arbitrary threshold gates or $n^{.499}$ arbitrary symmetric gates exhibit
exponentially small correlation against an explicit function (extending a
result of Tan and Servedio (RANDOM, 2019)).
</p>
<p>3. There is a seed length $O((\log m)^{d-1}\log(m/\varepsilon)\log\log(m))$
pseudorandom generator against size-$m$ depth-$d$ GC0$(\log m)$ circuits,
matching the AC0 lower bound of H{\aa}stad stad up to a $\log\log m$ factor
(extending a result of Lyu (CCC, 2022)).
</p>
<p>4. Size-$m$ GC0$(\log m)$ circuits have exponentially small Fourier tails
(extending a result of Tal (CCC, 2017)).
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Kumar_V/0/1/0/all/0/1">Vinayak M. Kumar</a></p><p>We initiate the study of generalized AC0 circuits comprised of negations and
arbitrary unbounded fan-in gates that only need to be constant over inputs of
Hamming weight $\ge k$, which we denote GC0$(k)$. The gate set of this class
includes biased LTFs like the $k$-$OR$ (output $1$ iff $\ge k$ bits are 1) and
$k$-$AND$ (output $0$ iff $\ge k$ bits are 0), and thus can be seen as an
interpolation between AC0 and TC0. We establish a tight multi-switching lemma
for GC0$(k)$ circuits, which bounds the probability that several depth-2
GC0$(k)$ circuits do not simultaneously simplify under a random restriction. We
also establish a new depth reduction lemma such that coupled with our
multi-switching lemma, we can show many results obtained from the
multi-switching lemma for depth-$d$ size-$s$ AC0 circuits lifts to depth-$d$
size-$s^{.99}$ GC0$(.01\log s)$ circuits with no loss in parameters (other than
hidden constants). Our result has the following applications:
</p>
<p>1.Size-$2^{\Omega(n^{1/d})}$ depth-$d$ GC0$(\Omega(n^{1/d}))$ circuits do not
correlate with parity (extending a result of H{\aa}stad (SICOMP, 2014)).
</p>
<p>2. Size-$n^{\Omega(\log n)}$ GC0$(\Omega(\log^2 n))$ circuits with $n^{.249}$
arbitrary threshold gates or $n^{.499}$ arbitrary symmetric gates exhibit
exponentially small correlation against an explicit function (extending a
result of Tan and Servedio (RANDOM, 2019)).
</p>
<p>3. There is a seed length $O((\log m)^{d-1}\log(m/\varepsilon)\log\log(m))$
pseudorandom generator against size-$m$ depth-$d$ GC0$(\log m)$ circuits,
matching the AC0 lower bound of H{\aa}stad stad up to a $\log\log m$ factor
(extending a result of Lyu (CCC, 2022)).
</p>
<p>4. Size-$m$ GC0$(\log m)$ circuits have exponentially small Fourier tails
(extending a result of Tal (CCC, 2017)).
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-07T00:30:00Z">Friday, April 07 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.02781'>Inapproximability of sufficient reasons for decision trees</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Alexander Kozachinskiy</p><p>In this note, we establish the hardness of approximation of the problem of
computing the minimal size of a $\delta$-sufficient reason for decision trees.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Kozachinskiy_A/0/1/0/all/0/1">Alexander Kozachinskiy</a></p><p>In this note, we establish the hardness of approximation of the problem of
computing the minimal size of a $\delta$-sufficient reason for decision trees.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-07T00:30:00Z">Friday, April 07 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.02943'>Improved Hardness of Approximating k-Clique under ETH</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Bingkai Lin, Xuandi Ren, Yican Sun, Xiuhan Wang</p><p>In this paper, we prove that assuming the exponential time hypothesis (ETH),
there is no $f(k)\cdot n^{k^{o(1/\log\log k)}}$-time algorithm that can decide
whether an $n$-vertex graph contains a clique of size $k$ or contains no clique
of size $k/2$, and no FPT algorithm can decide whether an input graph has a
clique of size $k$ or no clique of size $k/f(k)$, where $f(k)$ is some function
in $k^{1-o(1)}$. Our results significantly improve the previous works [Lin21,
LRSW22]. The crux of our proof is a framework to construct gap-producing
reductions for the \kclique{} problem. More precisely, we show that given an
error-correcting code $C:\Sigma_1^k\to\Sigma_2^{k'}$ that is locally testable
and smooth locally decodable in the parallel setting, one can construct a
reduction which on input a graph $G$ outputs a graph $G'$ in $(k')^{O(1)}\cdot
n^{O(\log|\Sigma_2|/\log|\Sigma_1|)}$ time such that:
</p>
<p>$\bullet$ If $G$ has a clique of size $k$, then $G'$ has a clique of size
$K$, where $K = (k')^{O(1)}$.
</p>
<p>$\bullet$ If $G$ has no clique of size $k$, then $G'$ has no clique of size
$(1-\varepsilon)\cdot K$ for some constant $\varepsilon\in(0,1)$.
</p>
<p>We then construct such a code with $k'=k^{\Theta(\log\log k)}$ and
$|\Sigma_2|=|\Sigma_1|^{k^{0.54}}$, establishing the hardness results above.
Our code generalizes the derivative code [WY07] into the case with a super
constant order of derivatives.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Lin_B/0/1/0/all/0/1">Bingkai Lin</a>, <a href="http://arxiv.org/find/cs/1/au:+Ren_X/0/1/0/all/0/1">Xuandi Ren</a>, <a href="http://arxiv.org/find/cs/1/au:+Sun_Y/0/1/0/all/0/1">Yican Sun</a>, <a href="http://arxiv.org/find/cs/1/au:+Wang_X/0/1/0/all/0/1">Xiuhan Wang</a></p><p>In this paper, we prove that assuming the exponential time hypothesis (ETH),
there is no $f(k)\cdot n^{k^{o(1/\log\log k)}}$-time algorithm that can decide
whether an $n$-vertex graph contains a clique of size $k$ or contains no clique
of size $k/2$, and no FPT algorithm can decide whether an input graph has a
clique of size $k$ or no clique of size $k/f(k)$, where $f(k)$ is some function
in $k^{1-o(1)}$. Our results significantly improve the previous works [Lin21,
LRSW22]. The crux of our proof is a framework to construct gap-producing
reductions for the \kclique{} problem. More precisely, we show that given an
error-correcting code $C:\Sigma_1^k\to\Sigma_2^{k'}$ that is locally testable
and smooth locally decodable in the parallel setting, one can construct a
reduction which on input a graph $G$ outputs a graph $G'$ in $(k')^{O(1)}\cdot
n^{O(\log|\Sigma_2|/\log|\Sigma_1|)}$ time such that:
</p>
<p>$\bullet$ If $G$ has a clique of size $k$, then $G'$ has a clique of size
$K$, where $K = (k')^{O(1)}$.
</p>
<p>$\bullet$ If $G$ has no clique of size $k$, then $G'$ has no clique of size
$(1-\varepsilon)\cdot K$ for some constant $\varepsilon\in(0,1)$.
</p>
<p>We then construct such a code with $k'=k^{\Theta(\log\log k)}$ and
$|\Sigma_2|=|\Sigma_1|^{k^{0.54}}$, establishing the hardness results above.
Our code generalizes the derivative code [WY07] into the case with a super
constant order of derivatives.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-07T00:30:00Z">Friday, April 07 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.03256'>The complexity of decomposing a graph into a matching and a bounded linear forest</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Agnijo Banerjee, Jo&#xe3;o Pedro Marciano, Adva Mond, Jan Petr, Julien Portier</p><p>Deciding whether a graph can be edge-decomposed into a matching and a
$k$-bounded linear forest was recently shown by Campbell, H{\"o}rsch and Moore
to be NP-complete for every $k \ge 9$, and solvable in polynomial time for
$k=1,2$. In the first part of this paper, we close this gap by showing that
this problem is in NP-complete for every $k \ge 3$. In the second part of the
paper, we show that deciding whether a graph can be edge-decomposed into a
matching and a $k$-bounded star forest is polynomially solvable for any $k \in
\mathbb{N} \cup \{ \infty \}$, answering another question by Campbell,
H{\"o}rsch and Moore from the same paper.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Banerjee_A/0/1/0/all/0/1">Agnijo Banerjee</a>, <a href="http://arxiv.org/find/cs/1/au:+Marciano_J/0/1/0/all/0/1">Jo&#xe3;o Pedro Marciano</a>, <a href="http://arxiv.org/find/cs/1/au:+Mond_A/0/1/0/all/0/1">Adva Mond</a>, <a href="http://arxiv.org/find/cs/1/au:+Petr_J/0/1/0/all/0/1">Jan Petr</a>, <a href="http://arxiv.org/find/cs/1/au:+Portier_J/0/1/0/all/0/1">Julien Portier</a></p><p>Deciding whether a graph can be edge-decomposed into a matching and a
$k$-bounded linear forest was recently shown by Campbell, H{\"o}rsch and Moore
to be NP-complete for every $k \ge 9$, and solvable in polynomial time for
$k=1,2$. In the first part of this paper, we close this gap by showing that
this problem is in NP-complete for every $k \ge 3$. In the second part of the
paper, we show that deciding whether a graph can be edge-decomposed into a
matching and a $k$-bounded star forest is polynomially solvable for any $k \in
\mathbb{N} \cup \{ \infty \}$, answering another question by Campbell,
H{\"o}rsch and Moore from the same paper.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-07T00:30:00Z">Friday, April 07 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.02745'>Software and Analysis for Dynamic Voronoi Diagrams in the Hilbert Metric</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CG/recent'>arXiv: Computational Geometry</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Madeline Bumpus, Caesar Dai, Auguste H. Gezalyan, Sam Munoz, Renita Santhoshkumar, Songyu Ye, David M. Mount</p><p>The Hilbert metric is a projective metric defined on a convex body which
generalizes the Cayley-Klein model of hyperbolic geometry to any convex set. In
this paper we analyze Hilbert Voronoi diagrams in the Dynamic setting. In
addition we introduce dynamic visualization software for Voronoi diagrams in
the Hilbert metric on user specified convex polygons.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Bumpus_M/0/1/0/all/0/1">Madeline Bumpus</a>, <a href="http://arxiv.org/find/cs/1/au:+Dai_C/0/1/0/all/0/1">Caesar Dai</a>, <a href="http://arxiv.org/find/cs/1/au:+Gezalyan_A/0/1/0/all/0/1">Auguste H. Gezalyan</a>, <a href="http://arxiv.org/find/cs/1/au:+Munoz_S/0/1/0/all/0/1">Sam Munoz</a>, <a href="http://arxiv.org/find/cs/1/au:+Santhoshkumar_R/0/1/0/all/0/1">Renita Santhoshkumar</a>, <a href="http://arxiv.org/find/cs/1/au:+Ye_S/0/1/0/all/0/1">Songyu Ye</a>, <a href="http://arxiv.org/find/cs/1/au:+Mount_D/0/1/0/all/0/1">David M. Mount</a></p><p>The Hilbert metric is a projective metric defined on a convex body which
generalizes the Cayley-Klein model of hyperbolic geometry to any convex set. In
this paper we analyze Hilbert Voronoi diagrams in the Dynamic setting. In
addition we introduce dynamic visualization software for Voronoi diagrams in
the Hilbert metric on user specified convex polygons.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-07T00:30:00Z">Friday, April 07 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.02657'>Fast computation of approximate weak common intervals in multiple indeterminate strings</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Daniel Doerr, Bernard M.E. Moret</p><p>In ongoing work to define a principled method for syntenic block discovery
and structuring, work based on homology-derived constraints and a
generalization of common intervals, we faced a fundamental computational
problem: how to determine quickly, among a set of indeterminate strings
(strings whose elements consist of subsets of characters), contiguous intervals
that would share a vast majority of their elements, but allow for sharing
subsets of characters subsumed by others, and also for certain elements to be
missing from certain genomes. An algorithm for this problem in the special case
of determinate strings (where each element is a single character of the
alphabet, i.e., "normal" strings) was described by Doerr et al., but its
running time would explode if generalized to indeterminate strings. In this
paper, we describe an algorithm for computing these special common intervals in
time close to that of the simpler algorithm of Doerr et al. and show that can
compute these intervals in just a couple of hours for large collections (tens
to hundreds) of bacterial genomes.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Doerr_D/0/1/0/all/0/1">Daniel Doerr</a>, <a href="http://arxiv.org/find/cs/1/au:+Moret_B/0/1/0/all/0/1">Bernard M.E. Moret</a></p><p>In ongoing work to define a principled method for syntenic block discovery
and structuring, work based on homology-derived constraints and a
generalization of common intervals, we faced a fundamental computational
problem: how to determine quickly, among a set of indeterminate strings
(strings whose elements consist of subsets of characters), contiguous intervals
that would share a vast majority of their elements, but allow for sharing
subsets of characters subsumed by others, and also for certain elements to be
missing from certain genomes. An algorithm for this problem in the special case
of determinate strings (where each element is a single character of the
alphabet, i.e., "normal" strings) was described by Doerr et al., but its
running time would explode if generalized to indeterminate strings. In this
paper, we describe an algorithm for computing these special common intervals in
time close to that of the simpler algorithm of Doerr et al. and show that can
compute these intervals in just a couple of hours for large collections (tens
to hundreds) of bacterial genomes.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-07T00:30:00Z">Friday, April 07 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.02700'>Agnostic proper learning of monotone functions: beyond the black-box correction barrier</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Jane Lange, Arsen Vasilyan</p><p>We give the first agnostic, efficient, proper learning algorithm for monotone
Boolean functions. Given $2^{\tilde{O}(\sqrt{n}/\varepsilon)}$ uniformly random
examples of an unknown function $f:\{\pm 1\}^n \rightarrow \{\pm 1\}$, our
algorithm outputs a hypothesis $g:\{\pm 1\}^n \rightarrow \{\pm 1\}$ that is
monotone and $(\mathrm{opt} + \varepsilon)$-close to $f$, where $\mathrm{opt}$
is the distance from $f$ to the closest monotone function. The running time of
the algorithm (and consequently the size and evaluation time of the hypothesis)
is also $2^{\tilde{O}(\sqrt{n}/\varepsilon)}$, nearly matching the lower bound
of Blais et al (RANDOM '15). We also give an algorithm for estimating up to
additive error $\varepsilon$ the distance of an unknown function $f$ to
monotone using a run-time of $2^{\tilde{O}(\sqrt{n}/\varepsilon)}$. Previously,
for both of these problems, sample-efficient algorithms were known, but these
algorithms were not run-time efficient. Our work thus closes this gap in our
knowledge between the run-time and sample complexity.
</p>
<p>This work builds upon the improper learning algorithm of Bshouty and Tamon
(JACM '96) and the proper semiagnostic learning algorithm of Lange, Rubinfeld,
and Vasilyan (FOCS '22), which obtains a non-monotone Boolean-valued
hypothesis, then ``corrects'' it to monotone using query-efficient local
computation algorithms on graphs. This black-box correction approach can
achieve no error better than $2\mathrm{opt} + \varepsilon$
information-theoretically; we bypass this barrier by
</p>
<p>a) augmenting the improper learner with a convex optimization step, and
</p>
<p>b) learning and correcting a real-valued function before rounding its values
to Boolean.
</p>
<p>Our real-valued correction algorithm solves the ``poset sorting'' problem of
[LRV22] for functions over general posets with non-Boolean labels.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Lange_J/0/1/0/all/0/1">Jane Lange</a>, <a href="http://arxiv.org/find/cs/1/au:+Vasilyan_A/0/1/0/all/0/1">Arsen Vasilyan</a></p><p>We give the first agnostic, efficient, proper learning algorithm for monotone
Boolean functions. Given $2^{\tilde{O}(\sqrt{n}/\varepsilon)}$ uniformly random
examples of an unknown function $f:\{\pm 1\}^n \rightarrow \{\pm 1\}$, our
algorithm outputs a hypothesis $g:\{\pm 1\}^n \rightarrow \{\pm 1\}$ that is
monotone and $(\mathrm{opt} + \varepsilon)$-close to $f$, where $\mathrm{opt}$
is the distance from $f$ to the closest monotone function. The running time of
the algorithm (and consequently the size and evaluation time of the hypothesis)
is also $2^{\tilde{O}(\sqrt{n}/\varepsilon)}$, nearly matching the lower bound
of Blais et al (RANDOM '15). We also give an algorithm for estimating up to
additive error $\varepsilon$ the distance of an unknown function $f$ to
monotone using a run-time of $2^{\tilde{O}(\sqrt{n}/\varepsilon)}$. Previously,
for both of these problems, sample-efficient algorithms were known, but these
algorithms were not run-time efficient. Our work thus closes this gap in our
knowledge between the run-time and sample complexity.
</p>
<p>This work builds upon the improper learning algorithm of Bshouty and Tamon
(JACM '96) and the proper semiagnostic learning algorithm of Lange, Rubinfeld,
and Vasilyan (FOCS '22), which obtains a non-monotone Boolean-valued
hypothesis, then ``corrects'' it to monotone using query-efficient local
computation algorithms on graphs. This black-box correction approach can
achieve no error better than $2\mathrm{opt} + \varepsilon$
information-theoretically; we bypass this barrier by
</p>
<p>a) augmenting the improper learner with a convex optimization step, and
</p>
<p>b) learning and correcting a real-valued function before rounding its values
to Boolean.
</p>
<p>Our real-valued correction algorithm solves the ``poset sorting'' problem of
[LRV22] for functions over general posets with non-Boolean labels.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-07T00:30:00Z">Friday, April 07 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.02897'>LSketch: A Label-Enabled Graph Stream Sketch Toward Time-Sensitive Queries</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Yiling Zeng, Chunyao Song, Yuhan Li, Tingjian Ge</p><p>Graph streams represent data interactions in real applications. The mining of
graph streams plays an important role in network security, social network
analysis, and traffic control, among others. However, the sheer volume and high
dynamics cause great challenges for efficient storage and subsequent query
analysis on them. Current studies apply sketches to summarize graph streams. We
propose LSketch that works for heterogeneous graph streams, which effectively
preserves the label information carried by the streams in real scenes, thereby
enriching the expressive ability of sketches. In addition, as graph streams
continue to evolve over time, edges too old may lose their practical
significance. Therefore, we introduce the sliding window model into LSketch to
eliminate the expired edges automatically. LSketch uses sub-linear storage
space and can support structure based queries and time-sensitive queries with
high accuracy. We perform extensive experiments over four real datasets,
demonstrating the superiority of the proposed method over state-of-the-art
methods, in aspects of query accuracy and time efficiency.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Zeng_Y/0/1/0/all/0/1">Yiling Zeng</a>, <a href="http://arxiv.org/find/cs/1/au:+Song_C/0/1/0/all/0/1">Chunyao Song</a>, <a href="http://arxiv.org/find/cs/1/au:+Li_Y/0/1/0/all/0/1">Yuhan Li</a>, <a href="http://arxiv.org/find/cs/1/au:+Ge_T/0/1/0/all/0/1">Tingjian Ge</a></p><p>Graph streams represent data interactions in real applications. The mining of
graph streams plays an important role in network security, social network
analysis, and traffic control, among others. However, the sheer volume and high
dynamics cause great challenges for efficient storage and subsequent query
analysis on them. Current studies apply sketches to summarize graph streams. We
propose LSketch that works for heterogeneous graph streams, which effectively
preserves the label information carried by the streams in real scenes, thereby
enriching the expressive ability of sketches. In addition, as graph streams
continue to evolve over time, edges too old may lose their practical
significance. Therefore, we introduce the sliding window model into LSketch to
eliminate the expired edges automatically. LSketch uses sub-linear storage
space and can support structure based queries and time-sensitive queries with
high accuracy. We perform extensive experiments over four real datasets,
demonstrating the superiority of the proposed method over state-of-the-art
methods, in aspects of query accuracy and time efficiency.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-07T00:30:00Z">Friday, April 07 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.03146'>Parameterized Approximation Schemes for Clustering with General Norm Objectives</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Fateme Abbasi, Sandip Banerjee, Jaros&#x142;aw Byrka, Parinya Chalermsook, Ameet Gadekar, Kamyar Khodamoradi, D&#xe1;niel Marx, Roohani Sharma, Joachim Spoerhase</p><p>This paper considers the well-studied algorithmic regime of designing a
$(1+\epsilon)$-approximation algorithm for a $k$-clustering problem that runs
in time $f(k,\epsilon)poly(n)$ (sometimes called an efficient parameterized
approximation scheme or EPAS for short). Notable results of this kind include
EPASes in the high-dimensional Euclidean setting for $k$-center [Bad\u{o}iu,
Har-Peled, Indyk; STOC'02] as well as $k$-median, and $k$-means [Kumar,
Sabharwal, Sen; J. ACM 2010]. However, existing EPASes handle only basic
objectives (such as $k$-center, $k$-median, and $k$-means) and are tailored to
the specific objective and metric space.
</p>
<p>Our main contribution is a clean and simple EPAS that settles more than ten
clustering problems (across multiple well-studied objectives as well as metric
spaces) and unifies well-known EPASes. Our algorithm gives EPASes for a large
variety of clustering objectives (for example, $k$-means, $k$-center,
$k$-median, priority $k$-center, $\ell$-centrum, ordered $k$-median, socially
fair $k$-median aka robust $k$-median, or more generally monotone norm
$k$-clustering) and metric spaces (for example, continuous high-dimensional
Euclidean spaces, metrics of bounded doubling dimension, bounded treewidth
metrics, and planar metrics).
</p>
<p>Key to our approach is a new concept that we call bounded $\epsilon$-scatter
dimension--an intrinsic complexity measure of a metric space that is a
relaxation of the standard notion of bounded doubling dimension. Our main
technical result shows that two conditions are essentially sufficient for our
algorithm to yield an EPAS on the input metric $M$ for any clustering
objective: (i) The objective is described by a monotone (not necessarily
symmetric!) norm, and (ii) the $\epsilon$-scatter dimension of $M$ is upper
bounded by a function of $\epsilon$.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Abbasi_F/0/1/0/all/0/1">Fateme Abbasi</a>, <a href="http://arxiv.org/find/cs/1/au:+Banerjee_S/0/1/0/all/0/1">Sandip Banerjee</a>, <a href="http://arxiv.org/find/cs/1/au:+Byrka_J/0/1/0/all/0/1">Jaros&#x142;aw Byrka</a>, <a href="http://arxiv.org/find/cs/1/au:+Chalermsook_P/0/1/0/all/0/1">Parinya Chalermsook</a>, <a href="http://arxiv.org/find/cs/1/au:+Gadekar_A/0/1/0/all/0/1">Ameet Gadekar</a>, <a href="http://arxiv.org/find/cs/1/au:+Khodamoradi_K/0/1/0/all/0/1">Kamyar Khodamoradi</a>, <a href="http://arxiv.org/find/cs/1/au:+Marx_D/0/1/0/all/0/1">D&#xe1;niel Marx</a>, <a href="http://arxiv.org/find/cs/1/au:+Sharma_R/0/1/0/all/0/1">Roohani Sharma</a>, <a href="http://arxiv.org/find/cs/1/au:+Spoerhase_J/0/1/0/all/0/1">Joachim Spoerhase</a></p><p>This paper considers the well-studied algorithmic regime of designing a
$(1+\epsilon)$-approximation algorithm for a $k$-clustering problem that runs
in time $f(k,\epsilon)poly(n)$ (sometimes called an efficient parameterized
approximation scheme or EPAS for short). Notable results of this kind include
EPASes in the high-dimensional Euclidean setting for $k$-center [Bad\u{o}iu,
Har-Peled, Indyk; STOC'02] as well as $k$-median, and $k$-means [Kumar,
Sabharwal, Sen; J. ACM 2010]. However, existing EPASes handle only basic
objectives (such as $k$-center, $k$-median, and $k$-means) and are tailored to
the specific objective and metric space.
</p>
<p>Our main contribution is a clean and simple EPAS that settles more than ten
clustering problems (across multiple well-studied objectives as well as metric
spaces) and unifies well-known EPASes. Our algorithm gives EPASes for a large
variety of clustering objectives (for example, $k$-means, $k$-center,
$k$-median, priority $k$-center, $\ell$-centrum, ordered $k$-median, socially
fair $k$-median aka robust $k$-median, or more generally monotone norm
$k$-clustering) and metric spaces (for example, continuous high-dimensional
Euclidean spaces, metrics of bounded doubling dimension, bounded treewidth
metrics, and planar metrics).
</p>
<p>Key to our approach is a new concept that we call bounded $\epsilon$-scatter
dimension--an intrinsic complexity measure of a metric space that is a
relaxation of the standard notion of bounded doubling dimension. Our main
technical result shows that two conditions are essentially sufficient for our
algorithm to yield an EPAS on the input metric $M$ for any clustering
objective: (i) The objective is described by a monotone (not necessarily
symmetric!) norm, and (ii) the $\epsilon$-scatter dimension of $M$ is upper
bounded by a function of $\epsilon$.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-07T00:30:00Z">Friday, April 07 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.03170'>Spectral Toolkit of Algorithms for Graphs: Technical Report (1)</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Peter Macgregor, He Sun</p><p>Spectral Toolkit of Algorithms for Graphs (STAG) is an open-source library
for efficient spectral graph algorithms, and its development starts in
September 2022. We have so far finished the component on local graph
clustering, and this technical report presents a user's guide to STAG, showcase
studies, and several technical considerations behind our development.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Macgregor_P/0/1/0/all/0/1">Peter Macgregor</a>, <a href="http://arxiv.org/find/cs/1/au:+Sun_H/0/1/0/all/0/1">He Sun</a></p><p>Spectral Toolkit of Algorithms for Graphs (STAG) is an open-source library
for efficient spectral graph algorithms, and its development starts in
September 2022. We have so far finished the component on local graph
clustering, and this technical report presents a user's guide to STAG, showcase
studies, and several technical considerations behind our development.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-07T00:30:00Z">Friday, April 07 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.03182'>On the tractability of sampling from the Potts model at low temperatures via Swendsen--Wang dynamics</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Antonio Blanca, Reza Gheissari</p><p>Sampling from the $q$-state ferromagnetic Potts model is a fundamental
question in statistical physics, probability theory, and theoretical computer
science. On general graphs, this problem is computationally hard, and this
hardness holds at arbitrarily low temperatures. At the same time, in recent
years, there has been significant progress showing the existence of
low-temperature sampling algorithms in various specific families of graphs. Our
aim in this paper is to understand the minimal structural properties of general
graphs that enable polynomial-time sampling from the $q$-state ferromagnetic
Potts model at low temperatures. We study this problem from the perspective of
the widely-used Swendsen--Wang dynamics and the closely related random-cluster
dynamics.
</p>
<p>Our results demonstrate that the key graph property behind fast or slow
convergence time for these dynamics is whether the independent edge-percolation
on the graph admits a strongly supercritical phase. By this, we mean that at
large $p&lt;1$, it has a unique giant component of linear size, and the complement
of that giant component is comprised of only small components. Specifically, we
prove that such a condition implies fast mixing of the Swendsen--Wang and
random-cluster dynamics on two general families of bounded-degree graphs: (a)
graphs of at most stretched-exponential volume growth and (b) locally treelike
graphs. In the other direction, we show that, even among graphs in those
families, these Markov chains can converge exponentially slowly at arbitrarily
low temperatures if the edge-percolation condition does not hold. In the
process, we develop new tools for the analysis of non-local Markov chains,
including a framework to bound the speed of disagreement propagation in the
presence of long-range correlations, and an understanding of spatial mixing
properties on trees with random boundary conditions.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/math/1/au:+Blanca_A/0/1/0/all/0/1">Antonio Blanca</a>, <a href="http://arxiv.org/find/math/1/au:+Gheissari_R/0/1/0/all/0/1">Reza Gheissari</a></p><p>Sampling from the $q$-state ferromagnetic Potts model is a fundamental
question in statistical physics, probability theory, and theoretical computer
science. On general graphs, this problem is computationally hard, and this
hardness holds at arbitrarily low temperatures. At the same time, in recent
years, there has been significant progress showing the existence of
low-temperature sampling algorithms in various specific families of graphs. Our
aim in this paper is to understand the minimal structural properties of general
graphs that enable polynomial-time sampling from the $q$-state ferromagnetic
Potts model at low temperatures. We study this problem from the perspective of
the widely-used Swendsen--Wang dynamics and the closely related random-cluster
dynamics.
</p>
<p>Our results demonstrate that the key graph property behind fast or slow
convergence time for these dynamics is whether the independent edge-percolation
on the graph admits a strongly supercritical phase. By this, we mean that at
large $p&lt;1$, it has a unique giant component of linear size, and the complement
of that giant component is comprised of only small components. Specifically, we
prove that such a condition implies fast mixing of the Swendsen--Wang and
random-cluster dynamics on two general families of bounded-degree graphs: (a)
graphs of at most stretched-exponential volume growth and (b) locally treelike
graphs. In the other direction, we show that, even among graphs in those
families, these Markov chains can converge exponentially slowly at arbitrarily
low temperatures if the edge-percolation condition does not hold. In the
process, we develop new tools for the analysis of non-local Markov chains,
including a framework to bound the speed of disagreement propagation in the
presence of long-range correlations, and an understanding of spatial mixing
properties on trees with random boundary conditions.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-07T00:30:00Z">Friday, April 07 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.03191'>Krylov Methods are (nearly) Optimal for Low-Rank Approximation</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Ainesh Bakshi, Shyam Narayanan</p><p>We consider the problem of rank-$1$ low-rank approximation (LRA) in the
matrix-vector product model under various Schatten norms: $$
</p>
<p>\min_{\|u\|_2=1} \|A (I - u u^\top)\|_{\mathcal{S}_p} , $$ where
$\|M\|_{\mathcal{S}_p}$ denotes the $\ell_p$ norm of the singular values of
$M$. Given $\varepsilon&gt;0$, our goal is to output a unit vector $v$ such that
$$
</p>
<p>\|A(I - vv^\top)\|_{\mathcal{S}_p} \leq (1+\varepsilon) \min_{\|u\|_2=1}\|A(I
- u u^\top)\|_{\mathcal{S}_p}. $$ Our main result shows that Krylov methods
(nearly) achieve the information-theoretically optimal number of matrix-vector
products for Spectral ($p=\infty$), Frobenius ($p=2$) and Nuclear ($p=1$) LRA.
</p>
<p>In particular, for Spectral LRA, we show that any algorithm requires
$\Omega\left(\log(n)/\varepsilon^{1/2}\right)$ matrix-vector products, exactly
matching the upper bound obtained by Krylov methods [MM15, BCW22]. Our lower
bound addresses Open Question 1 in [Woo14], providing evidence for the lack of
progress on algorithms for Spectral LRA and resolves Open Question 1.2 in
[BCW22]. Next, we show that for any fixed constant $p$, i.e. $1\leq p =O(1)$,
there is an upper bound of
$O\left(\log(1/\varepsilon)/\varepsilon^{1/3}\right)$ matrix-vector products,
implying that the complexity does not grow as a function of input size. This
improves the $O\left(\log(n/\varepsilon)/\varepsilon^{1/3}\right)$ bound
recently obtained in [BCW22], and matches their
$\Omega\left(1/\varepsilon^{1/3}\right)$ lower bound, to a
$\log(1/\varepsilon)$ factor.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Bakshi_A/0/1/0/all/0/1">Ainesh Bakshi</a>, <a href="http://arxiv.org/find/cs/1/au:+Narayanan_S/0/1/0/all/0/1">Shyam Narayanan</a></p><p>We consider the problem of rank-$1$ low-rank approximation (LRA) in the
matrix-vector product model under various Schatten norms: $$
</p>
<p>\min_{\|u\|_2=1} \|A (I - u u^\top)\|_{\mathcal{S}_p} , $$ where
$\|M\|_{\mathcal{S}_p}$ denotes the $\ell_p$ norm of the singular values of
$M$. Given $\varepsilon&gt;0$, our goal is to output a unit vector $v$ such that
$$
</p>
<p>\|A(I - vv^\top)\|_{\mathcal{S}_p} \leq (1+\varepsilon) \min_{\|u\|_2=1}\|A(I
- u u^\top)\|_{\mathcal{S}_p}. $$ Our main result shows that Krylov methods
(nearly) achieve the information-theoretically optimal number of matrix-vector
products for Spectral ($p=\infty$), Frobenius ($p=2$) and Nuclear ($p=1$) LRA.
</p>
<p>In particular, for Spectral LRA, we show that any algorithm requires
$\Omega\left(\log(n)/\varepsilon^{1/2}\right)$ matrix-vector products, exactly
matching the upper bound obtained by Krylov methods [MM15, BCW22]. Our lower
bound addresses Open Question 1 in [Woo14], providing evidence for the lack of
progress on algorithms for Spectral LRA and resolves Open Question 1.2 in
[BCW22]. Next, we show that for any fixed constant $p$, i.e. $1\leq p =O(1)$,
there is an upper bound of
$O\left(\log(1/\varepsilon)/\varepsilon^{1/3}\right)$ matrix-vector products,
implying that the complexity does not grow as a function of input size. This
improves the $O\left(\log(n/\varepsilon)/\varepsilon^{1/3}\right)$ bound
recently obtained in [BCW22], and matches their
$\Omega\left(1/\varepsilon^{1/3}\right)$ lower bound, to a
$\log(1/\varepsilon)$ factor.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-07T00:30:00Z">Friday, April 07 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.03233'>Parameterized algorithms for Eccentricity Shortest Path Problem</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Sriram Bhyravarapu, Satyabrata Jana, Lawqueen Kanesh, Saket Saurabh, Shaily Verma</p><p>Given an undirected graph $G=(V,E)$ and an integer $\ell$, the Eccentricity
Shortest Path (ESP) asks to find a shortest path $P$ such that for every vertex
$v\in V(G)$, there is a vertex $w\in P$ such that $d_G(v,w)\leq \ell$, where
$d_G(v,w)$ represents the distance between $v$ and $w$ in $G$. Dragan and
Leitert [Theor. Comput. Sci. 2017] showed that the optimization version of this
problem, which asks to find the minimum $\ell$ for the ESP problem, is NP-hard
even on planar bipartite graphs with maximum degree 3. They also showed that
ESP is W[2]-hard when parameterized by $\ell$. On the positive side, Ku\v cera
and Such\'y [IWOCA 2021] showed that the problem exhibits fixed parameter
tractable (FPT) behavior when parameterized by modular width, cluster vertex
deletion set, maximum leaf number, or the combined parameters disjoint paths
deletion set and $\ell$. It was asked as an open question in the above paper,
if ESP is FPT parameterized by disjoint paths deletion set or feedback vertex
set. We answer these questions partially and obtain the following results: -
ESP is FPT when parameterized by disjoint paths deletion set, split vertex
deletion set or the combined parameters feedback vertex set and eccentricity of
the graph. - We design a $(1+\epsilon)$-factor FPT approximation algorithm when
parameterized by the feedback vertex set number. - ESP is W[2]-hard when
parameterized by the chordal vertex deletion set.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Bhyravarapu_S/0/1/0/all/0/1">Sriram Bhyravarapu</a>, <a href="http://arxiv.org/find/cs/1/au:+Jana_S/0/1/0/all/0/1">Satyabrata Jana</a>, <a href="http://arxiv.org/find/cs/1/au:+Kanesh_L/0/1/0/all/0/1">Lawqueen Kanesh</a>, <a href="http://arxiv.org/find/cs/1/au:+Saurabh_S/0/1/0/all/0/1">Saket Saurabh</a>, <a href="http://arxiv.org/find/cs/1/au:+Verma_S/0/1/0/all/0/1">Shaily Verma</a></p><p>Given an undirected graph $G=(V,E)$ and an integer $\ell$, the Eccentricity
Shortest Path (ESP) asks to find a shortest path $P$ such that for every vertex
$v\in V(G)$, there is a vertex $w\in P$ such that $d_G(v,w)\leq \ell$, where
$d_G(v,w)$ represents the distance between $v$ and $w$ in $G$. Dragan and
Leitert [Theor. Comput. Sci. 2017] showed that the optimization version of this
problem, which asks to find the minimum $\ell$ for the ESP problem, is NP-hard
even on planar bipartite graphs with maximum degree 3. They also showed that
ESP is W[2]-hard when parameterized by $\ell$. On the positive side, Ku\v cera
and Such\'y [IWOCA 2021] showed that the problem exhibits fixed parameter
tractable (FPT) behavior when parameterized by modular width, cluster vertex
deletion set, maximum leaf number, or the combined parameters disjoint paths
deletion set and $\ell$. It was asked as an open question in the above paper,
if ESP is FPT parameterized by disjoint paths deletion set or feedback vertex
set. We answer these questions partially and obtain the following results: -
ESP is FPT when parameterized by disjoint paths deletion set, split vertex
deletion set or the combined parameters feedback vertex set and eccentricity of
the graph. - We design a $(1+\epsilon)$-factor FPT approximation algorithm when
parameterized by the feedback vertex set number. - ESP is W[2]-hard when
parameterized by the chordal vertex deletion set.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-07T00:30:00Z">Friday, April 07 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    
    <h2 class='tr-new-date'>
      <i class='fa-regular fa-calendar'></i> Thursday, April 06
    </h2>
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='https://cstheory-jobs.org/2023/04/06/phd-postdoc-at-goethe-university-frankfurt-germany-apply-by-june-16-2023/'>PhD / Postdoc at Goethe University Frankfurt, Germany (apply by June 16, 2023)</a></h3>
        <p class='tr-article-feed'>from <a href='https://cstheory-jobs.org'>CCI: jobs</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          Fully-funded PhD or Postdoc position in “Parameterized Complexity of Network Dynamics” to be carried out under the supervision of Prof. Holger Dell. The 3-year research project at the intersection of parameterized complexity, statistical physics, and graph theory involves the rigorous analysis of dynamic processes on graphs, such as virus or fake news spreading through a [&#8230;]
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p>Fully-funded PhD or Postdoc position in “Parameterized Complexity of Network Dynamics” to be carried out under the supervision of Prof. Holger Dell. The 3-year research project at the intersection of parameterized complexity, statistical physics, and graph theory involves the rigorous analysis of dynamic processes on graphs, such as virus or fake news spreading through a social network.</p>
<p>Website: <a href="https://tcs.uni-frankfurt.de/positions/">https://tcs.uni-frankfurt.de/positions/</a><br />
Email: tcs-applications@dlist.uni-frankfurt.de</p>
<p class="authors">By shacharlovett</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-06T09:13:46Z">Thursday, April 06 2023, 09:13</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='https://rjlipton.wpcomstaging.com/2023/04/06/neil-jones-1941-2023/'>Neil Jones, 1941–2023</a></h3>
        <p class='tr-article-feed'>from <a href='https://rjlipton.wpcomstaging.com'>Richard Lipton</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          Neil Jones, sad to relate, just passed away. He was Professor Emeritus of Computer Science at the University of Copenhagen, which he joined on a permanent basis in 1982 after gaining tenure at Penn State and a full professorship at the University of Kansas. Eric Allender wrote a post on Neil for Lance Fortnow&#8217;s and [&#8230;]
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p>
Neil Jones, sad to relate, just passed away. He was Professor Emeritus of Computer Science at the University of Copenhagen, which he joined on a permanent basis in 1982 after gaining tenure at Penn State and a full professorship at the University of Kansas. </p>
<p><P><br />
<a href="https://rjlipton.wpcomstaging.com/2023/04/06/neil-jones-1941-2023/neil-d-jones-60-aar/" rel="attachment wp-att-21404"><img data-attachment-id="21404" data-permalink="https://rjlipton.wpcomstaging.com/2023/04/06/neil-jones-1941-2023/neil-d-jones-60-aar/" data-orig-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/04/nj.jpeg?fit=1312%2C2000&amp;ssl=1" data-orig-size="1312,2000" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;JENS ASTRUP&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;NEIL D. JONES FRA DATALOGISK INSTITUT I KBH\r\rBILLEDET KAN FRIT ANVENDES TIL OMTALE AF HANS 60 AARS  DAG&quot;,&quot;created_timestamp&quot;:&quot;&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;NEIL D. JONES 60 AAR&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="NEIL D. JONES 60 AAR" data-image-description="" data-image-caption="&lt;p&gt;NEIL D. JONES FRA DATALOGISK INSTITUT I KBH&lt;/p&gt;
&lt;p&gt;BILLEDET KAN FRIT ANVENDES TIL OMTALE AF HANS 60 AARS  DAG&lt;/p&gt;
" data-medium-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/04/nj.jpeg?fit=197%2C300&amp;ssl=1" data-large-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/04/nj.jpeg?fit=600%2C914&amp;ssl=1" decoding="async" loading="lazy" src="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/04/nj.jpeg?resize=200%2C305&#038;ssl=1" alt="" width="200" height="305" class="aligncenter wp-image-21404" srcset="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/04/nj.jpeg?resize=672%2C1024&amp;ssl=1 672w, https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/04/nj.jpeg?resize=197%2C300&amp;ssl=1 197w, https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/04/nj.jpeg?resize=768%2C1171&amp;ssl=1 768w, https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/04/nj.jpeg?resize=1008%2C1536&amp;ssl=1 1008w, https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/04/nj.jpeg?resize=1200%2C1829&amp;ssl=1 1200w, https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/04/nj.jpeg?w=1312&amp;ssl=1 1312w" sizes="(max-width: 200px) 100vw, 200px" data-recalc-dims="1" /></a> </p>
<p><P><br />
Eric Allender wrote a <a href="https://blog.computationalcomplexity.org">post</a> on Neil for Lance Fortnow&#8217;s and Bill Gasarch&#8217;s famous blog. We point to it, hopefully with their full approval, and add some supplementary remarks. Eric&#8217;s tribute leads with Jones&#8217;s work with Alan Selman characterizing logical spectra via languages in nondeterministic <img decoding="async" src="https://s0.wp.com/latex.php?latex=%7B2%5E%7BO%28n%29%7D%7D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002" alt="{2^{O(n)}}" class="latex" /> time. He quotes remarks by D. Sivakumar that echo what Siva wrote for our <a href="https://rjlipton.wpcomstaging.com/2021/01/29/alan-selman-1941-2021/">memorial</a> to Alan.</p>
<p>
<p><H2> The Space Problem </H2></p>
<p><p>
Steve Cook and Dick Karp started the quest to understand <img decoding="async" src="https://s0.wp.com/latex.php?latex=%7B%5Cmathsf%7BP+%3D+NP%7D%7D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002" alt="{&#92;mathsf{P = NP}}" class="latex" />? What many including Neil have always considered the &#8220;second big problem&#8221; involves the power of space rather than nondeterminism, specifically: is <img decoding="async" src="https://s0.wp.com/latex.php?latex=%7B%5Cmathsf%7BLOGSPACE+%3D+PTIME%7D%7D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002" alt="{&#92;mathsf{LOGSPACE = PTIME}}" class="latex" />? Neil, like the rest of us, had his thoughts on the conjecture that they are different, but like the rest of us, did not know for sure. His thoughts on the subject ranged from <a href="https://dblp.uni-trier.de/rec/journals/jcss/Jones75.html">two</a> early <a href="https://dl.acm.org/doi/pdf/10.1145/800119.803883">papers</a> to the last <a href="https://arxiv.org/pdf/2008.02932.pdf">paper</a> on his DBLP page. </p>
<p>
This last paper is joint with Siddharth Bhaskar, Cynthia Kop, and Jakob Simonsen, and is titled, &#8220;Cons-free Programs and Complexity Classes between LOGSPACE and PTIME.&#8221; It appeared at the 2020 joint meeting of the Horn Clauses for Verification and Synthesis (HCVS) and Verification and Program Transformation (VPT) workshops. They call a program &#8220;cons-free&#8221; if it does not allow agglutination of data, not by <FONT SIZE="+1"><tt>cons</tt></FONT> with lists, nor successor, +, or * with integers, nor any allocator of storage. They further consider constraining recursion so as not to mushroom by mandating certain forms of tail recursion. Problems decided by cons-free programs form the class &#8220;<img decoding="async" src="https://s0.wp.com/latex.php?latex=%7B%5Cmathsf%7BCF%7D%7D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002" alt="{&#92;mathsf{CF}}" class="latex" />&#8221; and those further having only tail recursion, &#8220;<img decoding="async" src="https://s0.wp.com/latex.php?latex=%7B%5Cmathsf%7BCFTR%7D%7D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002" alt="{&#92;mathsf{CFTR}}" class="latex" />.&#8221;</p>
<p>
This use of functional languages represents both a more modern viewpoint&#8212;than how complexity was founded on Turing machines in the 1960s&#8212;and an older one, insofar as Lisp and other ideas of functional languages were fertile before the 1960s. They characterize <img decoding="async" src="https://s0.wp.com/latex.php?latex=%7B%5Cmathsf%7BP+%3D+CF%7D%7D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002" alt="{&#92;mathsf{P = CF}}" class="latex" /> and <img decoding="async" src="https://s0.wp.com/latex.php?latex=%7B%5Cmathsf%7BLOGSPACE+%3D+CFTR%7D%7D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002" alt="{&#92;mathsf{LOGSPACE = CFTR}}" class="latex" /> as their form also constraining recursion. The former holds some surprise as the cons-free programs are allowed to run for exponential time. If they are constrained to run in polynomial time, a class intermediate between <img decoding="async" src="https://s0.wp.com/latex.php?latex=%7B%5Cmathsf%7BLOGSPACE%7D%7D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002" alt="{&#92;mathsf{LOGSPACE}}" class="latex" /> and <img decoding="async" src="https://s0.wp.com/latex.php?latex=%7B%5Cmathsf%7BP%7D%7D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002" alt="{&#92;mathsf{P}}" class="latex" /> emerges. Is it equivalent to a known class? They leave that open.</p>
<p>
<p><H2> Non-Turing Time </H2></p>
<p><p>
Jones&#8217;s work on other models besides Turing machines caught my attention 30 years ago&#8212;this is Ken writing this section. I was interested in models that have a constant-factor time overhead for universal simulation <img decoding="async" src="https://s0.wp.com/latex.php?latex=%7BU%7D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002" alt="{U}" class="latex" /> of any other machine <img decoding="async" src="https://s0.wp.com/latex.php?latex=%7BM%7D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002" alt="{M}" class="latex" />, in contrast to the standard multitape Turing machine model where <img decoding="async" src="https://s0.wp.com/latex.php?latex=%7BU%7D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002" alt="{U}" class="latex" /> incurs an <img decoding="async" src="https://s0.wp.com/latex.php?latex=%7BO%28%5Clog+t%29%7D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002" alt="{O(&#92;log t)}" class="latex" /> time overhead for simulating <img decoding="async" src="https://s0.wp.com/latex.php?latex=%7Bt%7D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002" alt="{t}" class="latex" /> steps of machines <img decoding="async" src="https://s0.wp.com/latex.php?latex=%7BM%7D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002" alt="{M}" class="latex" /> with more tapes than <img decoding="async" src="https://s0.wp.com/latex.php?latex=%7BU%7D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002" alt="{U}" class="latex" /> has. This <img decoding="async" src="https://s0.wp.com/latex.php?latex=%7B%5Clog+t%7D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002" alt="{&#92;log t}" class="latex" /> factor also shows up in the deterministic time hierarchy theorem, though for natural instances it can be shaved down to <img decoding="async" src="https://s0.wp.com/latex.php?latex=%7BO%28%5Clog+t%29%5E%5Cepsilon%7D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002" alt="{O(&#92;log t)^&#92;epsilon}" class="latex" /> for any fixed <img decoding="async" src="https://s0.wp.com/latex.php?latex=%7B%5Cepsilon%7D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002" alt="{&#92;epsilon}" class="latex" /> by techniques of <em>padding and translation</em>. </p>
<p>
Martin F&uuml;rer had <a href="https://dl.acm.org/doi/10.1145/800070.802172">shown</a> that when <img decoding="async" src="https://s0.wp.com/latex.php?latex=%7Bk%7D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002" alt="{k}" class="latex" /> is fixed, the log factor goes away. I was interested in leveraging random-access models that have constant-factor overhead while imposing locality restrictions on the random access. The resulting time hierarchy theorems are only &#8220;tight&#8221; in the sense of needing <img decoding="async" src="https://s0.wp.com/latex.php?latex=%7Bt_1%28n%29+%3D+o%28t_2%28n%29%29%7D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002" alt="{t_1(n) = o(t_2(n))}" class="latex" />&#8212;in order to construct a language decidable in time <img decoding="async" src="https://s0.wp.com/latex.php?latex=%7Bt_2%28n%29%7D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002" alt="{t_2(n)}" class="latex" /> but not in time <img decoding="async" src="https://s0.wp.com/latex.php?latex=%7BO%28t_1%28n%29%29%7D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002" alt="{O(t_1(n))}" class="latex" />.</p>
<p>
Jones went this one better by building a natural programming-based model that has a time hierarchy for a <em>fixed</em> constant factor. His STOC 1993 <a href="https://dl.acm.org/doi/pdf/10.1145/167088.167244">paper</a> was titled, &#8220;Constant Time Factors <em>Do</em> Matter&#8221; with italics on the <em>Do</em>. This grew into a <a href="https://link.springer.com/article/10.1007/s002360000038">paper</a> in <em>Acta Informatica</em> 2000 with Amir Ben-Amram. It also became the basis for his 1997 <a href="https://www.amazon.com/Computability-Complexity-Programming-Perspective-Foundations/dp/0262100649">textbook</a>, <em>Computability and Complexity: From a Programming Perspective</em>. </p>
<p>
The prominence of &#8220;<img decoding="async" src="https://s0.wp.com/latex.php?latex=%7B%5Cmathsf%7BP+%3D+NP%7D%7D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002" alt="{&#92;mathsf{P = NP}}" class="latex" />?&#8221; masks that our lack of knowledge of lower bounds takes effect at linear time. For circuit models the status is even worse: we still have not refuted the possibility that every language in deterministic <img decoding="async" src="https://s0.wp.com/latex.php?latex=%7B2%5E%7BO%28n%29%7D%7D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002" alt="{2^{O(n)}}" class="latex" /> time has (possibly nonuniform) <img decoding="async" src="https://s0.wp.com/latex.php?latex=%7BO%28n%29%7D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002" alt="{O(n)}" class="latex" />-sized circuits. I thought that a new kind of super-linear lower bound could get a grip on peeling the end of a coiled tape that might then freely unroll. As with <img decoding="async" src="https://s0.wp.com/latex.php?latex=%7B%5Cmathsf%7BP%7D%7D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002" alt="{&#92;mathsf{P}}" class="latex" /> versus <img decoding="async" src="https://s0.wp.com/latex.php?latex=%7B%5Cmathsf%7BLOGSPACE%7D%7D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002" alt="{&#92;mathsf{LOGSPACE}}" class="latex" />, however, getting such a grip remains open.</p>
<p>
<p><H2> Open Problems </H2></p>
<p><p>
I&#8212;Dick again&#8212;worked on related stuff in a 1979 <a href="https://www2.eecs.berkeley.edu/Pubs/TechRpts/1979/ERL-m-79-54.pdf">paper</a> that had a cast of famous brilliant scholars: &#8220;Random Walks, Universal Traversal Sequences, and the Complexity of Maze Problems&#8221;&#8212;by Romas Aleliunas, Dick Karp, me, Laci Lovasz, and Charlie Rackoff. There were ways to build off this to greater results, particularly Omer Reingold&#8217;s blending-in of Irit Dinur&#8217;s PCP proof technique to <a href="https://omereingold.files.wordpress.com/2014/10/sl.pdf">show</a> that undirected maze problems belong to deterministic logspace. Is there a way to build more off Neil&#8217;s results&#8212;the newer and the older ones?</p>
<p>
<p class="authors">By RJLipton+KWRegan</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-06T04:03:23Z">Thursday, April 06 2023, 04:03</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.02358'>Visualizing Quantum Circuit Probability -- estimating computational action for quantum program synthesis</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Bao Gia Bach, Akash Kundu, Tamal Acharya, Aritra Sarkar</p><p>This research applies concepts from algorithmic probability to Boolean and
quantum combinatorial logic circuits. A tutorial-style introduction to states
and various notions of the complexity of states are presented. Thereafter, the
probability of states in the circuit model of computation is defined. Classical
and quantum gate sets are compared to select some characteristic sets. The
reachability and expressibility in a space-time-bounded setting for these gate
sets are enumerated and visualized. These results are studied in terms of
computational resources, universality and quantum behavior. The article
suggests how applications like geometric quantum machine learning, novel
quantum algorithm synthesis and quantum artificial general intelligence can
benefit by studying circuit probabilities.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/quant-ph/1/au:+Bach_B/0/1/0/all/0/1">Bao Gia Bach</a>, <a href="http://arxiv.org/find/quant-ph/1/au:+Kundu_A/0/1/0/all/0/1">Akash Kundu</a>, <a href="http://arxiv.org/find/quant-ph/1/au:+Acharya_T/0/1/0/all/0/1">Tamal Acharya</a>, <a href="http://arxiv.org/find/quant-ph/1/au:+Sarkar_A/0/1/0/all/0/1">Aritra Sarkar</a></p><p>This research applies concepts from algorithmic probability to Boolean and
quantum combinatorial logic circuits. A tutorial-style introduction to states
and various notions of the complexity of states are presented. Thereafter, the
probability of states in the circuit model of computation is defined. Classical
and quantum gate sets are compared to select some characteristic sets. The
reachability and expressibility in a space-time-bounded setting for these gate
sets are enumerated and visualized. These results are studied in terms of
computational resources, universality and quantum behavior. The article
suggests how applications like geometric quantum machine learning, novel
quantum algorithm synthesis and quantum artificial general intelligence can
benefit by studying circuit probabilities.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-06T00:30:00Z">Thursday, April 06 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.02524'>Picturing counting reductions with the ZH-calculus</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Tuomas Laakkonen, Konstantinos Meichanetzidis, John van de Wetering</p><p>Counting the solutions to Boolean formulae defines the problem #SAT, which is
complete for the complexity class #P. We use the ZH-calculus, a universal and
complete graphical language for linear maps which naturally encodes counting
problems in terms of diagrams, to give graphical reductions from #SAT to
several related counting problems. Some of these graphical reductions, like to
#2SAT, are substantially simpler than known reductions via the matrix
permanent. Additionally, our approach allows us to consider the case of
counting solutions modulo an integer on equal footing. Finally, since the
ZH-calculus was originally introduced to reason about quantum computing, we
show that the problem of evaluating ZH-diagrams in the fragment corresponding
to the Clifford+T gateset, is in $FP^{\#P}$. Our results show that graphical
calculi represent an intuitive and useful framework for reasoning about
counting problems.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Laakkonen_T/0/1/0/all/0/1">Tuomas Laakkonen</a>, <a href="http://arxiv.org/find/cs/1/au:+Meichanetzidis_K/0/1/0/all/0/1">Konstantinos Meichanetzidis</a>, <a href="http://arxiv.org/find/cs/1/au:+Wetering_J/0/1/0/all/0/1">John van de Wetering</a></p><p>Counting the solutions to Boolean formulae defines the problem #SAT, which is
complete for the complexity class #P. We use the ZH-calculus, a universal and
complete graphical language for linear maps which naturally encodes counting
problems in terms of diagrams, to give graphical reductions from #SAT to
several related counting problems. Some of these graphical reductions, like to
#2SAT, are substantially simpler than known reductions via the matrix
permanent. Additionally, our approach allows us to consider the case of
counting solutions modulo an integer on equal footing. Finally, since the
ZH-calculus was originally introduced to reason about quantum computing, we
show that the problem of evaluating ZH-diagrams in the fragment corresponding
to the Clifford+T gateset, is in $FP^{\#P}$. Our results show that graphical
calculi represent an intuitive and useful framework for reasoning about
counting problems.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-06T00:30:00Z">Thursday, April 06 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.02555'>Top-Down Lower Bounds for Depth-Four Circuits</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Mika G&#xf6;&#xf6;s, Artur Riazanov, Anastasia Sofronova, Dmitry Sokolov</p><p>We present a top-down lower-bound method for depth-$4$ boolean circuits. In
particular, we give a new proof of the well-known result that the parity
function requires depth-$4$ circuits of size exponential in $n^{1/3}$. Our
proof is an application of robust sunflowers and block unpredictability.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Goos_M/0/1/0/all/0/1">Mika G&#xf6;&#xf6;s</a>, <a href="http://arxiv.org/find/cs/1/au:+Riazanov_A/0/1/0/all/0/1">Artur Riazanov</a>, <a href="http://arxiv.org/find/cs/1/au:+Sofronova_A/0/1/0/all/0/1">Anastasia Sofronova</a>, <a href="http://arxiv.org/find/cs/1/au:+Sokolov_D/0/1/0/all/0/1">Dmitry Sokolov</a></p><p>We present a top-down lower-bound method for depth-$4$ boolean circuits. In
particular, we give a new proof of the well-known result that the parity
function requires depth-$4$ circuits of size exponential in $n^{1/3}$. Our
proof is an application of robust sunflowers and block unpredictability.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-06T00:30:00Z">Thursday, April 06 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.02207'>Algorithm and Hardness for Dynamic Attention Maintenance in Large Language Models</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Jan van den Brand, Zhao Song, Tianyi Zhou</p><p>Large language models (LLMs) have made fundamental changes in human life. The
attention scheme is one of the key components over all the LLMs, such as BERT,
GPT-1, Transformers, GPT-2, 3, 3.5 and 4. Inspired by previous theoretical
study of static version of the attention multiplication problem [Zandieh, Han,
Daliri, and Karbasi arXiv 2023, Alman and Song arXiv 2023]. In this work, we
formally define a dynamic version of attention matrix multiplication problem.
There are matrices $Q,K, V \in \mathbb{R}^{n \times d}$, they represent query,
key and value in LLMs. In each iteration we update one entry in $K$ or $V$. In
the query stage, we receive $(i,j) \in [n] \times [d]$ as input, and want to
answer $(D^{-1} A V)_{i,j}$, where $A:=\exp(QK^\top) \in \mathbb{R}^{n \times
n}$ is a square matrix and $D := \mathrm{diag}(A {\bf 1}_n) \in \mathbb{R}^{n
\times n}$ is a diagonal matrix. Here ${\bf 1}_n$ denote a length-$n$ vector
that all the entries are ones.
</p>
<p>We provide two results: an algorithm and a conditional lower bound.
</p>
<p>$\bullet$ On one hand, inspired by the lazy update idea from [Demetrescu and
Italiano FOCS 2000, Sankowski FOCS 2004, Cohen, Lee and Song STOC 2019, Brand
SODA 2020], we provide a data-structure that uses
$O(n^{\omega(1,1,\tau)-\tau})$ amortized update time, and $O(n^{1+\tau})$
worst-case query time.
</p>
<p>$\bullet$ On the other hand, show that unless the hinted matrix vector
multiplication conjecture [Brand, Nanongkai and Saranurak FOCS 2019] is false,
there is no algorithm that can use both $O(n^{\omega(1,1,\tau) - \tau-
\Omega(1)})$ amortized update time, and $O(n^{1+\tau-\Omega(1)})$ worst query
time.
</p>
<p>In conclusion, our algorithmic result is conditionally optimal unless hinted
matrix vector multiplication conjecture is false.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Brand_J/0/1/0/all/0/1">Jan van den Brand</a>, <a href="http://arxiv.org/find/cs/1/au:+Song_Z/0/1/0/all/0/1">Zhao Song</a>, <a href="http://arxiv.org/find/cs/1/au:+Zhou_T/0/1/0/all/0/1">Tianyi Zhou</a></p><p>Large language models (LLMs) have made fundamental changes in human life. The
attention scheme is one of the key components over all the LLMs, such as BERT,
GPT-1, Transformers, GPT-2, 3, 3.5 and 4. Inspired by previous theoretical
study of static version of the attention multiplication problem [Zandieh, Han,
Daliri, and Karbasi arXiv 2023, Alman and Song arXiv 2023]. In this work, we
formally define a dynamic version of attention matrix multiplication problem.
There are matrices $Q,K, V \in \mathbb{R}^{n \times d}$, they represent query,
key and value in LLMs. In each iteration we update one entry in $K$ or $V$. In
the query stage, we receive $(i,j) \in [n] \times [d]$ as input, and want to
answer $(D^{-1} A V)_{i,j}$, where $A:=\exp(QK^\top) \in \mathbb{R}^{n \times
n}$ is a square matrix and $D := \mathrm{diag}(A {\bf 1}_n) \in \mathbb{R}^{n
\times n}$ is a diagonal matrix. Here ${\bf 1}_n$ denote a length-$n$ vector
that all the entries are ones.
</p>
<p>We provide two results: an algorithm and a conditional lower bound.
</p>
<p>$\bullet$ On one hand, inspired by the lazy update idea from [Demetrescu and
Italiano FOCS 2000, Sankowski FOCS 2004, Cohen, Lee and Song STOC 2019, Brand
SODA 2020], we provide a data-structure that uses
$O(n^{\omega(1,1,\tau)-\tau})$ amortized update time, and $O(n^{1+\tau})$
worst-case query time.
</p>
<p>$\bullet$ On the other hand, show that unless the hinted matrix vector
multiplication conjecture [Brand, Nanongkai and Saranurak FOCS 2019] is false,
there is no algorithm that can use both $O(n^{\omega(1,1,\tau) - \tau-
\Omega(1)})$ amortized update time, and $O(n^{1+\tau-\Omega(1)})$ worst query
time.
</p>
<p>In conclusion, our algorithmic result is conditionally optimal unless hinted
matrix vector multiplication conjecture is false.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-06T00:30:00Z">Thursday, April 06 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.02063'>Set Covering with Our Eyes Wide Shut</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Anupam Gupta, Gregory Kehne, Roie Levin</p><p>In the stochastic set cover problem (Grandoni et al., FOCS '08), we are given
a collection $\mathcal{S}$ of $m$ sets over a universe $\mathcal{U}$ of size
$N$, and a distribution $D$ over elements of $\mathcal{U}$. The algorithm draws
$n$ elements one-by-one from $D$ and must buy a set to cover each element on
arrival; the goal is to minimize the total cost of sets bought during this
process. A universal algorithm a priori maps each element $u \in \mathcal{U}$
to a set $S(u)$ such that if $U \subseteq \mathcal{U}$ is formed by drawing $n$
times from distribution $D$, then the algorithm commits to outputting $S(U)$.
Grandoni et al. gave an $O(\log mN)$-competitive universal algorithm for this
stochastic set cover problem.
</p>
<p>We improve unilaterally upon this result by giving a simple, polynomial time
$O(\log mn)$-competitive universal algorithm for the more general prophet
version, in which $U$ is formed by drawing from $n$ different distributions
$D_1, \ldots, D_n$. Furthermore, we show that we do not need full foreknowledge
of the distributions: in fact, a single sample from each distribution suffices.
We show similar results for the 2-stage prophet setting and for the
online-with-a-sample setting.
</p>
<p>We obtain our results via a generic reduction from the single-sample prophet
setting to the random-order setting; this reduction holds for a broad class of
minimization problems that includes all covering problems. We take advantage of
this framework by giving random-order algorithms for non-metric facility
location and set multicover; using our framework, these automatically translate
to universal prophet algorithms.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Gupta_A/0/1/0/all/0/1">Anupam Gupta</a>, <a href="http://arxiv.org/find/cs/1/au:+Kehne_G/0/1/0/all/0/1">Gregory Kehne</a>, <a href="http://arxiv.org/find/cs/1/au:+Levin_R/0/1/0/all/0/1">Roie Levin</a></p><p>In the stochastic set cover problem (Grandoni et al., FOCS '08), we are given
a collection $\mathcal{S}$ of $m$ sets over a universe $\mathcal{U}$ of size
$N$, and a distribution $D$ over elements of $\mathcal{U}$. The algorithm draws
$n$ elements one-by-one from $D$ and must buy a set to cover each element on
arrival; the goal is to minimize the total cost of sets bought during this
process. A universal algorithm a priori maps each element $u \in \mathcal{U}$
to a set $S(u)$ such that if $U \subseteq \mathcal{U}$ is formed by drawing $n$
times from distribution $D$, then the algorithm commits to outputting $S(U)$.
Grandoni et al. gave an $O(\log mN)$-competitive universal algorithm for this
stochastic set cover problem.
</p>
<p>We improve unilaterally upon this result by giving a simple, polynomial time
$O(\log mn)$-competitive universal algorithm for the more general prophet
version, in which $U$ is formed by drawing from $n$ different distributions
$D_1, \ldots, D_n$. Furthermore, we show that we do not need full foreknowledge
of the distributions: in fact, a single sample from each distribution suffices.
We show similar results for the 2-stage prophet setting and for the
online-with-a-sample setting.
</p>
<p>We obtain our results via a generic reduction from the single-sample prophet
setting to the random-order setting; this reduction holds for a broad class of
minimization problems that includes all covering problems. We take advantage of
this framework by giving random-order algorithms for non-metric facility
location and set multicover; using our framework, these automatically translate
to universal prophet algorithms.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-06T00:30:00Z">Thursday, April 06 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.02091'>Determinantal Sieving</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Eduard Eiben, Tomohiro Koana, Magnus Wahlstr&#xf6;m</p><p>We introduce determinantal sieving, a new, remarkably powerful tool in the
toolbox of algebraic FPT algorithms. Given a polynomial $P(X)$ on a set of
variables $X=\{x_1,\ldots,x_n\}$ and a linear matroid $M=(X,\mathcal{I})$ of
rank $k$, both over a field $\mathbb{F}$ of characteristic 2, in $2^k$
evaluations we can sieve for those terms in the monomial expansion of $P$ which
are multilinear and whose support is a basis for $M$. Alternatively, using
$2^k$ evaluations of $P$ we can sieve for those monomials whose odd support
spans $M$. Applying this framework, we improve on a range of algebraic FPT
algorithms, such as:
</p>
<p>1. Solving $q$-Matroid Intersection in time $O^*(2^{(q-2)k})$ and $q$-Matroid
Parity in time $O^*(2^{qk})$, improving on $O^*(4^{qk})$ (Brand and Pratt,
ICALP 2021)
</p>
<p>2. $T$-Cycle, Colourful $(s,t)$-Path, Colourful $(S,T)$-Linkage in undirected
graphs, and the more general Rank $k$ $(S,T)$-Linkage problem, all in
$O^*(2^k)$ time, improving on $O^*(2^{k+|S|})$ respectively $O^*(2^{|S|+O(k^2
\log(k+|\mathbb{F}|))})$ (Fomin et al., SODA 2023)
</p>
<p>3. Many instances of the Diverse X paradigm, finding a collection of $r$
solutions to a problem with a minimum mutual distance of $d$ in time
$O^*(2^{r(r-1)d/2})$, improving solutions for $k$-Distinct Branchings from time
$2^{O(k \log k)}$ to $O^*(2^k)$ (Bang-Jensen et al., ESA 2021), and for Diverse
Perfect Matchings from $O^*(2^{2^{O(rd)}})$ to $O^*(2^{r^2d/2})$ (Fomin et al.,
STACS 2021)
</p>
<p>All matroids are assumed to be represented over a field of characteristic 2.
Over general fields, we achieve similar results at the cost of using
exponential space by working over the exterior algebra. For a class of
arithmetic circuits we call strongly monotone, this is even achieved without
any loss of running time. However, the odd support sieving result appears to be
specific to working over characteristic 2.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Eiben_E/0/1/0/all/0/1">Eduard Eiben</a>, <a href="http://arxiv.org/find/cs/1/au:+Koana_T/0/1/0/all/0/1">Tomohiro Koana</a>, <a href="http://arxiv.org/find/cs/1/au:+Wahlstrom_M/0/1/0/all/0/1">Magnus Wahlstr&#xf6;m</a></p><p>We introduce determinantal sieving, a new, remarkably powerful tool in the
toolbox of algebraic FPT algorithms. Given a polynomial $P(X)$ on a set of
variables $X=\{x_1,\ldots,x_n\}$ and a linear matroid $M=(X,\mathcal{I})$ of
rank $k$, both over a field $\mathbb{F}$ of characteristic 2, in $2^k$
evaluations we can sieve for those terms in the monomial expansion of $P$ which
are multilinear and whose support is a basis for $M$. Alternatively, using
$2^k$ evaluations of $P$ we can sieve for those monomials whose odd support
spans $M$. Applying this framework, we improve on a range of algebraic FPT
algorithms, such as:
</p>
<p>1. Solving $q$-Matroid Intersection in time $O^*(2^{(q-2)k})$ and $q$-Matroid
Parity in time $O^*(2^{qk})$, improving on $O^*(4^{qk})$ (Brand and Pratt,
ICALP 2021)
</p>
<p>2. $T$-Cycle, Colourful $(s,t)$-Path, Colourful $(S,T)$-Linkage in undirected
graphs, and the more general Rank $k$ $(S,T)$-Linkage problem, all in
$O^*(2^k)$ time, improving on $O^*(2^{k+|S|})$ respectively $O^*(2^{|S|+O(k^2
\log(k+|\mathbb{F}|))})$ (Fomin et al., SODA 2023)
</p>
<p>3. Many instances of the Diverse X paradigm, finding a collection of $r$
solutions to a problem with a minimum mutual distance of $d$ in time
$O^*(2^{r(r-1)d/2})$, improving solutions for $k$-Distinct Branchings from time
$2^{O(k \log k)}$ to $O^*(2^k)$ (Bang-Jensen et al., ESA 2021), and for Diverse
Perfect Matchings from $O^*(2^{2^{O(rd)}})$ to $O^*(2^{r^2d/2})$ (Fomin et al.,
STACS 2021)
</p>
<p>All matroids are assumed to be represented over a field of characteristic 2.
Over general fields, we achieve similar results at the cost of using
exponential space by working over the exterior algebra. For a class of
arithmetic circuits we call strongly monotone, this is even achieved without
any loss of running time. However, the odd support sieving result appears to be
specific to working over characteristic 2.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-06T00:30:00Z">Thursday, April 06 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.02124'>The Bit Complexity of Efficient Continuous Optimization</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Mehrdad Ghadiri, Richard Peng, Santosh S. Vempala</p><p>We analyze the bit complexity of efficient algorithms for fundamental
optimization problems, such as linear regression, $p$-norm regression, and
linear programming (LP). State-of-the-art algorithms are iterative, and in
terms of the number of arithmetic operations, they match the current time
complexity of multiplying two $n$-by-$n$ matrices (up to polylogarithmic
factors). However, previous work has typically assumed infinite precision
arithmetic, and due to complicated inverse maintenance techniques, the actual
running times of these algorithms are unknown. To settle the running time and
bit complexity of these algorithms, we demonstrate that a core common
subroutine, known as \emph{inverse maintenance}, is backward-stable.
Additionally, we show that iterative approaches for solving constrained
weighted regression problems can be accomplished with bounded-error
pre-conditioners. Specifically, we prove that linear programs can be solved
approximately in matrix multiplication time multiplied by polylog factors that
depend on the condition number $\kappa$ of the matrix and the inner and outer
radius of the LP problem. $p$-norm regression can be solved approximately in
matrix multiplication time multiplied by polylog factors in $\kappa$. Lastly,
linear regression can be solved approximately in input-sparsity time multiplied
by polylog factors in $\kappa$. Furthermore, we present results for achieving
lower than matrix multiplication time for $p$-norm regression by utilizing
faster solvers for sparse linear systems.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Ghadiri_M/0/1/0/all/0/1">Mehrdad Ghadiri</a>, <a href="http://arxiv.org/find/cs/1/au:+Peng_R/0/1/0/all/0/1">Richard Peng</a>, <a href="http://arxiv.org/find/cs/1/au:+Vempala_S/0/1/0/all/0/1">Santosh S. Vempala</a></p><p>We analyze the bit complexity of efficient algorithms for fundamental
optimization problems, such as linear regression, $p$-norm regression, and
linear programming (LP). State-of-the-art algorithms are iterative, and in
terms of the number of arithmetic operations, they match the current time
complexity of multiplying two $n$-by-$n$ matrices (up to polylogarithmic
factors). However, previous work has typically assumed infinite precision
arithmetic, and due to complicated inverse maintenance techniques, the actual
running times of these algorithms are unknown. To settle the running time and
bit complexity of these algorithms, we demonstrate that a core common
subroutine, known as \emph{inverse maintenance}, is backward-stable.
Additionally, we show that iterative approaches for solving constrained
weighted regression problems can be accomplished with bounded-error
pre-conditioners. Specifically, we prove that linear programs can be solved
approximately in matrix multiplication time multiplied by polylog factors that
depend on the condition number $\kappa$ of the matrix and the inner and outer
radius of the LP problem. $p$-norm regression can be solved approximately in
matrix multiplication time multiplied by polylog factors in $\kappa$. Lastly,
linear regression can be solved approximately in input-sparsity time multiplied
by polylog factors in $\kappa$. Furthermore, we present results for achieving
lower than matrix multiplication time for $p$-norm regression by utilizing
faster solvers for sparse linear systems.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-06T00:30:00Z">Thursday, April 06 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.02141'>Sequential Linearithmic Time Optimal Unimodal Fitting When Minimizing Univariate Linear Losses</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Kaan Gokcesu, Hakan Gokcesu</p><p>This paper focuses on optimal unimodal transformation of the score outputs of
a univariate learning model under linear loss functions. We demonstrate that
the optimal mapping between score values and the target region is a rectangular
function. To produce this optimal rectangular fit for the observed samples, we
propose a sequential approach that can its estimation with each incoming new
sample. Our approach has logarithmic time complexity per iteration and is
optimally efficient.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Gokcesu_K/0/1/0/all/0/1">Kaan Gokcesu</a>, <a href="http://arxiv.org/find/cs/1/au:+Gokcesu_H/0/1/0/all/0/1">Hakan Gokcesu</a></p><p>This paper focuses on optimal unimodal transformation of the score outputs of
a univariate learning model under linear loss functions. We demonstrate that
the optimal mapping between score values and the target region is a rectangular
function. To produce this optimal rectangular fit for the observed samples, we
propose a sequential approach that can its estimation with each incoming new
sample. Our approach has logarithmic time complexity per iteration and is
optimally efficient.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-06T00:30:00Z">Thursday, April 06 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.02193'>Folklore Sampling is Optimal for Exact Hopsets: Confirming the $\sqrt{n}$ Barrier</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Greg Bodwin, Gary Hoppenworth</p><p>For a graph $G$, a $D$-diameter-reducing exact hopset is a small set of
additional edges $H$ that, when added to $G$, maintains its graph metric but
guarantees that all node pairs have a shortest path in $G \cup H$ using at most
$D$ edges. A shortcut set is the analogous concept for reachability. These
objects have been studied since the early '90s due to applications in parallel,
distributed, dynamic, and streaming graph algorithms.
</p>
<p>For most of their history, the state-of-the-art construction for either
object was a simple folklore algorithm, based on randomly sampling nodes to hit
long paths in the graph. However, recent breakthroughs of Kogan and Parter
[SODA '22] and Bernstein and Wein [SODA '23] have finally improved over the
folklore diameter bound of $\widetilde{O}(n^{1/2})$ for shortcut sets and for
$(1+\epsilon)$-approximate hopsets. For both objects it is now known that one
can use $O(n)$ hop-edges to reduce diameter to $\widetilde{O}(n^{1/3})$. The
only setting where folklore sampling remains unimproved is for exact hopsets.
Can these improvements be continued?
</p>
<p>We settle this question negatively by constructing graphs on which any exact
hopset of $O(n)$ edges has diameter $\widetilde{\Omega}(n^{1/2})$. This
improves on the previous lower bound of $\widetilde{\Omega}(n^{1/3})$ by Kogan
and Parter [FOCS '22]. Using similar ideas, we also polynomially improve the
current lower bounds for shortcut sets, constructing graphs on which any
shortcut set of $O(n)$ edges reduces diameter to $\widetilde{\Omega}(n^{1/4})$.
This improves on the previous lower bound of $\Omega(n^{1/6})$ by Huang and
Pettie [SIAM J. Disc. Math. '18]. We also extend our constructions to provide
lower bounds against $O(p)$-size exact hopsets and shortcut sets for other
values of $p$; in particular, we show that folklore sampling is near-optimal
for exact hopsets in the entire range of $p \in [1, n^2]$.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Bodwin_G/0/1/0/all/0/1">Greg Bodwin</a>, <a href="http://arxiv.org/find/cs/1/au:+Hoppenworth_G/0/1/0/all/0/1">Gary Hoppenworth</a></p><p>For a graph $G$, a $D$-diameter-reducing exact hopset is a small set of
additional edges $H$ that, when added to $G$, maintains its graph metric but
guarantees that all node pairs have a shortest path in $G \cup H$ using at most
$D$ edges. A shortcut set is the analogous concept for reachability. These
objects have been studied since the early '90s due to applications in parallel,
distributed, dynamic, and streaming graph algorithms.
</p>
<p>For most of their history, the state-of-the-art construction for either
object was a simple folklore algorithm, based on randomly sampling nodes to hit
long paths in the graph. However, recent breakthroughs of Kogan and Parter
[SODA '22] and Bernstein and Wein [SODA '23] have finally improved over the
folklore diameter bound of $\widetilde{O}(n^{1/2})$ for shortcut sets and for
$(1+\epsilon)$-approximate hopsets. For both objects it is now known that one
can use $O(n)$ hop-edges to reduce diameter to $\widetilde{O}(n^{1/3})$. The
only setting where folklore sampling remains unimproved is for exact hopsets.
Can these improvements be continued?
</p>
<p>We settle this question negatively by constructing graphs on which any exact
hopset of $O(n)$ edges has diameter $\widetilde{\Omega}(n^{1/2})$. This
improves on the previous lower bound of $\widetilde{\Omega}(n^{1/3})$ by Kogan
and Parter [FOCS '22]. Using similar ideas, we also polynomially improve the
current lower bounds for shortcut sets, constructing graphs on which any
shortcut set of $O(n)$ edges reduces diameter to $\widetilde{\Omega}(n^{1/4})$.
This improves on the previous lower bound of $\Omega(n^{1/6})$ by Huang and
Pettie [SIAM J. Disc. Math. '18]. We also extend our constructions to provide
lower bounds against $O(p)$-size exact hopsets and shortcut sets for other
values of $p$; in particular, we show that folklore sampling is near-optimal
for exact hopsets in the entire range of $p \in [1, n^2]$.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-06T00:30:00Z">Thursday, April 06 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.02261'>Optimal Sketching Bounds for Sparse Linear Regression</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Tung Mai, Alexander Munteanu, Cameron Musco, Anup B. Rao, Chris Schwiegelshohn, David P. Woodruff</p><p>We study oblivious sketching for $k$-sparse linear regression under various
loss functions such as an $\ell_p$ norm, or from a broad class of hinge-like
loss functions, which includes the logistic and ReLU losses. We show that for
sparse $\ell_2$ norm regression, there is a distribution over oblivious
sketches with $\Theta(k\log(d/k)/\varepsilon^2)$ rows, which is tight up to a
constant factor. This extends to $\ell_p$ loss with an additional additive
$O(k\log(k/\varepsilon)/\varepsilon^2)$ term in the upper bound. This
establishes a surprising separation from the related sparse recovery problem,
which is an important special case of sparse regression. For this problem,
under the $\ell_2$ norm, we observe an upper bound of $O(k \log (d)/\varepsilon
+ k\log(k/\varepsilon)/\varepsilon^2)$ rows, showing that sparse recovery is
strictly easier to sketch than sparse regression. For sparse regression under
hinge-like loss functions including sparse logistic and sparse ReLU regression,
we give the first known sketching bounds that achieve $o(d)$ rows showing that
$O(\mu^2 k\log(\mu n d/\varepsilon)/\varepsilon^2)$ rows suffice, where $\mu$
is a natural complexity parameter needed to obtain relative error bounds for
these loss functions. We again show that this dimension is tight, up to lower
order terms and the dependence on $\mu$. Finally, we show that similar
sketching bounds can be achieved for LASSO regression, a popular convex
relaxation of sparse regression, where one aims to minimize
$\|Ax-b\|_2^2+\lambda\|x\|_1$ over $x\in\mathbb{R}^d$. We show that sketching
dimension $O(\log(d)/(\lambda \varepsilon)^2)$ suffices and that the dependence
on $d$ and $\lambda$ is tight.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Mai_T/0/1/0/all/0/1">Tung Mai</a>, <a href="http://arxiv.org/find/cs/1/au:+Munteanu_A/0/1/0/all/0/1">Alexander Munteanu</a>, <a href="http://arxiv.org/find/cs/1/au:+Musco_C/0/1/0/all/0/1">Cameron Musco</a>, <a href="http://arxiv.org/find/cs/1/au:+Rao_A/0/1/0/all/0/1">Anup B. Rao</a>, <a href="http://arxiv.org/find/cs/1/au:+Schwiegelshohn_C/0/1/0/all/0/1">Chris Schwiegelshohn</a>, <a href="http://arxiv.org/find/cs/1/au:+Woodruff_D/0/1/0/all/0/1">David P. Woodruff</a></p><p>We study oblivious sketching for $k$-sparse linear regression under various
loss functions such as an $\ell_p$ norm, or from a broad class of hinge-like
loss functions, which includes the logistic and ReLU losses. We show that for
sparse $\ell_2$ norm regression, there is a distribution over oblivious
sketches with $\Theta(k\log(d/k)/\varepsilon^2)$ rows, which is tight up to a
constant factor. This extends to $\ell_p$ loss with an additional additive
$O(k\log(k/\varepsilon)/\varepsilon^2)$ term in the upper bound. This
establishes a surprising separation from the related sparse recovery problem,
which is an important special case of sparse regression. For this problem,
under the $\ell_2$ norm, we observe an upper bound of $O(k \log (d)/\varepsilon
+ k\log(k/\varepsilon)/\varepsilon^2)$ rows, showing that sparse recovery is
strictly easier to sketch than sparse regression. For sparse regression under
hinge-like loss functions including sparse logistic and sparse ReLU regression,
we give the first known sketching bounds that achieve $o(d)$ rows showing that
$O(\mu^2 k\log(\mu n d/\varepsilon)/\varepsilon^2)$ rows suffice, where $\mu$
is a natural complexity parameter needed to obtain relative error bounds for
these loss functions. We again show that this dimension is tight, up to lower
order terms and the dependence on $\mu$. Finally, we show that similar
sketching bounds can be achieved for LASSO regression, a popular convex
relaxation of sparse regression, where one aims to minimize
$\|Ax-b\|_2^2+\lambda\|x\|_1$ over $x\in\mathbb{R}^d$. We show that sketching
dimension $O(\log(d)/(\lambda \varepsilon)^2)$ suffices and that the dependence
on $d$ and $\lambda$ is tight.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-06T00:30:00Z">Thursday, April 06 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.02315'>The Laplacian Paradigm in Deterministic Congested Clique</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Sebatian Forster, Tijn de Vos</p><p>In this paper, we bring the techniques of the Laplacian paradigm to the
congested clique, while further restricting ourselves to deterministic
algorithms. In particular, we show how to solve a Laplacian system up to
precision $\epsilon$ in $n^{o(1)}\log(1/\epsilon)$ rounds. We show how to
leverage this result within existing interior point methods for solving flow
problems. We obtain an $m^{3/7+o(1)}U^{1/7}$ round algorithm for maximum flow
on a weighted directed graph with maximum weight $U$, and we obtain an
$\tilde{O}(m^{3/7}(n^{0.158}+n^{o(1)}\text{poly}\log W))$ round algorithm for
unit capacity minimum cost flow on a directed graph with maximum cost $W$.
Hereto, we give a novel routine for computing Eulerian orientations in $O(\log
n \log^* n)$ rounds, which we believe may be of separate interest.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Forster_S/0/1/0/all/0/1">Sebatian Forster</a>, <a href="http://arxiv.org/find/cs/1/au:+Vos_T/0/1/0/all/0/1">Tijn de Vos</a></p><p>In this paper, we bring the techniques of the Laplacian paradigm to the
congested clique, while further restricting ourselves to deterministic
algorithms. In particular, we show how to solve a Laplacian system up to
precision $\epsilon$ in $n^{o(1)}\log(1/\epsilon)$ rounds. We show how to
leverage this result within existing interior point methods for solving flow
problems. We obtain an $m^{3/7+o(1)}U^{1/7}$ round algorithm for maximum flow
on a weighted directed graph with maximum weight $U$, and we obtain an
$\tilde{O}(m^{3/7}(n^{0.158}+n^{o(1)}\text{poly}\log W))$ round algorithm for
unit capacity minimum cost flow on a directed graph with maximum cost $W$.
Hereto, we give a novel routine for computing Eulerian orientations in $O(\log
n \log^* n)$ rounds, which we believe may be of separate interest.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-06T00:30:00Z">Thursday, April 06 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.02360'>On the Power of Threshold-Based Algorithms for Detecting Cycles in the CONGEST Model</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Pierre Fraigniaud, Ma&#xeb;l Luce, Ioan Todinca</p><p>It is known that, for every $k\geq 2$, $C_{2k}$-freeness can be decided by a
generic Monte-Carlo algorithm running in $n^{1-1/\Theta(k^2)}$ rounds in the
CONGEST model. For $2\leq k\leq 5$, faster Monte-Carlo algorithms do exist,
running in $O(n^{1-1/k})$ rounds, based on upper bounding the number of
messages to be forwarded, and aborting search sub-routines for which this
number exceeds certain thresholds. We investigate the possible extension of
these threshold-based algorithms, for the detection of larger cycles. We first
show that, for every $k\geq 6$, there exists an infinite family of graphs
containing a $2k$-cycle for which any threshold-based algorithm fails to detect
that cycle. Hence, in particular, neither $C_{12}$-freeness nor
$C_{14}$-freeness can be decided by threshold-based algorithms. Nevertheless,
we show that $\{C_{12},C_{14}\}$-freeness can still be decided by a
threshold-based algorithm, running in $O(n^{1-1/7})= O(n^{0.857\dots})$ rounds,
which is faster than using the generic algorithm, which would run in
$O(n^{1-1/22})\simeq O(n^{0.954\dots})$ rounds. Moreover, we exhibit an
infinite collection of families of cycles such that threshold-based algorithms
can decide $\mathcal{F}$-freeness for every $\mathcal{F}$ in this collection.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Fraigniaud_P/0/1/0/all/0/1">Pierre Fraigniaud</a>, <a href="http://arxiv.org/find/cs/1/au:+Luce_M/0/1/0/all/0/1">Ma&#xeb;l Luce</a>, <a href="http://arxiv.org/find/cs/1/au:+Todinca_I/0/1/0/all/0/1">Ioan Todinca</a></p><p>It is known that, for every $k\geq 2$, $C_{2k}$-freeness can be decided by a
generic Monte-Carlo algorithm running in $n^{1-1/\Theta(k^2)}$ rounds in the
CONGEST model. For $2\leq k\leq 5$, faster Monte-Carlo algorithms do exist,
running in $O(n^{1-1/k})$ rounds, based on upper bounding the number of
messages to be forwarded, and aborting search sub-routines for which this
number exceeds certain thresholds. We investigate the possible extension of
these threshold-based algorithms, for the detection of larger cycles. We first
show that, for every $k\geq 6$, there exists an infinite family of graphs
containing a $2k$-cycle for which any threshold-based algorithm fails to detect
that cycle. Hence, in particular, neither $C_{12}$-freeness nor
$C_{14}$-freeness can be decided by threshold-based algorithms. Nevertheless,
we show that $\{C_{12},C_{14}\}$-freeness can still be decided by a
threshold-based algorithm, running in $O(n^{1-1/7})= O(n^{0.857\dots})$ rounds,
which is faster than using the generic algorithm, which would run in
$O(n^{1-1/22})\simeq O(n^{0.954\dots})$ rounds. Moreover, we exhibit an
infinite collection of families of cycles such that threshold-based algorithms
can decide $\mathcal{F}$-freeness for every $\mathcal{F}$ in this collection.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-06T00:30:00Z">Thursday, April 06 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2304.02498'>Improved Analysis of two Algorithms for Min-Weighted Sum Bin Packing</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Guillaume Sagnol</p><p>We study the Min-Weighted Sum Bin Packing problem, a variant of the classical
Bin Packing problem in which items have a weight, and each item induces a cost
equal to its weight multiplied by the index of the bin in which it is packed.
This is in fact equivalent to a batch scheduling problem that arises in many
fields of applications such as appointment scheduling or warehouse logistics.
We give improved lower and upper bounds on the approximation ratio of two
simple algorithms for this problem. In particular, we show that the
knapsack-batching algorithm, which iteratively solves knapsack problems over
the set of remaining items to pack the maximal weight in the current bin, has
an approximation ratio of at most 17/10.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Sagnol_G/0/1/0/all/0/1">Guillaume Sagnol</a></p><p>We study the Min-Weighted Sum Bin Packing problem, a variant of the classical
Bin Packing problem in which items have a weight, and each item induces a cost
equal to its weight multiplied by the index of the bin in which it is packed.
This is in fact equivalent to a batch scheduling problem that arises in many
fields of applications such as appointment scheduling or warehouse logistics.
We give improved lower and upper bounds on the approximation ratio of two
simple algorithms for this problem. In particular, we show that the
knapsack-batching algorithm, which iteratively solves knapsack problems over
the set of remaining items to pack the maximal weight in the current bin, has
an approximation ratio of at most 17/10.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-04-06T00:30:00Z">Thursday, April 06 2023, 00:30</time>
        </div>
      </div>
    </details>
  
  </div>

  <script src='https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.1/jquery.min.js' type="text/javascript"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-timeago/1.6.7/jquery.timeago.min.js" type="text/javascript"></script>
  <script src='js/theory.js'></script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>
