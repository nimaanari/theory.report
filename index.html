<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-0RQ5M78VX5"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-0RQ5M78VX5');
  </script>

  <meta charset='utf-8'>
  <meta name='generator' content='Pluto 1.6.2 on Ruby 3.0.6 (2023-03-30) [x86_64-linux]'>

  <title>Theory of Computing Report</title>

  <link rel="alternate" type="application/rss+xml" title="Posts (RSS)" href="rss20.xml" />
  <link rel="alternate" type="application/atom+xml" title="Posts (Atom)" href="atom.xml" />
  
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/solid.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/regular.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/fontawesome.min.css">
  <link rel='stylesheet' type='text/css' href='css/theory.css'>
</head>
<body>
  <details class="tr-panel" open>
    <summary>
      <span>Last Update</span>
      <div class="tr-small">
        
          <time class='timeago' datetime="2023-05-07T11:30:26Z">Sunday, May 07 2023, 11:30</time>
        
      </div>
      <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
    </summary>
    <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

    <ul class='tr-subscriptions tr-small' >
    
      <li>
        <a href='http://arxiv.org/rss/cs.CC'><img src='icon/feed.png'></a>
        <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a>
      </li>
    
      <li>
        <a href='http://arxiv.org/rss/cs.CG'><img src='icon/feed.png'></a>
        <a href='https://arxiv.org/list/cs.CG/recent'>arXiv: Computational Geometry</a>
      </li>
    
      <li>
        <a href='http://arxiv.org/rss/cs.DS'><img src='icon/feed.png'></a>
        <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a>
      </li>
    
      <li>
        <a href='http://aaronsadventures.blogspot.com/feeds/posts/default'><img src='icon/feed.png'></a>
        <a href='http://aaronsadventures.blogspot.com/'>Aaron Roth</a>
      </li>
    
      <li>
        <a href='https://adamsheffer.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://adamsheffer.wordpress.com'>Adam Sheffer</a>
      </li>
    
      <li>
        <a href='https://adamdsmith.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://adamdsmith.wordpress.com'>Adam Smith</a>
      </li>
    
      <li>
        <a href='https://polylogblog.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://polylogblog.wordpress.com'>Andrew McGregor</a>
      </li>
    
      <li>
        <a href='https://corner.mimuw.edu.pl/?feed=rss2'><img src='icon/feed.png'></a>
        <a href='https://corner.mimuw.edu.pl'>Banach's Algorithmic Corner</a>
      </li>
    
      <li>
        <a href='http://www.argmin.net/feed.xml'><img src='icon/feed.png'></a>
        <a href='http://benjamin-recht.github.io/'>Ben Recht</a>
      </li>
    
      <li>
        <a href='http://bit-player.org/feed/atom/'><img src='icon/feed.png'></a>
        <a href='http://bit-player.org'>bit-player</a>
      </li>
    
      <li>
        <a href='https://cstheory-jobs.org/feed/'><img src='icon/feed.png'></a>
        <a href='https://cstheory-jobs.org'>CCI: jobs</a>
      </li>
    
      <li>
        <a href='https://cstheory-events.org/feed/'><img src='icon/feed.png'></a>
        <a href='https://cstheory-events.org'>CS Theory Events</a>
      </li>
    
      <li>
        <a href='http://blog.computationalcomplexity.org/feeds/posts/default'><img src='icon/feed.png'></a>
        <a href='http://blog.computationalcomplexity.org/'>Computational Complexity</a>
      </li>
    
      <li>
        <a href='https://11011110.github.io/blog/feed.xml'><img src='icon/feed.png'></a>
        <a href='https://11011110.github.io/blog/'>David Eppstein</a>
      </li>
    
      <li>
        <a href='https://daveagp.wordpress.com/category/toc/feed/'><img src='icon/feed.png'></a>
        <a href='https://daveagp.wordpress.com'>David Pritchard</a>
      </li>
    
      <li>
        <a href='https://decentdescent.org/feed.xml'><img src='icon/feed.png'></a>
        <a href='https://decentdescent.org/'>Decent Descent</a>
      </li>
    
      <li>
        <a href='https://decentralizedthoughts.github.io/feed'><img src='icon/feed.png'></a>
        <a href='https://decentralizedthoughts.github.io'>Decentralized Thoughts</a>
      </li>
    
      <li>
        <a href='https://differentialprivacy.org/feed.xml'><img src='icon/feed.png'></a>
        <a href='https://differentialprivacy.org'>DifferentialPrivacy.org</a>
      </li>
    
      <li>
        <a href='https://eccc.weizmann.ac.il//feeds/reports/'><img src='icon/feed.png'></a>
        <a href='https://eccc.weizmann.ac.il/'>ECCC Papers</a>
      </li>
    
      <li>
        <a href='https://emanueleviola.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://emanueleviola.wordpress.com'>Emanuele Viola</a>
      </li>
    
      <li>
        <a href='https://3dpancakes.typepad.com/ernie/atom.xml'><img src='icon/feed.png'></a>
        <a href='https://3dpancakes.typepad.com/ernie/'>Ernie's 3D Pancakes</a>
      </li>
    
      <li>
        <a href='https://dstheory.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://dstheory.wordpress.com'>Foundation of Data Science - Virtual Talk Series</a>
      </li>
    
      <li>
        <a href='https://francisbach.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://francisbach.com'>Francis Bach</a>
      </li>
    
      <li>
        <a href='https://gilkalai.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://gilkalai.wordpress.com'>Gil Kalai</a>
      </li>
    
      <li>
        <a href='https://blogs.oregonstate.edu:443/glencora/tag/tcs/feed/'><img src='icon/feed.png'></a>
        <a href='https://blogs.oregonstate.edu/glencora'>Glencora Borradaile</a>
      </li>
    
      <li>
        <a href='https://research.googleblog.com/feeds/posts/default/-/Algorithms'><img src='icon/feed.png'></a>
        <a href='https://research.googleblog.com/search/label/Algorithms'>Google Research Blog: Algorithms</a>
      </li>
    
      <li>
        <a href='https://gradientscience.org/feed.xml'><img src='icon/feed.png'></a>
        <a href='https://gradientscience.org/'>Gradient Science</a>
      </li>
    
      <li>
        <a href='http://grigory.us/blog/feed.xml'><img src='icon/feed.png'></a>
        <a href='http://grigory.github.io/blog'>Grigory Yaroslavtsev</a>
      </li>
    
      <li>
        <a href='https://minorfree.github.io/feed.xml'><img src='icon/feed.png'></a>
        <a href='https://minorfree.github.io'>Hung Le</a>
      </li>
    
      <li>
        <a href='https://tcsmath.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://tcsmath.wordpress.com'>James R. Lee</a>
      </li>
    
      <li>
        <a href='https://kamathematics.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://kamathematics.wordpress.com'>Kamathematics</a>
      </li>
    
      <li>
        <a href='http://processalgebra.blogspot.com/feeds/posts/default'><img src='icon/feed.png'></a>
        <a href='http://processalgebra.blogspot.com/'>Luca Aceto</a>
      </li>
    
      <li>
        <a href='https://lucatrevisan.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://lucatrevisan.wordpress.com'>Luca Trevisan</a>
      </li>
    
      <li>
        <a href='https://mittheory.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://mittheory.wordpress.com'>MIT CSAIL Student Blog</a>
      </li>
    
      <li>
        <a href='http://mybiasedcoin.blogspot.com/feeds/posts/default'><img src='icon/feed.png'></a>
        <a href='http://mybiasedcoin.blogspot.com/'>Michael Mitzenmacher</a>
      </li>
    
      <li>
        <a href='http://blog.mrtz.org/feed.xml'><img src='icon/feed.png'></a>
        <a href='http://blog.mrtz.org/'>Moritz Hardt</a>
      </li>
    
      <li>
        <a href='http://mysliceofpizza.blogspot.com/feeds/posts/default/-/aggregator'><img src='icon/feed.png'></a>
        <a href='http://mysliceofpizza.blogspot.com/search/label/aggregator'>Muthu Muthukrishnan</a>
      </li>
    
      <li>
        <a href='https://nisheethvishnoi.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://nisheethvishnoi.wordpress.com'>Nisheeth Vishnoi</a>
      </li>
    
      <li>
        <a href='http://www.solipsistslog.com/feed/'><img src='icon/feed.png'></a>
        <a href='http://www.solipsistslog.com'>Noah Stephens-Davidowitz</a>
      </li>
    
      <li>
        <a href='http://www.offconvex.org/feed.xml'><img src='icon/feed.png'></a>
        <a href='http://offconvex.github.io/'>Off the Convex Path</a>
      </li>
    
      <li>
        <a href='http://paulwgoldberg.blogspot.com/feeds/posts/default/-/aggregator'><img src='icon/feed.png'></a>
        <a href='http://paulwgoldberg.blogspot.com/search/label/aggregator'>Paul Goldberg</a>
      </li>
    
      <li>
        <a href='https://ptreview.sublinear.info/?feed=rss2'><img src='icon/feed.png'></a>
        <a href='https://ptreview.sublinear.info'>Property Testing Review</a>
      </li>
    
      <li>
        <a href='https://rjlipton.wpcomstaging.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://rjlipton.wpcomstaging.com'>Richard Lipton</a>
      </li>
    
      <li>
        <a href='https://blogs.princeton.edu/imabandit/feed/'><img src='icon/feed.png'></a>
        <a href='https://blogs.princeton.edu/imabandit'>Sébastien Bubeck</a>
      </li>
    
      <li>
        <a href='https://scottaaronson.blog/?feed=atom'><img src='icon/feed.png'></a>
        <a href='https://scottaaronson.blog'>Scott Aaronson</a>
      </li>
    
      <li>
        <a href='https://blog.simons.berkeley.edu/feed/'><img src='icon/feed.png'></a>
        <a href='https://blog.simons.berkeley.edu'>Simons Institute Blog</a>
      </li>
    
      <li>
        <a href='https://tcsplus.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://tcsplus.wordpress.com'>TCS+ Seminar Series</a>
      </li>
    
      <li>
        <a href='https://toc4fairness.org/feed/'><img src='icon/feed.png'></a>
        <a href='https://toc4fairness.org'>TOC for Fairness</a>
      </li>
    
      <li>
        <a href='http://www.blogger.com/feeds/6555947/posts/default?alt=atom'><img src='icon/feed.png'></a>
        <a href='http://blog.geomblog.org/'>The Geomblog</a>
      </li>
    
      <li>
        <a href='https://www.let-all.com/blog/feed/'><img src='icon/feed.png'></a>
        <a href='https://www.let-all.com/blog'>The Learning Theory Alliance Blog</a>
      </li>
    
      <li>
        <a href='https://theorydish.blog/feed/'><img src='icon/feed.png'></a>
        <a href='https://theorydish.blog'>Theory Dish: Stanford Blog</a>
      </li>
    
      <li>
        <a href='https://thmatters.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://thmatters.wordpress.com'>Theory Matters</a>
      </li>
    
      <li>
        <a href='https://mycqstate.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://mycqstate.wordpress.com'>Thomas Vidick</a>
      </li>
    
      <li>
        <a href='https://agtb.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://agtb.wordpress.com'>Turing's Invisible Hand</a>
      </li>
    
      <li>
        <a href='https://windowsontheory.org/feed/'><img src='icon/feed.png'></a>
        <a href='https://windowsontheory.org'>Windows on Theory</a>
      </li>
    
    </ul>

    <p class='tr-small'><a href="opml.xml">OPML feed</a> of all feeds.</p>
    <p class='tr-small'>Subscribe to the <a href="atom.xml">Atom feed</a>, <a href="rss20.xml">RSS feed</a>, or follow on <a href="https://twitter.com/cstheory">Twitter</a>, to stay up to date.</p>
    <p class='tr-small'>Source on <a href="https://github.com/nimaanari/theory.report">GitHub</a>.</p>
    <p class='tr-small'>Maintained by Nima Anari, Arnab Bhattacharyya, Gautam Kamath.</p>
    <p class='tr-small'>Powered by <a href='https://github.com/feedreader'>Pluto</a>.</p>
  </details>

  <div class="tr-opts">
    <i id='tr-show-headlines' class="fa-solid fa-fw fa-window-minimize tr-button" title='Show Headlines Only'></i>
    <i id='tr-show-snippets' class="fa-solid fa-fw fa-compress tr-button" title='Show Snippets'></i>
    <i id='tr-show-fulltext' class="fa-solid fa-fw fa-expand tr-button" title='Show Full Text'></i>
  </div>

  <h1>Theory of Computing Report</h1>

  <div class="tr-articles tr-shrink">
    
    
    <h2 class='tr-new-date'>
      <i class='fa-regular fa-calendar'></i> Friday, May 05
    </h2>
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='https://eccc.weizmann.ac.il/report/2023/066'>TR23-066 |  Protecting Single-Hop Radio Networks from Message Drops | 

	Dmitry Paramonov, 

	Gillat Kol, 

	Raghuvansh Saxena, 

	Klim Efremenko</a></h3>
        <p class='tr-article-feed'>from <a href='https://eccc.weizmann.ac.il/'>ECCC Papers</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          Single-hop radio networks (SHRN) are a well studied abstraction of communication over a wireless channel. In this model, in every round, each of the $n$ participating parties may decide to broadcast a message to all the others, potentially causing collisions. We consider the SHRN model in the presence of stochastic message drops (i.e., erasures), where in every round, the message received by each party is erased (replaced by $\bot$) with some small constant probability, independently.

Our main result is a constant rate coding scheme, allowing one to run protocols designed to work over the (noiseless) SHRN model over the SHRN model with erasures. Our scheme converts any protocol $\Pi$ of length at most exponential in $n$ over the SHRN model to a protocol $\Pi&#39;$ that is resilient to constant fraction of erasures and has length linear in the length of $\Pi$.

We mention that for the special case where the protocol $\Pi$ is non-adaptive, i.e., the order of communication is fixed in advance, such a scheme was known. Nevertheless, adaptivity is widely used and is known to hugely boost the power of wireless channels, which makes handling the general case of adaptive protocols $\Pi$ both important and more challenging. Indeed, to the best of our knowledge, our result is the first constant rate scheme that converts adaptive protocols to noise resilient ones in any multi-party model.
        
        </div>

        <div class='tr-article-summary'>
        
          
          Single-hop radio networks (SHRN) are a well studied abstraction of communication over a wireless channel. In this model, in every round, each of the $n$ participating parties may decide to broadcast a message to all the others, potentially causing collisions. We consider the SHRN model in the presence of stochastic message drops (i.e., erasures), where in every round, the message received by each party is erased (replaced by $\bot$) with some small constant probability, independently.

Our main result is a constant rate coding scheme, allowing one to run protocols designed to work over the (noiseless) SHRN model over the SHRN model with erasures. Our scheme converts any protocol $\Pi$ of length at most exponential in $n$ over the SHRN model to a protocol $\Pi&#39;$ that is resilient to constant fraction of erasures and has length linear in the length of $\Pi$.

We mention that for the special case where the protocol $\Pi$ is non-adaptive, i.e., the order of communication is fixed in advance, such a scheme was known. Nevertheless, adaptivity is widely used and is known to hugely boost the power of wireless channels, which makes handling the general case of adaptive protocols $\Pi$ both important and more challenging. Indeed, to the best of our knowledge, our result is the first constant rate scheme that converts adaptive protocols to noise resilient ones in any multi-party model.
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-05T17:23:04Z">Friday, May 05 2023, 17:23</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='https://scottaaronson.blog/?p=7278'>AI and Aaronson&#8217;s Law of Dark Irony</a></h3>
        <p class='tr-article-feed'>from <a href='https://scottaaronson.blog'>Scott Aaronson</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          The major developments in human history are always steeped in dark ironies. Yes, that&#8217;s my Law of Dark Irony, the whole thing. I don&#8217;t know why it&#8217;s true, but it certainly seems to be. Taking WWII as the archetypal example, let&#8217;s enumerate just the more obvious ones: When I think about the scenarios where superintelligent [&#8230;]
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p>The major developments in human history are <em>always</em> steeped in dark ironies.  Yes, that&#8217;s my Law of Dark Irony, the whole thing.</p>



<p>I don&#8217;t know why it&#8217;s true, but it certainly seems to be.  Taking WWII as the archetypal example, let&#8217;s enumerate just the more obvious ones:</p>



<ul>
<li>After the carnage of WWI, the world&#8217;s most sensitive and thoughtful people (many of them) learned the lesson that they should oppose war at any cost.  This attitude let Germany rearm and set the stage for WWII.</li>



<li>Hitler, who was neither tall nor blond, wished to establish the worldwide domination of tall, blond Aryans &#8230; and do so via an alliance with the Japanese.</li>



<li>The Nazis touted the dream of eugenically perfecting the human race, then perpetrated a genocide against a tiny group that had produced Einstein, von Neumann, Wigner, Ulam, and Tarski.</li>



<li>The Jews were murdered using a chemical&#8212;<a href="https://en.wikipedia.org/wiki/Zyklon_B">Zyklon B</a>&#8212;developed in part by the Jewish chemist Fritz Haber.</li>



<li>The Allied force that made the greatest sacrifice in lives to defeat Hitler was Stalin&#8217;s USSR, <em>another</em> of history&#8217;s most murderous and horrifying regimes.</li>



<li>The man who rallied the free world to defeat Nazism, Winston Churchill, was himself a racist colonialist, whose views would be (and regularly are) denounced as &#8220;Nazi&#8221; on modern college campuses.</li>



<li>The WWII legacy that would go on to threaten humanity&#8217;s existence&#8212;the Bomb&#8212;was created in what the scientists believed was a desperate race to <em>save</em> humanity.  Then Hitler was defeated before the Bomb was ready, and it turned out the Nazis were never even close to building their own Bomb, and the Bomb was used instead against Japan.</li>
</ul>



<p>When I think about the scenarios where superintelligent AI destroys the world, they rarely seem to do enough justice to the Law of Dark Irony.  It&#8217;s like: OK, AI is created to serve humanity, and instead it turns on humanity and destroys it.  Great, that&#8217;s <em>one</em> dark irony.  One.  What other dark ironies could there be?  How about:</p>



<ul>
<li>For decades, the Yudkowskyans warned about the dangers of superintelligence.  So far, by all accounts, the great practical effect of these warnings has been to inspire the founding of both DeepMind and OpenAI, the entities that Yudkowskyans believe are locked into a race to <em>realize</em> those dangers.</li>



<li>Maybe AIs will displace humans &#8230; and they&#8217;ll <em>deserve</em> to, since they won&#8217;t be quite as wretched and cruel as we are.  (This is basically the plot of <em>Westworld</em>, or at least of its first couple seasons, which Dana and I are now belatedly watching.)</li>



<li>Maybe the world will get destroyed by what Yudkowsky calls a <a href="https://arbital.com/p/pivotal/">&#8220;pivotal act&#8221;</a>: an act meant to <em>safeguard</em> the world from takeover from an unaligned AGI, for example by taking it over with an aligned AGI first.  (I seriously worry about this; it&#8217;s a pretty obvious one.)</li>



<li>Maybe AI will get the idea to take over the world, but only because it&#8217;s been trained on generations of science fiction and decades of Internet discussion worrying about the possibility of AI taking over the world.  (I&#8217;m far from the first to notice this possibility.)</li>



<li>Maybe AI will indeed destroy the world, but it will do so &#8220;by mistake,&#8221; while trying to <em>save</em> the world, or by taking a calculated gamble to save the world that fails.  (A commenter on my last post <a href="https://scottaaronson.blog/?p=7266#comment-1949890">brought this one up</a>.)</li>



<li>Maybe humanity will successfully coordinate to pause AGI development, and then promptly be destroyed by <em>something else</em>&#8212;runaway climate change, an accidental nuclear exchange&#8212;that the AGI, had it been created, would&#8217;ve prevented.  (This, of course, would be directly analogous to one of the great dark ironies of all time: the one where decades of antinuclear activism, intended to save the planet, has instead doomed us to destroy the earth by oil and coal.)</li>
</ul>



<p>Readers: which <em>other</em> possible dark ironies have I missed?</p>
<p class="authors">By Scott</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-05T02:27:52Z">Friday, May 05 2023, 02:27</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.02553'>Complexity and asymptotics of structure constants</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Greta Panova</p><p>Kostka, Littlewood-Richardson, Kronecker, and plethysm coefficients are
fundamental quantities in algebraic combinatorics, yet many natural questions
about them stay unanswered for more than 80 years. Kronecker and plethysm
coefficients lack ``nice formulas'', a notion that can be formalized using
computational complexity theory. Beyond formulas and combinatorial
interpretations, we can attempt to understand their asymptotic behavior in
various regimes, and inequalities they could satisfy. Understanding these
quantities has applications beyond combinatorics. On the one hand, the
asymptotics of structure constants is closely related to understanding the
[limit] behavior of vertex and tiling models in statistical mechanics. More
recently, these structure constants have been involved in establishing
computational complexity lower bounds and separation of complexity classes like
VP vs VNP, the algebraic analogs of P vs NP in arithmetic complexity theory.
Here we discuss the outstanding problems related to asymptotics, positivity,
and complexity of structure constants focusing mostly on the Kronecker
coefficients of the symmetric group and, less so, on the plethysm coefficients.
</p>
<p>This expository paper is based on the talk presented at the Open Problems in
Algebraic Combinatorics coneference in May 2022.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/math/1/au:+Panova_G/0/1/0/all/0/1">Greta Panova</a></p><p>Kostka, Littlewood-Richardson, Kronecker, and plethysm coefficients are
fundamental quantities in algebraic combinatorics, yet many natural questions
about them stay unanswered for more than 80 years. Kronecker and plethysm
coefficients lack ``nice formulas'', a notion that can be formalized using
computational complexity theory. Beyond formulas and combinatorial
interpretations, we can attempt to understand their asymptotic behavior in
various regimes, and inequalities they could satisfy. Understanding these
quantities has applications beyond combinatorics. On the one hand, the
asymptotics of structure constants is closely related to understanding the
[limit] behavior of vertex and tiling models in statistical mechanics. More
recently, these structure constants have been involved in establishing
computational complexity lower bounds and separation of complexity classes like
VP vs VNP, the algebraic analogs of P vs NP in arithmetic complexity theory.
Here we discuss the outstanding problems related to asymptotics, positivity,
and complexity of structure constants focusing mostly on the Kronecker
coefficients of the symmetric group and, less so, on the plethysm coefficients.
</p>
<p>This expository paper is based on the talk presented at the Open Problems in
Algebraic Combinatorics coneference in May 2022.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-05T00:30:00Z">Friday, May 05 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.02800'>On the parameterized complexity of the Perfect Phylogeny problem</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Jorke M. de Vlas</p><p>This paper categorizes the parameterized complexity of the algorithmic
problems Perfect Phylogeny and Triangulating Colored Graphs. We show that they
are complete for the parameterized complexity class XALP using a reduction from
Tree-chained Multicolor Independent Set and a proof of membership. We introduce
the problem Triangulating Multicolored Graphs as a stepping stone and prove
XALP-completeness for this problem as well. We also show that, assuming the
Exponential Time Hypothesis, there exists no algorithm that solves any of these
problems in time $f(k) n^{o(k)}$, where $n$ is the input size, $k$ the
parameter, and $f$ any computable function.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Vlas_J/0/1/0/all/0/1">Jorke M. de Vlas</a></p><p>This paper categorizes the parameterized complexity of the algorithmic
problems Perfect Phylogeny and Triangulating Colored Graphs. We show that they
are complete for the parameterized complexity class XALP using a reduction from
Tree-chained Multicolor Independent Set and a proof of membership. We introduce
the problem Triangulating Multicolored Graphs as a stepping stone and prove
XALP-completeness for this problem as well. We also show that, assuming the
Exponential Time Hypothesis, there exists no algorithm that solves any of these
problems in time $f(k) n^{o(k)}$, where $n$ is the input size, $k$ the
parameter, and $f$ any computable function.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-05T00:30:00Z">Friday, May 05 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.03003'>All Kronecker coefficients are reduced Kronecker coefficients</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Christian Ikenmeyer, Greta Panova</p><p>We settle the question of where exactly the reduced Kronecker coefficients
lie on the spectrum between the Littlewood-Richardson and Kronecker
coefficients by showing that every Kronecker coefficient of the symmetric group
is equal to a reduced Kronecker coefficient by an explicit construction. This
implies the equivalence of a question by Stanley from 2000 and a question by
Kirillov from 2004 about combinatorial interpretations of these two families of
coefficients. Moreover, as a corollary, we deduce that deciding the positivity
of reduced Kronecker coefficients is $NP$-hard, and computing them is
$\#P$-hard under parsimonious many-one reductions.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/math/1/au:+Ikenmeyer_C/0/1/0/all/0/1">Christian Ikenmeyer</a>, <a href="http://arxiv.org/find/math/1/au:+Panova_G/0/1/0/all/0/1">Greta Panova</a></p><p>We settle the question of where exactly the reduced Kronecker coefficients
lie on the spectrum between the Littlewood-Richardson and Kronecker
coefficients by showing that every Kronecker coefficient of the symmetric group
is equal to a reduced Kronecker coefficient by an explicit construction. This
implies the equivalence of a question by Stanley from 2000 and a question by
Kirillov from 2004 about combinatorial interpretations of these two families of
coefficients. Moreover, as a corollary, we deduce that deciding the positivity
of reduced Kronecker coefficients is $NP$-hard, and computing them is
$\#P$-hard under parsimonious many-one reductions.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-05T00:30:00Z">Friday, May 05 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.02445'>Online Geometric Covering and Piercing</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CG/recent'>arXiv: Computational Geometry</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Minati De, Saksham Jain, Sarat Varma Kallepalli, Satyam Singh</p><p>We consider the online version of the piercing set problem, where geometric
objects arrive one by one, and the online algorithm must maintain a valid
piercing set for the already arrived objects by making irrevocable decisions.
It is easy to observe that any deterministic online algorithm that solves this
problem has a competitive ratio of at least $\Omega(n)$, which even holds when
the objects are intervals. This paper considers the piercing set problem when
objects are bounded scaled. We propose deterministic algorithms for bounded
scaled fat objects. Piercing translated copies of an object is equivalent to
the unit covering problem, which is well-studied in the online setup.
Surprisingly, no upper bound of the competitive ratio was known for the unit
covering problem when unit objects are anything other than balls and
hypercubes. Our result gives an upper bound of the competitive ratio for the
unit covering problem for various unit objects. For fixed-oriented hypercubes
in $\mathbb{R}^d$ with the scaling factor in the range $[1,k]$, we propose an
algorithm having a competitive ratio of at most~$3^d\log_2 k+2^d$. In the end,
we show a lower bound of the competitive ratio for bounded scaled objects of
various types like $\alpha$-fat objects in $\mathbb{R}^2$, axis-aligned
hypercubes in $\mathbb{R}^d$, and balls in $\mathbb{R}^2$ and~$\mathbb{R}^3$.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+De_M/0/1/0/all/0/1">Minati De</a>, <a href="http://arxiv.org/find/cs/1/au:+Jain_S/0/1/0/all/0/1">Saksham Jain</a>, <a href="http://arxiv.org/find/cs/1/au:+Kallepalli_S/0/1/0/all/0/1">Sarat Varma Kallepalli</a>, <a href="http://arxiv.org/find/cs/1/au:+Singh_S/0/1/0/all/0/1">Satyam Singh</a></p><p>We consider the online version of the piercing set problem, where geometric
objects arrive one by one, and the online algorithm must maintain a valid
piercing set for the already arrived objects by making irrevocable decisions.
It is easy to observe that any deterministic online algorithm that solves this
problem has a competitive ratio of at least $\Omega(n)$, which even holds when
the objects are intervals. This paper considers the piercing set problem when
objects are bounded scaled. We propose deterministic algorithms for bounded
scaled fat objects. Piercing translated copies of an object is equivalent to
the unit covering problem, which is well-studied in the online setup.
Surprisingly, no upper bound of the competitive ratio was known for the unit
covering problem when unit objects are anything other than balls and
hypercubes. Our result gives an upper bound of the competitive ratio for the
unit covering problem for various unit objects. For fixed-oriented hypercubes
in $\mathbb{R}^d$ with the scaling factor in the range $[1,k]$, we propose an
algorithm having a competitive ratio of at most~$3^d\log_2 k+2^d$. In the end,
we show a lower bound of the competitive ratio for bounded scaled objects of
various types like $\alpha$-fat objects in $\mathbb{R}^2$, axis-aligned
hypercubes in $\mathbb{R}^d$, and balls in $\mathbb{R}^2$ and~$\mathbb{R}^3$.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-05T00:30:00Z">Friday, May 05 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.02724'>Towards Stratified Space Learning: 2-complexes</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CG/recent'>arXiv: Computational Geometry</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Yossi Bokor Bleile</p><p>In this paper, we consider a simple class of stratified spaces --
2-complexes. We present an algorithm that learns the abstract structure of an
embedded 2-complex from a point cloud sampled from it. We use tools and
inspiration from computational geometry, algebraic topology, and topological
data analysis and prove the correctness of the identified abstract structure
under assumptions on the embedding.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Bleile_Y/0/1/0/all/0/1">Yossi Bokor Bleile</a></p><p>In this paper, we consider a simple class of stratified spaces --
2-complexes. We present an algorithm that learns the abstract structure of an
embedded 2-complex from a point cloud sampled from it. We use tools and
inspiration from computational geometry, algebraic topology, and topological
data analysis and prove the correctness of the identified abstract structure
under assumptions on the embedding.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-05T00:30:00Z">Friday, May 05 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.02850'>Impossibility of Depth Reduction in Explainable Clustering</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Chengyuan Deng, Surya Teja Gavva, Karthik C. S., Parth Patel, Adarsh Srinivasan</p><p>Over the last few years Explainable Clustering has gathered a lot of
attention. Dasgupta et al. [ICML'20] initiated the study of explainable k-means
and k-median clustering problems where the explanation is captured by a
threshold decision tree which partitions the space at each node using axis
parallel hyperplanes. Recently, Laber et al. [Pattern Recognition'23] made a
case to consider the depth of the decision tree as an additional complexity
measure of interest.
</p>
<p>In this work, we prove that even when the input points are in the Euclidean
plane, then any depth reduction in the explanation incurs unbounded loss in the
k-means and k-median cost. Formally, we show that there exists a data set X in
the Euclidean plane, for which there is a decision tree of depth k-1 whose
k-means/k-median cost matches the optimal clustering cost of X, but every
decision tree of depth less than k-1 has unbounded cost w.r.t. the optimal cost
of clustering. We extend our results to the k-center objective as well, albeit
with weaker guarantees.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Deng_C/0/1/0/all/0/1">Chengyuan Deng</a>, <a href="http://arxiv.org/find/cs/1/au:+Gavva_S/0/1/0/all/0/1">Surya Teja Gavva</a>, <a href="http://arxiv.org/find/cs/1/au:+S%2E_K/0/1/0/all/0/1">Karthik C. S.</a>, <a href="http://arxiv.org/find/cs/1/au:+Patel_P/0/1/0/all/0/1">Parth Patel</a>, <a href="http://arxiv.org/find/cs/1/au:+Srinivasan_A/0/1/0/all/0/1">Adarsh Srinivasan</a></p><p>Over the last few years Explainable Clustering has gathered a lot of
attention. Dasgupta et al. [ICML'20] initiated the study of explainable k-means
and k-median clustering problems where the explanation is captured by a
threshold decision tree which partitions the space at each node using axis
parallel hyperplanes. Recently, Laber et al. [Pattern Recognition'23] made a
case to consider the depth of the decision tree as an additional complexity
measure of interest.
</p>
<p>In this work, we prove that even when the input points are in the Euclidean
plane, then any depth reduction in the explanation incurs unbounded loss in the
k-means and k-median cost. Formally, we show that there exists a data set X in
the Euclidean plane, for which there is a decision tree of depth k-1 whose
k-means/k-median cost matches the optimal clustering cost of X, but every
decision tree of depth less than k-1 has unbounded cost w.r.t. the optimal cost
of clustering. We extend our results to the k-center objective as well, albeit
with weaker guarantees.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-05T00:30:00Z">Friday, May 05 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.02450'>Perfect Sampling for Hard Spheres from Strong Spatial Mixing</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Konrad Anand, Andreas G&#xf6;bel, Marcus Pappik, Will Perkins</p><p>We provide a perfect sampling algorithm for the hard-sphere model on subsets
of $\mathbb{R}^d$ with expected running time linear in the volume under the
assumption of strong spatial mixing. A large number of perfect and approximate
sampling algorithms have been devised to sample from the hard-sphere model, and
our perfect sampling algorithm is efficient for a range of parameters for which
only efficient approximate samplers were previously known and is faster than
these known approximate approaches. Our methods also extend to the more general
setting of Gibbs point processes interacting via finite-range, repulsive
potentials.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Anand_K/0/1/0/all/0/1">Konrad Anand</a>, <a href="http://arxiv.org/find/cs/1/au:+Gobel_A/0/1/0/all/0/1">Andreas G&#xf6;bel</a>, <a href="http://arxiv.org/find/cs/1/au:+Pappik_M/0/1/0/all/0/1">Marcus Pappik</a>, <a href="http://arxiv.org/find/cs/1/au:+Perkins_W/0/1/0/all/0/1">Will Perkins</a></p><p>We provide a perfect sampling algorithm for the hard-sphere model on subsets
of $\mathbb{R}^d$ with expected running time linear in the volume under the
assumption of strong spatial mixing. A large number of perfect and approximate
sampling algorithms have been devised to sample from the hard-sphere model, and
our perfect sampling algorithm is efficient for a range of parameters for which
only efficient approximate samplers were previously known and is faster than
these known approximate approaches. Our methods also extend to the more general
setting of Gibbs point processes interacting via finite-range, repulsive
potentials.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-05T00:30:00Z">Friday, May 05 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.02508'>Efficient Caching with Reserves via Marking</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Sharat Ibrahimpur, Manish Purohit, Zoya Svitkina, Erik Vee, Joshua R. Wang</p><p>Online caching is among the most fundamental and well-studied problems in the
area of online algorithms. Innovative algorithmic ideas and analysis --
including potential functions and primal-dual techniques -- give insight into
this still-growing area. Here, we introduce a new analysis technique that first
uses a potential function to upper bound the cost of an online algorithm and
then pairs that with a new dual-fitting strategy to lower bound the cost of an
offline optimal algorithm. We apply these techniques to the Caching with
Reserves problem recently introduced by Ibrahimpur et al. [10] and give an
O(log k)-competitive fractional online algorithm via a marking strategy, where
k denotes the size of the cache. We also design a new online rounding algorithm
that runs in polynomial time to obtain an O(log k)-competitive randomized
integral algorithm. Additionally, we provide a new, simple proof for randomized
marking for the classical unweighted paging problem.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Ibrahimpur_S/0/1/0/all/0/1">Sharat Ibrahimpur</a>, <a href="http://arxiv.org/find/cs/1/au:+Purohit_M/0/1/0/all/0/1">Manish Purohit</a>, <a href="http://arxiv.org/find/cs/1/au:+Svitkina_Z/0/1/0/all/0/1">Zoya Svitkina</a>, <a href="http://arxiv.org/find/cs/1/au:+Vee_E/0/1/0/all/0/1">Erik Vee</a>, <a href="http://arxiv.org/find/cs/1/au:+Wang_J/0/1/0/all/0/1">Joshua R. Wang</a></p><p>Online caching is among the most fundamental and well-studied problems in the
area of online algorithms. Innovative algorithmic ideas and analysis --
including potential functions and primal-dual techniques -- give insight into
this still-growing area. Here, we introduce a new analysis technique that first
uses a potential function to upper bound the cost of an online algorithm and
then pairs that with a new dual-fitting strategy to lower bound the cost of an
offline optimal algorithm. We apply these techniques to the Caching with
Reserves problem recently introduced by Ibrahimpur et al. [10] and give an
O(log k)-competitive fractional online algorithm via a marking strategy, where
k denotes the size of the cache. We also design a new online rounding algorithm
that runs in polynomial time to obtain an O(log k)-competitive randomized
integral algorithm. Additionally, we provide a new, simple proof for randomized
marking for the classical unweighted paging problem.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-05T00:30:00Z">Friday, May 05 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.02526'>Prefix Sorting DFAs: a Recursive Algorithm</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Nicola Cotumaccio</p><p>In the past thirty years, numerous algorithms for building the suffix array
of a string have been proposed. In 2021, the notion of suffix array was
extended from strings to DFAs, and it was shown that the resulting data
structure can be built in $ O(m^2 + n^{5/2}) $ time, where $ n $ is the number
of states and $ m $ is the number of edges [SODA 2021]. Recently, algorithms
running in $ O(mn) $ and $ O(n^2\log n) $ time have been described [CPM 2023].
</p>
<p>In this paper, we improve the previous bounds by proposing an $ O(n^2) $
recursive algorithm inspired by Farach's algorithm for building a suffix tree
[FOCS 1997]. To this end, we provide insight into the rich lexicographic and
combinatorial structure of a graph, so contributing to the fascinating journey
which might lead to solve the long-standing open problem of building the suffix
tree of a graph.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Cotumaccio_N/0/1/0/all/0/1">Nicola Cotumaccio</a></p><p>In the past thirty years, numerous algorithms for building the suffix array
of a string have been proposed. In 2021, the notion of suffix array was
extended from strings to DFAs, and it was shown that the resulting data
structure can be built in $ O(m^2 + n^{5/2}) $ time, where $ n $ is the number
of states and $ m $ is the number of edges [SODA 2021]. Recently, algorithms
running in $ O(mn) $ and $ O(n^2\log n) $ time have been described [CPM 2023].
</p>
<p>In this paper, we improve the previous bounds by proposing an $ O(n^2) $
recursive algorithm inspired by Farach's algorithm for building a suffix tree
[FOCS 1997]. To this end, we provide insight into the rich lexicographic and
combinatorial structure of a graph, so contributing to the fascinating journey
which might lead to solve the long-standing open problem of building the suffix
tree of a graph.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-05T00:30:00Z">Friday, May 05 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.02535'>On the Unreasonable Effectiveness of Single Vector Krylov Methods for Low-Rank Approximation</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Raphael A. Meyer, Cameron Musco, Christopher Musco</p><p>Krylov subspace methods are a ubiquitous tool for computing near-optimal rank
$k$ approximations of large matrices. While "large block" Krylov methods with
block size at least $k$ give the best known theoretical guarantees, block size
one (a single vector) or a small constant is often preferred in practice.
Despite their popularity, we lack theoretical bounds on the performance of such
"small block" Krylov methods for low-rank approximation.
</p>
<p>We address this gap between theory and practice by proving that small block
Krylov methods essentially match all known low-rank approximation guarantees
for large block methods. Via a black-box reduction we show, for example, that
the standard single vector Krylov method run for $t$ iterations obtains the
same spectral norm and Frobenius norm error bounds as a Krylov method with
block size $\ell \geq k$ run for $O(t/\ell)$ iterations, up to a logarithmic
dependence on the smallest gap between sequential singular values. That is, for
a given number of matrix-vector products, single vector methods are essentially
as effective as any choice of large block size.
</p>
<p>By combining our result with tail-bounds on eigenvalue gaps in random
matrices, we prove that the dependence on the smallest singular value gap can
be eliminated if the input matrix is perturbed by a small random matrix.
Further, we show that single vector methods match the more complex algorithm of
[Bakshi et al. `22], which combines the results of multiple block sizes to
achieve an improved algorithm for Schatten $p$-norm low-rank approximation.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Meyer_R/0/1/0/all/0/1">Raphael A. Meyer</a>, <a href="http://arxiv.org/find/cs/1/au:+Musco_C/0/1/0/all/0/1">Cameron Musco</a>, <a href="http://arxiv.org/find/cs/1/au:+Musco_C/0/1/0/all/0/1">Christopher Musco</a></p><p>Krylov subspace methods are a ubiquitous tool for computing near-optimal rank
$k$ approximations of large matrices. While "large block" Krylov methods with
block size at least $k$ give the best known theoretical guarantees, block size
one (a single vector) or a small constant is often preferred in practice.
Despite their popularity, we lack theoretical bounds on the performance of such
"small block" Krylov methods for low-rank approximation.
</p>
<p>We address this gap between theory and practice by proving that small block
Krylov methods essentially match all known low-rank approximation guarantees
for large block methods. Via a black-box reduction we show, for example, that
the standard single vector Krylov method run for $t$ iterations obtains the
same spectral norm and Frobenius norm error bounds as a Krylov method with
block size $\ell \geq k$ run for $O(t/\ell)$ iterations, up to a logarithmic
dependence on the smallest gap between sequential singular values. That is, for
a given number of matrix-vector products, single vector methods are essentially
as effective as any choice of large block size.
</p>
<p>By combining our result with tail-bounds on eigenvalue gaps in random
matrices, we prove that the dependence on the smallest singular value gap can
be eliminated if the input matrix is perturbed by a small random matrix.
Further, we show that single vector methods match the more complex algorithm of
[Bakshi et al. `22], which combines the results of multiple block sizes to
achieve an improved algorithm for Schatten $p$-norm low-rank approximation.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-05T00:30:00Z">Friday, May 05 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.02544'>Nearly-Linear Time and Streaming Algorithms for Outlier-Robust PCA</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Ilias Diakonikolas, Daniel M. Kane, Ankit Pensia, Thanasis Pittas</p><p>We study principal component analysis (PCA), where given a dataset in
$\mathbb{R}^d$ from a distribution, the task is to find a unit vector $v$ that
approximately maximizes the variance of the distribution after being projected
along $v$. Despite being a classical task, standard estimators fail drastically
if the data contains even a small fraction of outliers, motivating the problem
of robust PCA. Recent work has developed computationally-efficient algorithms
for robust PCA that either take super-linear time or have sub-optimal error
guarantees. Our main contribution is to develop a nearly-linear time algorithm
for robust PCA with near-optimal error guarantees. We also develop a
single-pass streaming algorithm for robust PCA with memory usage nearly-linear
in the dimension.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Diakonikolas_I/0/1/0/all/0/1">Ilias Diakonikolas</a>, <a href="http://arxiv.org/find/cs/1/au:+Kane_D/0/1/0/all/0/1">Daniel M. Kane</a>, <a href="http://arxiv.org/find/cs/1/au:+Pensia_A/0/1/0/all/0/1">Ankit Pensia</a>, <a href="http://arxiv.org/find/cs/1/au:+Pittas_T/0/1/0/all/0/1">Thanasis Pittas</a></p><p>We study principal component analysis (PCA), where given a dataset in
$\mathbb{R}^d$ from a distribution, the task is to find a unit vector $v$ that
approximately maximizes the variance of the distribution after being projected
along $v$. Despite being a classical task, standard estimators fail drastically
if the data contains even a small fraction of outliers, motivating the problem
of robust PCA. Recent work has developed computationally-efficient algorithms
for robust PCA that either take super-linear time or have sub-optimal error
guarantees. Our main contribution is to develop a nearly-linear time algorithm
for robust PCA with near-optimal error guarantees. We also develop a
single-pass streaming algorithm for robust PCA with memory usage nearly-linear
in the dimension.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-05T00:30:00Z">Friday, May 05 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.02545'>$\alpha_i$-Metric Graphs: Radius, Diameter and all Eccentricities</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Feodor F. Dragan, Guillaume Ducoffe</p><p>We extend known results on chordal graphs and distance-hereditary graphs to
much larger graph classes by using only a common metric property of these
graphs. Specifically, a graph is called $\alpha_i$-metric ($i\in \mathcal{N}$)
if it satisfies the following $\alpha_i$-metric property for every vertices
$u,w,v$ and $x$: if a shortest path between $u$ and $w$ and a shortest path
between $x$ and $v$ share a terminal edge $vw$, then $d(u,x)\geq d(u,v) +
d(v,x)-i$. Roughly, gluing together any two shortest paths along a common
terminal edge may not necessarily result in a shortest path but yields a
``near-shortest'' path with defect at most $i$. It is known that
$\alpha_0$-metric graphs are exactly ptolemaic graphs, and that chordal graphs
and distance-hereditary graphs are $\alpha_i$-metric for $i=1$ and $i=2$,
respectively. We show that an additive $O(i)$-approximation of the radius, of
the diameter, and in fact of all vertex eccentricities of an $\alpha_i$-metric
graph can be computed in total linear time. Our strongest results are obtained
for $\alpha_1$-metric graphs, for which we prove that a central vertex can be
computed in subquadratic time, and even better in linear time for so-called
$(\alpha_1,\Delta)$-metric graphs (a superclass of chordal graphs and of plane
triangulations with inner vertices of degree at least $7$). The latter answers
a question raised in (Dragan, IPL, 2020). Our algorithms follow from new
results on centers and metric intervals of $\alpha_i$-metric graphs. In
particular, we prove that the diameter of the center is at most $3i+2$ (at most
$3$, if $i=1$). The latter partly answers a question raised in (Yushmanov &amp;
Chepoi, Mathematical Problems in Cybernetics, 1991).
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Dragan_F/0/1/0/all/0/1">Feodor F. Dragan</a>, <a href="http://arxiv.org/find/cs/1/au:+Ducoffe_G/0/1/0/all/0/1">Guillaume Ducoffe</a></p><p>We extend known results on chordal graphs and distance-hereditary graphs to
much larger graph classes by using only a common metric property of these
graphs. Specifically, a graph is called $\alpha_i$-metric ($i\in \mathcal{N}$)
if it satisfies the following $\alpha_i$-metric property for every vertices
$u,w,v$ and $x$: if a shortest path between $u$ and $w$ and a shortest path
between $x$ and $v$ share a terminal edge $vw$, then $d(u,x)\geq d(u,v) +
d(v,x)-i$. Roughly, gluing together any two shortest paths along a common
terminal edge may not necessarily result in a shortest path but yields a
``near-shortest'' path with defect at most $i$. It is known that
$\alpha_0$-metric graphs are exactly ptolemaic graphs, and that chordal graphs
and distance-hereditary graphs are $\alpha_i$-metric for $i=1$ and $i=2$,
respectively. We show that an additive $O(i)$-approximation of the radius, of
the diameter, and in fact of all vertex eccentricities of an $\alpha_i$-metric
graph can be computed in total linear time. Our strongest results are obtained
for $\alpha_1$-metric graphs, for which we prove that a central vertex can be
computed in subquadratic time, and even better in linear time for so-called
$(\alpha_1,\Delta)$-metric graphs (a superclass of chordal graphs and of plane
triangulations with inner vertices of degree at least $7$). The latter answers
a question raised in (Dragan, IPL, 2020). Our algorithms follow from new
results on centers and metric intervals of $\alpha_i$-metric graphs. In
particular, we prove that the diameter of the center is at most $3i+2$ (at most
$3$, if $i=1$). The latter partly answers a question raised in (Yushmanov &amp;
Chepoi, Mathematical Problems in Cybernetics, 1991).
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-05T00:30:00Z">Friday, May 05 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.02566'>A Hyperbolic Extension of Kadison-Singer Type Results</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Ruizhe Zhang, Xinzhi Zhang</p><p>In 2013, Marcus, Spielman, and Srivastava resolved the famous Kadison-Singer
conjecture. It states that for $n$ independent random vectors $v_1,\cdots, v_n$
that have expected squared norm bounded by $\epsilon$ and are in the isotropic
position in expectation, there is a positive probability that the determinant
polynomial $\det(xI - \sum_{i=1}^n v_iv_i^\top)$ has roots bounded by $(1 +
\sqrt{\epsilon})^2$. An interpretation of the Kadison-Singer theorem is that we
can always find a partition of the vectors $v_1,\cdots,v_n$ into two sets with
a low discrepancy in terms of the spectral norm (in other words, rely on the
determinant polynomial).
</p>
<p>In this paper, we provide two results for a broader class of polynomials, the
hyperbolic polynomials. Furthermore, our results are in two generalized
settings:
</p>
<p>$\bullet$ The first one shows that the Kadison-Singer result requires a
weaker assumption that the vectors have a bounded sum of hyperbolic norms.
</p>
<p>$\bullet$ The second one relaxes the Kadison-Singer result's distribution
assumption to the Strongly Rayleigh distribution.
</p>
<p>To the best of our knowledge, the previous results only support determinant
polynomials [Anari and Oveis Gharan'14, Kyng, Luh and Song'20]. It is unclear
whether they can be generalized to a broader class of polynomials. In addition,
we also provide a sub-exponential time algorithm for constructing our results.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/math/1/au:+Zhang_R/0/1/0/all/0/1">Ruizhe Zhang</a>, <a href="http://arxiv.org/find/math/1/au:+Zhang_X/0/1/0/all/0/1">Xinzhi Zhang</a></p><p>In 2013, Marcus, Spielman, and Srivastava resolved the famous Kadison-Singer
conjecture. It states that for $n$ independent random vectors $v_1,\cdots, v_n$
that have expected squared norm bounded by $\epsilon$ and are in the isotropic
position in expectation, there is a positive probability that the determinant
polynomial $\det(xI - \sum_{i=1}^n v_iv_i^\top)$ has roots bounded by $(1 +
\sqrt{\epsilon})^2$. An interpretation of the Kadison-Singer theorem is that we
can always find a partition of the vectors $v_1,\cdots,v_n$ into two sets with
a low discrepancy in terms of the spectral norm (in other words, rely on the
determinant polynomial).
</p>
<p>In this paper, we provide two results for a broader class of polynomials, the
hyperbolic polynomials. Furthermore, our results are in two generalized
settings:
</p>
<p>$\bullet$ The first one shows that the Kadison-Singer result requires a
weaker assumption that the vectors have a bounded sum of hyperbolic norms.
</p>
<p>$\bullet$ The second one relaxes the Kadison-Singer result's distribution
assumption to the Strongly Rayleigh distribution.
</p>
<p>To the best of our knowledge, the previous results only support determinant
polynomials [Anari and Oveis Gharan'14, Kyng, Luh and Song'20]. It is unclear
whether they can be generalized to a broader class of polynomials. In addition,
we also provide a sub-exponential time algorithm for constructing our results.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-05T00:30:00Z">Friday, May 05 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.02816'>Shannon meets Gray: Noise-robust, Low-sensitivity Codes with Applications in Differential Privacy</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: David Rasmussen Lolck, Rasmus Pagh</p><p>Integer data is typically made differentially private by adding noise from a
Discrete Laplace (or Discrete Gaussian) distribution. We study the setting
where differential privacy of a counting query is achieved using bit-wise
randomized response, i.e., independent, random bit flips on the encoding of the
query answer.
</p>
<p>Binary error-correcting codes transmitted through noisy channels with
independent bit flips are well-studied in information theory. However, such
codes are unsuitable for differential privacy since they have (by design) high
sensitivity, i.e., neighboring integers have encodings with a large Hamming
distance. Gray codes show that it is possible to create an efficient
sensitivity 1 encoding, but are also not suitable for differential privacy due
to lack of noise-robustness.
</p>
<p>Our main result is that it is possible, with a constant rate code, to
simultaneously achieve the sensitivity of Gray codes and the noise-robustness
of error-correcting codes (down to the noise level required for differential
privacy). An application of this new encoding of the integers is a faster,
space-optimal differentially private data structure for histograms.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Lolck_D/0/1/0/all/0/1">David Rasmussen Lolck</a>, <a href="http://arxiv.org/find/cs/1/au:+Pagh_R/0/1/0/all/0/1">Rasmus Pagh</a></p><p>Integer data is typically made differentially private by adding noise from a
Discrete Laplace (or Discrete Gaussian) distribution. We study the setting
where differential privacy of a counting query is achieved using bit-wise
randomized response, i.e., independent, random bit flips on the encoding of the
query answer.
</p>
<p>Binary error-correcting codes transmitted through noisy channels with
independent bit flips are well-studied in information theory. However, such
codes are unsuitable for differential privacy since they have (by design) high
sensitivity, i.e., neighboring integers have encodings with a large Hamming
distance. Gray codes show that it is possible to create an efficient
sensitivity 1 encoding, but are also not suitable for differential privacy due
to lack of noise-robustness.
</p>
<p>Our main result is that it is possible, with a constant rate code, to
simultaneously achieve the sensitivity of Gray codes and the noise-robustness
of error-correcting codes (down to the noise level required for differential
privacy). An application of this new encoding of the integers is a faster,
space-optimal differentially private data structure for histograms.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-05T00:30:00Z">Friday, May 05 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.02831'>Local Computation Algorithms for Hypergraph Coloring -- following Beck's approach (full version)</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Andrzej Dorobisz, Jakub Kozik</p><p>We investigate local computation algorithms (LCA) for two-coloring of
$k$-uniform hypergraphs. We focus on hypergraph instances that satisfy
strengthened assumption of the Lov\'{a}sz Local Lemma of the form $2^{1-\alpha
k} (\Delta+1) \mathrm{e} &lt; 1$, where $\Delta$ is the bound on the maximum edge
degree. The main question which arises here is for how large $\alpha$ there
exists an LCA that is able to properly color such hypergraphs in
polylogarithmic time per query. We describe briefly how upgrading the classical
sequential procedure of Beck from 1991 with Moser and Tardos' RESAMPLE yields
polylogarithmic LCA that works for $\alpha$ up to $1/4$. Then, we present an
improved procedure that solves wider range of instances by allowing $\alpha$ up
to $1/3$.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Dorobisz_A/0/1/0/all/0/1">Andrzej Dorobisz</a>, <a href="http://arxiv.org/find/cs/1/au:+Kozik_J/0/1/0/all/0/1">Jakub Kozik</a></p><p>We investigate local computation algorithms (LCA) for two-coloring of
$k$-uniform hypergraphs. We focus on hypergraph instances that satisfy
strengthened assumption of the Lov\'{a}sz Local Lemma of the form $2^{1-\alpha
k} (\Delta+1) \mathrm{e} &lt; 1$, where $\Delta$ is the bound on the maximum edge
degree. The main question which arises here is for how large $\alpha$ there
exists an LCA that is able to properly color such hypergraphs in
polylogarithmic time per query. We describe briefly how upgrading the classical
sequential procedure of Beck from 1991 with Moser and Tardos' RESAMPLE yields
polylogarithmic LCA that works for $\alpha$ up to $1/4$. Then, we present an
improved procedure that solves wider range of instances by allowing $\alpha$ up
to $1/3$.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-05T00:30:00Z">Friday, May 05 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.02854'>Near-Optimal Compact Routing and Decomposition Schemes for Planar Graphs</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Jinfeng Dou, Thorsten G&#xf6;tte, Henning Hillebrandt, Christian Scheideler, Julian Werthmann</p><p>We consider the problem of computing compact routing tables for a (weighted)
planar graph $G:= (V, E,w)$ in the PRAM, CONGEST, and the novel HYBRID
communication model. We present algorithms with polylogarithmic work and
communication that are almost optimal in all relevant parameters, i.e.,
computation time, table sizes, and stretch. All algorithms are heavily
randomized, and all our bounds hold w.h.p. For a given parameter $\epsilon&gt;0$,
our scheme computes labels of size $\widetilde{O}(\epsilon^{-1})$ and is
computed in $\widetilde{O}(\epsilon^{-2})$ time and $\widetilde{O}(n)$ work in
the PRAM and a HYBRID model and $\widetilde{O}(\epsilon^{-2} \cdot HD)$ (Here,
$HD$ denotes the network's hop-diameter) time in CONGEST. The stretch of the
resulting routing scheme is $1+\epsilon$. To achieve these results, we extend
the divide-and-conquer framework of Li and Parter [STOC '19] and combine it
with state-of-the-art distributed distance approximation algorithms [STOC '22].
Furthermore, we provide a distributed decomposition scheme, which may be of
independent interest.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Dou_J/0/1/0/all/0/1">Jinfeng Dou</a>, <a href="http://arxiv.org/find/cs/1/au:+Gotte_T/0/1/0/all/0/1">Thorsten G&#xf6;tte</a>, <a href="http://arxiv.org/find/cs/1/au:+Hillebrandt_H/0/1/0/all/0/1">Henning Hillebrandt</a>, <a href="http://arxiv.org/find/cs/1/au:+Scheideler_C/0/1/0/all/0/1">Christian Scheideler</a>, <a href="http://arxiv.org/find/cs/1/au:+Werthmann_J/0/1/0/all/0/1">Julian Werthmann</a></p><p>We consider the problem of computing compact routing tables for a (weighted)
planar graph $G:= (V, E,w)$ in the PRAM, CONGEST, and the novel HYBRID
communication model. We present algorithms with polylogarithmic work and
communication that are almost optimal in all relevant parameters, i.e.,
computation time, table sizes, and stretch. All algorithms are heavily
randomized, and all our bounds hold w.h.p. For a given parameter $\epsilon&gt;0$,
our scheme computes labels of size $\widetilde{O}(\epsilon^{-1})$ and is
computed in $\widetilde{O}(\epsilon^{-2})$ time and $\widetilde{O}(n)$ work in
the PRAM and a HYBRID model and $\widetilde{O}(\epsilon^{-2} \cdot HD)$ (Here,
$HD$ denotes the network's hop-diameter) time in CONGEST. The stretch of the
resulting routing scheme is $1+\epsilon$. To achieve these results, we extend
the divide-and-conquer framework of Li and Parter [STOC '19] and combine it
with state-of-the-art distributed distance approximation algorithms [STOC '22].
Furthermore, we provide a distributed decomposition scheme, which may be of
independent interest.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-05T00:30:00Z">Friday, May 05 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.02922'>Coloring tournaments with few colors: Algorithms and complexity</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Felix Klingelhoefer, Alantha Newman</p><p>A k-coloring of a tournament is a partition of its vertices into k acyclic
sets. Deciding if a tournament is 2-colorable is NP-hard. A natural problem,
akin to that of coloring a 3-colorable graph with few colors, is to color a
2-colorable tournament with few colors. This problem does not seem to have been
addressed before, although it is a special case of coloring a 2-colorable
3-uniform hypergraph with few colors, which is a well-studied problem with
super-constant lower bounds.
</p>
<p>We present an efficient decomposition lemma for tournaments and show that it
can be used to design polynomial-time algorithms to color various classes of
tournaments with few colors, including an algorithm to color a 2-colorable
tournament with ten colors. For the classes of tournaments considered, we
complement our upper bounds with strengthened lower bounds, painting a
comprehensive picture of the algorithmic and complexity aspects of coloring
tournaments.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Klingelhoefer_F/0/1/0/all/0/1">Felix Klingelhoefer</a>, <a href="http://arxiv.org/find/cs/1/au:+Newman_A/0/1/0/all/0/1">Alantha Newman</a></p><p>A k-coloring of a tournament is a partition of its vertices into k acyclic
sets. Deciding if a tournament is 2-colorable is NP-hard. A natural problem,
akin to that of coloring a 3-colorable graph with few colors, is to color a
2-colorable tournament with few colors. This problem does not seem to have been
addressed before, although it is a special case of coloring a 2-colorable
3-uniform hypergraph with few colors, which is a well-studied problem with
super-constant lower bounds.
</p>
<p>We present an efficient decomposition lemma for tournaments and show that it
can be used to design polynomial-time algorithms to color various classes of
tournaments with few colors, including an algorithm to color a 2-colorable
tournament with ten colors. For the classes of tournaments considered, we
complement our upper bounds with strengthened lower bounds, painting a
comprehensive picture of the algorithmic and complexity aspects of coloring
tournaments.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-05T00:30:00Z">Friday, May 05 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.02946'>What Else Can Voronoi Diagrams Do For Diameter In Planar Graphs?</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Amir Abboud, Shay Mozes, Oren Weimann</p><p>The Voronoi diagrams technique was introduced by Cabello to compute the
diameter of planar graphs in subquadratic time. We present novel applications
of this technique in static, fault-tolerant, and partially-dynamic undirected
unweighted planar graphs, as well as some new limitations.
</p>
<p>1. In the static case, we give $n^{3+o(1)}/D^2$ and $\tilde{O}(n\cdot D^2)$
time algorithms for computing the diameter of a planar graph $G$ with diameter
$D$. These are faster than the state of the art $\tilde{O}(n^{5/3})$ when
$D&lt;n^{1/3}$ or $D&gt;n^{2/3}$.
</p>
<p>2. In the fault-tolerant setting, we give an $n^{7/3+o(1)}$ time algorithm
for computing the diameter of $G\setminus \{e\}$ for every edge $e$ in $G$ (the
replacement diameter problem). Compared to the naive $\tilde{O}(n^{8/3})$ time
algorithm that runs the static algorithm for every edge.
</p>
<p>3. In the incremental setting, where we wish to maintain the diameter while
while adding edges, we present an algorithm with total running time
$n^{7/3+o(1)}$. Compared to the naive $\tilde{O}(n^{8/3})$ time algorithm that
runs the static algorithm after every update.
</p>
<p>4. We give a lower bound (conditioned on the SETH) ruling out an amortized
$O(n^{1-\varepsilon})$ update time for maintaining the diameter in {\em
weighted} planar graph. The lower bound holds even for incremental or
decremental updates.
</p>
<p>Our upper bounds are obtained by novel uses and manipulations of Voronoi
diagrams. These include maintaining the Voronoi diagram when edges of the graph
are deleted, allowing the sites of the Voronoi diagram to lie on a BFS tree
level (rather than on boundaries of $r$-division), and a new reduction from
incremental diameter to incremental {\em distance oracles} that could be of
interest beyond planar graphs. Our lower bound is the first lower bound for a
dynamic planar graph problem that is conditioned on the SETH.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Abboud_A/0/1/0/all/0/1">Amir Abboud</a>, <a href="http://arxiv.org/find/cs/1/au:+Mozes_S/0/1/0/all/0/1">Shay Mozes</a>, <a href="http://arxiv.org/find/cs/1/au:+Weimann_O/0/1/0/all/0/1">Oren Weimann</a></p><p>The Voronoi diagrams technique was introduced by Cabello to compute the
diameter of planar graphs in subquadratic time. We present novel applications
of this technique in static, fault-tolerant, and partially-dynamic undirected
unweighted planar graphs, as well as some new limitations.
</p>
<p>1. In the static case, we give $n^{3+o(1)}/D^2$ and $\tilde{O}(n\cdot D^2)$
time algorithms for computing the diameter of a planar graph $G$ with diameter
$D$. These are faster than the state of the art $\tilde{O}(n^{5/3})$ when
$D&lt;n^{1/3}$ or $D&gt;n^{2/3}$.
</p>
<p>2. In the fault-tolerant setting, we give an $n^{7/3+o(1)}$ time algorithm
for computing the diameter of $G\setminus \{e\}$ for every edge $e$ in $G$ (the
replacement diameter problem). Compared to the naive $\tilde{O}(n^{8/3})$ time
algorithm that runs the static algorithm for every edge.
</p>
<p>3. In the incremental setting, where we wish to maintain the diameter while
while adding edges, we present an algorithm with total running time
$n^{7/3+o(1)}$. Compared to the naive $\tilde{O}(n^{8/3})$ time algorithm that
runs the static algorithm after every update.
</p>
<p>4. We give a lower bound (conditioned on the SETH) ruling out an amortized
$O(n^{1-\varepsilon})$ update time for maintaining the diameter in {\em
weighted} planar graph. The lower bound holds even for incremental or
decremental updates.
</p>
<p>Our upper bounds are obtained by novel uses and manipulations of Voronoi
diagrams. These include maintaining the Voronoi diagram when edges of the graph
are deleted, allowing the sites of the Voronoi diagram to lie on a BFS tree
level (rather than on boundaries of $r$-division), and a new reduction from
incremental diameter to incremental {\em distance oracles} that could be of
interest beyond planar graphs. Our lower bound is the first lower bound for a
dynamic planar graph problem that is conditioned on the SETH.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-05T00:30:00Z">Friday, May 05 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.02987'>Convergence to Lexicographically Optimal Base in a (Contra)Polymatroid and Applications to Densest Subgraph and Tree Packing</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Elfarouk Harb, Kent Quanrud, Chandra Chekuri</p><p>Boob et al. [1] described an iterative peeling algorithm called Greedy++ for
the Densest Subgraph Problem (DSG) and conjectured that it converges to an
optimum solution. Chekuri, Quanrud, and Torres [2] extended the algorithm to
general supermodular density problems (of which DSG is a special case) and
proved that the resulting algorithm Super-Greedy++ (and hence also Greedy++)
converges. In this paper, we revisit the convergence proof and provide a
different perspective. This is done via a connection to Fujishige's quadratic
program for finding a lexicographically optimal base in a (contra)polymatroid
[3], and a noisy version of the Frank-Wolfe method from convex optimisation
[4,5]. This gives us a simpler convergence proof, and also shows a stronger
property that Super-Greedy++ converges to the optimal dense decomposition
vector, answering a question raised in Harb et al. [6]. A second contribution
of the paper is to understand Thorup's work on ideal tree packing and greedy
tree packing [7,8] via the Frank-Wolfe algorithm applied to find a
lexicographically optimum base in the graphic matroid. This yields a simpler
and transparent proof. The two results appear disparate but are unified via
Fujishige's result and convex optimisation.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Harb_E/0/1/0/all/0/1">Elfarouk Harb</a>, <a href="http://arxiv.org/find/cs/1/au:+Quanrud_K/0/1/0/all/0/1">Kent Quanrud</a>, <a href="http://arxiv.org/find/cs/1/au:+Chekuri_C/0/1/0/all/0/1">Chandra Chekuri</a></p><p>Boob et al. [1] described an iterative peeling algorithm called Greedy++ for
the Densest Subgraph Problem (DSG) and conjectured that it converges to an
optimum solution. Chekuri, Quanrud, and Torres [2] extended the algorithm to
general supermodular density problems (of which DSG is a special case) and
proved that the resulting algorithm Super-Greedy++ (and hence also Greedy++)
converges. In this paper, we revisit the convergence proof and provide a
different perspective. This is done via a connection to Fujishige's quadratic
program for finding a lexicographically optimal base in a (contra)polymatroid
[3], and a noisy version of the Frank-Wolfe method from convex optimisation
[4,5]. This gives us a simpler convergence proof, and also shows a stronger
property that Super-Greedy++ converges to the optimal dense decomposition
vector, answering a question raised in Harb et al. [6]. A second contribution
of the paper is to understand Thorup's work on ideal tree packing and greedy
tree packing [7,8] via the Frank-Wolfe algorithm applied to find a
lexicographically optimum base in the graphic matroid. This yields a simpler
and transparent proof. The two results appear disparate but are unified via
Fujishige's result and convex optimisation.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-05T00:30:00Z">Friday, May 05 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.03000'>Ranking and unranking bordered and unbordered words</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Daniel Gabric</p><p>A \emph{border} of a word $w$ is a word that is both a non-empty proper
prefix and suffix of $w$. If $w$ has a border, then it is said to be
\emph{bordered}; otherwise, it is said to be \emph{unbordered}. The main
results of this paper are the first algorithms to rank and unrank length-$n$
bordered and unbordered words over a $k$-letter alphabet. We show that ranking
bordered and unbordered words can be done in $O(kn^3)$ time using $O(n)$ space,
and unranking them can be done in $O(n^4k\log k)$ time using $O(n)$ space.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Gabric_D/0/1/0/all/0/1">Daniel Gabric</a></p><p>A \emph{border} of a word $w$ is a word that is both a non-empty proper
prefix and suffix of $w$. If $w$ has a border, then it is said to be
\emph{bordered}; otherwise, it is said to be \emph{unbordered}. The main
results of this paper are the first algorithms to rank and unrank length-$n$
bordered and unbordered words over a $k$-letter alphabet. We show that ranking
bordered and unbordered words can be done in $O(kn^3)$ time using $O(n)$ space,
and unranking them can be done in $O(n^4k\log k)$ time using $O(n)$ space.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-05T00:30:00Z">Friday, May 05 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    
    <h2 class='tr-new-date'>
      <i class='fa-regular fa-calendar'></i> Thursday, May 04
    </h2>
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='https://rjlipton.wpcomstaging.com/2023/05/04/a-ttic-talk/'>A TTIC Talk</a></h3>
        <p class='tr-article-feed'>from <a href='https://rjlipton.wpcomstaging.com'>Richard Lipton</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          Julia Chuzhoy is a professor at TTIC&#8212;the Toyota Technological Institute at Chicago. She is giving a talk this Friday at TTIC, 6045 S. Kenwood Avenue in the 5th Floor, Room 530. Her title is, &#8220;On Fixing Some Issues with Expanders.&#8221; An associated paper by her, however, has a much longer title. Ken and I wrote [&#8230;]
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p>
Julia Chuzhoy is a professor at <a href="https://home.ttic.edu/~cjulia/">TTIC</a>&#8212;the Toyota Technological Institute at Chicago. She is giving a talk this Friday at TTIC, 6045 S. Kenwood Avenue in the 5th Floor, Room 530. Her title is, &#8220;On Fixing Some Issues with Expanders.&#8221; An associated <a href="https://home.ttic.edu/~cjulia/papers/APSP-expanders.pdf">paper</a> by her, however, has a much longer title. </p>
<p><P><br />
<a href="https://rjlipton.wpcomstaging.com/2023/05/04/a-ttic-talk/jc-2/" rel="attachment wp-att-21600"><img data-attachment-id="21600" data-permalink="https://rjlipton.wpcomstaging.com/2023/05/04/a-ttic-talk/jc-2/" data-orig-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/05/jc.jpeg?fit=221%2C228&amp;ssl=1" data-orig-size="221,228" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="jc" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/05/jc.jpeg?fit=221%2C228&amp;ssl=1" data-large-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/05/jc.jpeg?fit=221%2C228&amp;ssl=1" decoding="async" loading="lazy" src="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/05/jc.jpeg?resize=221%2C228&#038;ssl=1" alt="" width="221" height="228" class="aligncenter size-full wp-image-21600" data-recalc-dims="1" /></a></p>
<p><P><br />
Ken and I wrote a <a href="https://rjlipton.wpcomstaging.com/2015/06/08/minor-insights-are-useful/">post</a> on her work a while ago in 2015. That was on a joint result with Chandra Chekuri. He is the Paul and Cynthia Sayles Professor at UIUC. </p>
<p>
<a href="https://rjlipton.wpcomstaging.com/2023/05/04/a-ttic-talk/cc-2/" rel="attachment wp-att-21601"><img data-attachment-id="21601" data-permalink="https://rjlipton.wpcomstaging.com/2023/05/04/a-ttic-talk/cc-2/" data-orig-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/05/cc.jpeg?fit=201%2C251&amp;ssl=1" data-orig-size="201,251" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="cc" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/05/cc.jpeg?fit=201%2C251&amp;ssl=1" data-large-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/05/cc.jpeg?fit=201%2C251&amp;ssl=1" decoding="async" loading="lazy" src="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/05/cc.jpeg?resize=160%2C200&#038;ssl=1" alt="" width="160" height="200" class="aligncenter wp-image-21601" data-recalc-dims="1" /></a></p>
<p><H2> A Well-Connected Talk </H2></p>
<p><p>
I am visiting TTIC till Friday and have to then return to home. So I will have to miss her talk. I hope it is well-connected enough that some of it gets back to me. Let me know how it goes. </p>
<p>
I believe the main thrust of her talk should interest many since it attends to an important issue. The concept of expander graph is wonderful and has great connections to other areas of combinatorics, but the condition is costly to instantiate and verify and may go beyond what many algorithms truly need for good performance. Her method to weaken-and-sidestep the requirements, centered around a notion of <em>well-connected</em> graphs, should help extend applications of the general technology. She says:</p>
<blockquote><p><b> </b> <em> We believe that the use of well-connected graphs instead of expanders in various dynamic distance-based problems (such as APSP in general graphs) has the potential of providing much stronger guarantees, since we are no longer necessarily restricted to superlogarithmic approximation factors. </em>
</p></blockquote>
<p>
<p><H2> Open Problems </H2></p>
<p><p>
Enjoy the talk. I think the results that follow from weakening expanders could be quite powerful. </p>
<p>
<p class="authors">By rjlipton</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-04T23:25:49Z">Thursday, May 04 2023, 23:25</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='https://eccc.weizmann.ac.il/report/2023/065'>TR23-065 |  From Grassmannian to Simplicial High-Dimensional Expanders | 

	Louis Golowich</a></h3>
        <p class='tr-article-feed'>from <a href='https://eccc.weizmann.ac.il/'>ECCC Papers</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          In this paper, we present a new construction of simplicial complexes of subpolynomial degree with arbitrarily good local spectral expansion. Previously, the only known high-dimensional expanders (HDXs) with arbitrarily good expansion and less than polynomial degree were based on one of two constructions, namely Ramanujan complexes and coset complexes. In contrast, our construction is a Cayley complex over the group $\mathbb{F}_2^k$, with Cayley generating set given by a Grassmannian HDX.

  Our construction is in part motivated by a coding-theoretic interpretation of Grassmannian HDXs that we present, which provides a formal connection between Grassmannian HDXs, simplicial HDXs, and LDPC codes. We apply this interpretation to prove a general characterization of the 1-homology groups over $\mathbb{F}_2$ of Cayley simplicial complexes over $\mathbb{F}_2^k$. Using this result, we construct simplicial complexes on $N$ vertices with arbitrarily good local expansion for which the dimension of the 1-homology group grows as $\Omega(\log^2N)$. No prior constructions in the literature have been shown to achieve as large a 1-homology group.
        
        </div>

        <div class='tr-article-summary'>
        
          
          In this paper, we present a new construction of simplicial complexes of subpolynomial degree with arbitrarily good local spectral expansion. Previously, the only known high-dimensional expanders (HDXs) with arbitrarily good expansion and less than polynomial degree were based on one of two constructions, namely Ramanujan complexes and coset complexes. In contrast, our construction is a Cayley complex over the group $\mathbb{F}_2^k$, with Cayley generating set given by a Grassmannian HDX.

  Our construction is in part motivated by a coding-theoretic interpretation of Grassmannian HDXs that we present, which provides a formal connection between Grassmannian HDXs, simplicial HDXs, and LDPC codes. We apply this interpretation to prove a general characterization of the 1-homology groups over $\mathbb{F}_2$ of Cayley simplicial complexes over $\mathbb{F}_2^k$. Using this result, we construct simplicial complexes on $N$ vertices with arbitrarily good local expansion for which the dimension of the 1-homology group grows as $\Omega(\log^2N)$. No prior constructions in the literature have been shown to achieve as large a 1-homology group.
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-04T13:54:49Z">Thursday, May 04 2023, 13:54</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='https://blog.computationalcomplexity.org/2023/05/breaking-ground-in-isomorphism-testing.html'>Breaking Ground in Isomorphism Testing: A Leap Forward for a Bottleneck Case of Group Isomorphism</a></h3>
        <p class='tr-article-feed'>from <a href='http://blog.computationalcomplexity.org/'>Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Guest post by Josh Grochow and Youming Qiao</p><p>There has, quietly, been somewhat of a breakthrough in isomorphism testing. No, not as big as Babai's 2016 Graph Isomorphism in Quasipolynomial Time. But a first foothold in climbing a wall for which no one had gotten much off the ground before. The result, due to Xiaorui Sun in this year's STOC, is an algorithm for testing isomorphism of a certain class of groups - p-groups of class 2 and exponent p if you must know, but we'll get to that - in time \(n^{O(\log^{5/6} n)}\) where n is the order of the group. To understand why we're excited about this we have to tell a bit of a story.&nbsp;</p><p>In the 1970s, when Graph Isomorphism was still a mystery, people also thought more widely about isomorphism testing of other combinatorial and algebraic structures. For finite groups of order n, Robert Tarjan realized that there is an \(n^{\log n+O(1)}\)-time algorithm, simply because a group of order n has a generating set of size \(\log n\). This observation was recorded by Gary Miller in a paper in STOC'78, and independently realized by Felsch and Neubüser. A natural question is then whether Group Isomorphism can be solved in time poly(n) where n is the group order.</p><br><p>Not only is this question natural from the perspective of studying groups computationally, it is also natural from the perspective of Graph Isomorphism. For Group Isomorphism reduces to Graph Isomorphism in polynomial-time (as does the isomorphism problem for any finite algebraic or relational structure, see Zemlyachenko, Korneenko, &amp; Tyshkevich). While this has been known for a long time, Babai’s result on Graph Isomorphism brings the running times quite close: \(n^{O(\log^2 n)}\) for graphs, and \(n^{O(\log n)}\) for groups. So not only does Group Isomorphism stand in the way of getting Graph Isomorphism into P, but in our current state of knowledge, it even stands in the way of shaving off more than a single log in the exponent of the runtime.</p><br><p>Since the general Group Isomorphism problem seems difficult, attention turned to special classes of groups. It was not hard to see that isomorphism of Abelian groups could be computed in polynomial time. However, a group class that is just “one step away” from Abelian - groups G where, when you mod out by the center Z(G), what’s left is Abelian -&nbsp; turned out to be difficult. Such groups are called class-2 nilpotent, and in one sense, their&nbsp; group-theoretic structure is relatively straightforward: both G/Z(G) and Z(G) are Abelian. Yet, to devise an efficient isomorphism testing procedure turned out to be extremely difficult (see e.g. Garzon-Zalcstein, Rosenbaum-Wagner, O’Brien, Wilson), to the point that this is usually considered as a bottleneck for putting Group Isomorphism in P.&nbsp;</p><br><p>Among class-2 nilpotent groups, the “key case” to resolve is widely believed, for several reasons, to be p-groups of class 2 and exponent p. In such groups, both the center Z(G) and quotient G/Z(G) are elementary abelian, i.e., of the form \((Z_p)^d\). Despite having an even simpler group-theoretic structure, this group class still turns out to be difficult! For a long time, the asymptotic growth of the exponent of the runtime for solving this restricted problem has not improved over the \(n^{\log n+O(1)}\)-time algorithm, which works for all groups.1</p><br><p>Xiaorui Sun’s result represents the first substantial improvement, cracking open this decades-old quest. His algorithm runs in time \(n^{O(\log^{5/6} n)}\), and its techniques are indeed novel. The starting point of this algorithm is to consider the following equivalent problem in (multi)linear algebra: let \(f, g:Z_p^d \times Z_p^d \rightarrow Z_p^e\) be two skew-symmetric bilinear maps. Do there exist change of bases A in \(GL(d, p)\) and B in \(GL(e, p)\), such that for all \(u, v\) in \(Z_p^d\), \(f(A(u), A(v))=B(g(u, v))\)?</p><br><p>Baer’s Correspondence sets up an equivalence of categories between p-groups of class 2 and exponent p, and skew-symmetric bilinear maps over \(Z_p\). This viewpoint allows Xiaorui to use multilinear algebra to study the structure of these bilinear maps. He also crucially depends on a result of Ivanyos and Qiao, which built on Wilson’s use of involutive algebras in this context. He also uses the individualization-and-refinement technique (but for matrix spaces, not graphs!), a characterization of spaces of matrices of low rank, and reducing a tensor to a “semi-canonical” form part of which is somewhat reminiscent of the Tucker decomposition.</p><br><p>All this results in an algorithm which solves the above problem on bilinear maps in time \(p^{(d+e)^{1.8} \log p}\). For groups of order \(p^n\) with \(\log_p(n)\) larger than \(\log^5 p\), Baer’s Correspondence then says that this algorithm does it; when \(\log_p n\) is smaller than \(log^5 p,\) he can fall back on the generator-enumerator algorithm, since the number of generators is at most \(log_p n\).</p><br><p>For us, who have been working on Group Isomorphism for more than a decade, Xiaorui’s result represents an exciting development on this classic algorithmic problem, and we look forward to seeing more progress in this direction in the near future.&nbsp;</p><p></p>1Rosenbaum &amp; Wagner improved the exponent to \(\frac{1}{2}\log {p(n)} + O(1)\), and later improved to \(\frac{1}{4}\log {p(n)} + O(1)\) for all groups, see p.5 of Le Gall &amp; Rosenbaum. In 2014, at a conference on Groups, Computation, and Geometry organized by Wilson, Brooksbank, Hulpke, Kantor, and Penttila, it was concluded that modern practical methods, such as those used in GAP and MAGMA, still take \(n^{O(\log n)}\) steps in the worst case.<p></p><p>By Lance Fortnow</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p><span style="font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;"><i>Guest post by Josh Grochow and </i></span><span style="font-family: Arial;"><span style="font-size: 14.6667px; white-space: pre-wrap;"><i>Youming Qiao</i></span></span></p><p><span style="font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;">There has, quietly, been somewhat of a breakthrough in isomorphism testing. No, not as big as Babai's 2016 </span><a href="https://arxiv.org/abs/1512.03547" style="text-decoration-line: none;"><span style="color: #1155cc; font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; text-decoration-line: underline; text-decoration-skip-ink: none; vertical-align: baseline; white-space: pre-wrap;">Graph Isomorphism in Quasipolynomial Time</span></a><span style="font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;">. But a first foothold in climbing a wall for which no one had gotten much off the ground before. The result, due to </span><a href="https://arxiv.org/abs/2303.15412" style="text-decoration-line: none;"><span style="color: #1155cc; font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; text-decoration-line: underline; text-decoration-skip-ink: none; vertical-align: baseline; white-space: pre-wrap;">Xiaorui Sun in this year's STOC</span></a><span style="font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;">, is an algorithm for testing isomorphism of a certain class of groups - p-groups of class 2 and exponent p if you must know, but we'll get to that - in time \(n^{O(\log^{5/6} n)}\) where n is the order of the group. To understand why we're excited about this we have to tell a bit of a story.&nbsp;</span></p><span id="docs-internal-guid-259ecb6b-7fff-b1a3-e5ab-283b928791b9"><p dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;">In the 1970s, when Graph Isomorphism was still a mystery, people also thought more widely about isomorphism testing of other combinatorial and algebraic structures. For finite groups of order n, Robert Tarjan realized that there is an \(n^{\log n+O(1)}\)-time algorithm, simply because a group of order n has a generating set of size \(\log n\). This observation was recorded by Gary Miller in a </span><a href="https://doi.org/10.1145/800133.804331" style="text-decoration-line: none;"><span style="color: #1155cc; font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; text-decoration-line: underline; text-decoration-skip-ink: none; vertical-align: baseline; white-space: pre-wrap;">paper in STOC'78</span></a><span style="font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;">, and independently realized by </span><a href="https://www.sciencedirect.com/science/article/abs/pii/B9780080129754500114" style="text-decoration-line: none;"><span style="color: #1155cc; font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; text-decoration-line: underline; text-decoration-skip-ink: none; vertical-align: baseline; white-space: pre-wrap;">Felsch and Neubüser</span></a><span style="font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;">. A natural question is then whether Group Isomorphism can be solved in time poly(n) where n is the group order.</span></p><br /><p dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;">Not only is this question natural from the perspective of studying groups computationally, it is also natural from the perspective of </span><span style="font-family: Arial; font-size: 11pt; font-style: italic; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;">Graph</span><span style="font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;"> Isomorphism. For Group Isomorphism reduces to Graph Isomorphism in polynomial-time (as does the isomorphism problem for any finite algebraic or relational structure, see </span><a href="https://doi.org/10.1007/BF02104746" style="text-decoration-line: none;"><span style="color: #1155cc; font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; text-decoration-line: underline; text-decoration-skip-ink: none; vertical-align: baseline; white-space: pre-wrap;">Zemlyachenko, Korneenko, &amp; Tyshkevich</span></a><span style="font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;">). While this has been known for a long time, Babai’s result on Graph Isomorphism brings the running times quite close: \(n^{O(\log^2 n)}\) for graphs, and \(n^{O(\log n)}\) for groups. So not only does Group Isomorphism stand in the way of getting Graph Isomorphism into P, but in our current state of knowledge, it even stands in the way of shaving off more than a single log in the exponent of the runtime.</span></p><br /><p dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;">Since the general Group Isomorphism problem seems difficult, attention turned to special classes of groups. It was not hard to see that isomorphism of Abelian groups could be computed in polynomial time. However, a group class that is just “one step away” from Abelian - groups G where, when you mod out by the center Z(G), what’s left is Abelian -&nbsp; turned out to be difficult. Such groups are called class-2 nilpotent, and in one sense, their&nbsp; group-theoretic structure is relatively straightforward: both G/Z(G) and Z(G) are Abelian. Yet, to devise an efficient isomorphism testing procedure turned out to be extremely difficult (see e.g. </span><a href="https://doi.org/10.1016/0022-0000(91)90012-T" style="text-decoration-line: none;"><span style="color: #1155cc; font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; text-decoration-line: underline; text-decoration-skip-ink: none; vertical-align: baseline; white-space: pre-wrap;">Garzon-Zalcstein</span></a><span style="font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;">, </span><a href="https://doi.org/10.1016/j.tcs.2015.05.036" style="text-decoration-line: none;"><span style="color: #1155cc; font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; text-decoration-line: underline; text-decoration-skip-ink: none; vertical-align: baseline; white-space: pre-wrap;">Rosenbaum-Wagner</span></a><span style="font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;">, </span><a href="https://www.math.auckland.ac.nz/~obrien/research/isom.pdf" style="text-decoration-line: none;"><span style="color: #1155cc; font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; text-decoration-line: underline; text-decoration-skip-ink: none; vertical-align: baseline; white-space: pre-wrap;">O’Brien</span></a><span style="font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;">, </span><a href="https://www.sciencedirect.com/science/article/pii/S0021869309004463" style="text-decoration-line: none;"><span style="color: #1155cc; font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; text-decoration-line: underline; text-decoration-skip-ink: none; vertical-align: baseline; white-space: pre-wrap;">Wilson</span></a><span style="font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;">), to the point that this is usually considered as a bottleneck for putting Group Isomorphism in P.&nbsp;</span></p><br /><p dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;">Among class-2 nilpotent groups, the “key case” to resolve is widely believed, </span><a href="https://cstheory.stackexchange.com/a/42551/129" style="text-decoration-line: none;"><span style="color: #1155cc; font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; text-decoration-line: underline; text-decoration-skip-ink: none; vertical-align: baseline; white-space: pre-wrap;">for several reasons</span></a><span style="font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;">, to be p-groups of class 2 and exponent p. In such groups, both the center Z(G) and quotient G/Z(G) are elementary abelian, i.e., of the form \((Z_p)^d\). Despite having an even simpler group-theoretic structure, this group class still turns out to be difficult! For a long time, the asymptotic growth of the exponent of the runtime for solving this restricted problem has not improved over the \(n^{\log n+O(1)}\)-time algorithm, which works for all groups.<sup>1</sup></span></p><br /><p dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;">Xiaorui Sun’s result represents the first substantial improvement, cracking open this decades-old quest. His algorithm runs in time \(n^{O(\log^{5/6} n)}\), and its techniques are indeed novel. The starting point of this algorithm is to consider the following equivalent problem in (multi)linear algebra: let \(f, g:Z_p^d \times Z_p^d \rightarrow Z_p^e\) be two skew-symmetric bilinear maps. Do there exist change of bases A in \(GL(d, p)\) and B in \(GL(e, p)\), such that for all \(u, v\) in \(Z_p^d\), \(f(A(u), A(v))=B(g(u, v))\)?</span></p><br /><p dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><a href="https://www.jstor.org/stable/1989886" style="text-decoration-line: none;"><span style="color: #1155cc; font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; text-decoration-line: underline; text-decoration-skip-ink: none; vertical-align: baseline; white-space: pre-wrap;">Baer’s Correspondence</span></a><span style="font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;"> sets up an equivalence of categories between p-groups of class 2 and exponent p, and skew-symmetric bilinear maps over \(Z_p\). This viewpoint allows Xiaorui to use multilinear algebra to study the structure of these bilinear maps. He also crucially depends on a result of </span><a href="https://doi.org/10.1137/18M1165682" style="text-decoration-line: none;"><span style="color: #1155cc; font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; text-decoration-line: underline; text-decoration-skip-ink: none; vertical-align: baseline; white-space: pre-wrap;">Ivanyos and Qiao</span></a><span style="font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;">, which built on </span><a href="https://doi.org/10.1016/j.jalgebra.2009.07.029" style="text-decoration-line: none;"><span style="color: #1155cc; font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; text-decoration-line: underline; text-decoration-skip-ink: none; vertical-align: baseline; white-space: pre-wrap;">Wilson’s use</span></a><span style="font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;"> of involutive algebras in this context. He also uses the individualization-and-refinement technique (but for matrix spaces, not graphs!), a characterization of spaces of matrices of low rank, and reducing a tensor to a “semi-canonical” form part of which is somewhat reminiscent of the Tucker decomposition.</span></p><br /><p dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;">All this results in an algorithm which solves the above problem on bilinear maps in time \(p^{(d+e)^{1.8} \log p}\). For groups of order \(p^n\) with \(\log_p(n)\) larger than \(\log^5 p\), Baer’s Correspondence then says that this algorithm does it; when \(\log_p n\) is smaller than \(log^5 p,\) he can fall back on the generator-enumerator algorithm, since the number of generators is at most \(log_p n\).</span></p><br /><p dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;">For us, who have been working on Group Isomorphism for more than a decade, Xiaorui’s result represents an exciting development on this classic algorithmic problem, and we look forward to seeing more progress in this direction in the near future.&nbsp;</span></p><p dir="ltr" style="line-height: 1.38; margin-bottom: 0pt; margin-top: 0pt;"><span style="font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;"><span style="font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline;"></span></span></p><hr /><span style="font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline; white-space: pre-wrap;"><span style="font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline;"><sup>1</sup></span><a href="https://doi.org/10.1016/j.tcs.2015.05.036" style="font-family: &quot;Times New Roman&quot;; font-size: medium; text-decoration-line: none; white-space: normal;"><span style="color: #1155cc; font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; text-decoration-line: underline; text-decoration-skip-ink: none; vertical-align: baseline; white-space: pre-wrap;">Rosenbaum &amp; Wagner</span></a><span style="font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline;"> improved the exponent to \(\frac{1}{2}\log {p(n)} + O(1)\), and later improved to \(\frac{1}{4}\log {p(n)} + O(1)\) for all groups, see p.5 of </span><a href="https://arxiv.org/abs/1609.08253" style="font-family: &quot;Times New Roman&quot;; font-size: medium; text-decoration-line: none; white-space: normal;"><span style="color: #1155cc; font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; text-decoration-line: underline; text-decoration-skip-ink: none; vertical-align: baseline; white-space: pre-wrap;">Le Gall &amp; Rosenbaum</span></a><span style="font-family: Arial; font-size: 11pt; font-variant-alternates: normal; font-variant-east-asian: normal; font-variant-numeric: normal; vertical-align: baseline;">. In 2014, at a conference on Groups, Computation, and Geometry organized by Wilson, Brooksbank, Hulpke, Kantor, and Penttila, it was concluded that modern practical methods, such as those used in GAP and MAGMA, still take \(n^{O(\log n)}\) steps in the worst case.</span></span><p></p></span><p class="authors">By Lance Fortnow</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-04T11:12:00Z">Thursday, May 04 2023, 11:12</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='https://cstheory-jobs.org/2023/05/04/phd-student-at-department-of-computer-and-information-science-linkoping-university-apply-by-may-28-2023/'>PhD Student at Department of Computer and Information Science, Linköping University (apply by May 28, 2023)</a></h3>
        <p class='tr-article-feed'>from <a href='https://cstheory-jobs.org'>CCI: jobs</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          Linköping University advertises one (1) position as PhD student in Computer Science. The PhD student will be supervised by prof. Peter Jonsson. The research for the advertised position is in the area of parameterized complexity of constraint satisfaction problems (CSP). Website: liu.se/en/work-at-liu/vacancies/21872 Email: peter.jonsson@liu.se
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p>Linköping University advertises one (1) position as PhD student in Computer Science. The PhD student will be supervised by prof. Peter Jonsson. The research for the advertised position is in the area of parameterized complexity of constraint satisfaction problems (CSP).</p>
<p>Website: <a href="https://liu.se/en/work-at-liu/vacancies/21872">https://liu.se/en/work-at-liu/vacancies/21872</a><br />
Email: peter.jonsson@liu.se</p>
<p class="authors">By shacharlovett</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-04T09:18:29Z">Thursday, May 04 2023, 09:18</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.01721'>Construction of Decision Trees and Acyclic Decision Graphs from Decision Rule Systems</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Kerven Durdymyradov, Mikhail Moshkov</p><p>Decision trees and systems of decision rules are widely used as classifiers,
as a means for knowledge representation, and as algorithms. They are among the
most interpretable models for data analysis. The study of the relationships
between these two models can be seen as an important task of computer science.
Methods for transforming decision trees into systems of decision rules are
simple and well-known. In this paper, we consider the inverse transformation
problem, which is not trivial. We study the complexity of constructing decision
trees and acyclic decision graphs representing decision trees from decision
rule systems, and we discuss the possibility of not building the entire
decision tree, but describing the computation path in this tree for the given
input.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Durdymyradov_K/0/1/0/all/0/1">Kerven Durdymyradov</a>, <a href="http://arxiv.org/find/cs/1/au:+Moshkov_M/0/1/0/all/0/1">Mikhail Moshkov</a></p><p>Decision trees and systems of decision rules are widely used as classifiers,
as a means for knowledge representation, and as algorithms. They are among the
most interpretable models for data analysis. The study of the relationships
between these two models can be seen as an important task of computer science.
Methods for transforming decision trees into systems of decision rules are
simple and well-known. In this paper, we consider the inverse transformation
problem, which is not trivial. We study the complexity of constructing decision
trees and acyclic decision graphs representing decision trees from decision
rule systems, and we discuss the possibility of not building the entire
decision tree, but describing the computation path in this tree for the given
input.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-04T00:30:00Z">Thursday, May 04 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.01851'>Complexity and Enumeration in Models of Genome Rearrangement</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Lora Bailey, Heather Smith Blake, Garner Cochran, Nathan Fox, Michael Levet, Reem Mahmoud, Elizabeth Matson, Inne Singgih, Grace Stadnyk, Xinyi Wang, Alexander Widemann</p><p>In this paper, we examine the computational complexity of enumeration in
certain genome rearrangement models. We first show that the Pairwise
Rearrangement problem in the Single Cut-and-Join model (Bergeron, Medvedev, &amp;
Stoye, J. Comput. Biol. 2010) is $\#\textsf{P}$-complete under polynomial-time
Turing reductions. Next, we show that in the Single Cut or Join model (Feijao &amp;
Meidanis, IEEE ACM Trans. Comp. Biol. Bioinf. 2011), the problem of enumerating
all medians ($\#$Median) is logspace-computable ($\textsf{FL}$), improving upon
the previous polynomial-time ($\textsf{FP}$) bound of Mikl\'os &amp; Smith (RECOMB
2015).
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/q-bio/1/au:+Bailey_L/0/1/0/all/0/1">Lora Bailey</a>, <a href="http://arxiv.org/find/q-bio/1/au:+Blake_H/0/1/0/all/0/1">Heather Smith Blake</a>, <a href="http://arxiv.org/find/q-bio/1/au:+Cochran_G/0/1/0/all/0/1">Garner Cochran</a>, <a href="http://arxiv.org/find/q-bio/1/au:+Fox_N/0/1/0/all/0/1">Nathan Fox</a>, <a href="http://arxiv.org/find/q-bio/1/au:+Levet_M/0/1/0/all/0/1">Michael Levet</a>, <a href="http://arxiv.org/find/q-bio/1/au:+Mahmoud_R/0/1/0/all/0/1">Reem Mahmoud</a>, <a href="http://arxiv.org/find/q-bio/1/au:+Matson_E/0/1/0/all/0/1">Elizabeth Matson</a>, <a href="http://arxiv.org/find/q-bio/1/au:+Singgih_I/0/1/0/all/0/1">Inne Singgih</a>, <a href="http://arxiv.org/find/q-bio/1/au:+Stadnyk_G/0/1/0/all/0/1">Grace Stadnyk</a>, <a href="http://arxiv.org/find/q-bio/1/au:+Wang_X/0/1/0/all/0/1">Xinyi Wang</a>, <a href="http://arxiv.org/find/q-bio/1/au:+Widemann_A/0/1/0/all/0/1">Alexander Widemann</a></p><p>In this paper, we examine the computational complexity of enumeration in
certain genome rearrangement models. We first show that the Pairwise
Rearrangement problem in the Single Cut-and-Join model (Bergeron, Medvedev, &amp;
Stoye, J. Comput. Biol. 2010) is $\#\textsf{P}$-complete under polynomial-time
Turing reductions. Next, we show that in the Single Cut or Join model (Feijao &amp;
Meidanis, IEEE ACM Trans. Comp. Biol. Bioinf. 2011), the problem of enumerating
all medians ($\#$Median) is logspace-computable ($\textsf{FL}$), improving upon
the previous polynomial-time ($\textsf{FP}$) bound of Mikl\'os &amp; Smith (RECOMB
2015).
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-04T00:30:00Z">Thursday, May 04 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.02226'>$P\not=NP$ relative to a $P$-complete oracle</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Reiner Czerwinski</p><p>The $P$ versus $NP$ problem is still unsolved. But there are several oracles
with $P$ unequal $NP$ relative to them. Here we will prove, that $P\not=NP$
relative to a $P$-complete oracle. In this paper, we use padding arguments as
the proof method. The padding arguments are not bounded by a computable
function. Such as we can use methods from computability theory to separate
complexity classes.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Czerwinski_R/0/1/0/all/0/1">Reiner Czerwinski</a></p><p>The $P$ versus $NP$ problem is still unsolved. But there are several oracles
with $P$ unequal $NP$ relative to them. Here we will prove, that $P\not=NP$
relative to a $P$-complete oracle. In this paper, we use padding arguments as
the proof method. The padding arguments are not bounded by a computable
function. Such as we can use methods from computability theory to separate
complexity classes.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-04T00:30:00Z">Thursday, May 04 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.01877'>The Impacts of Dimensionality, Diffusion, and Directedness on Intrinsic Cross-Model Simulation in Tile-Based Self-Assembly</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CG/recent'>arXiv: Computational Geometry</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Daniel Hader, Matthew J. Patitz</p><p>Algorithmic self-assembly occurs when disorganized components autonomously
combine to form structures and, by their design and the dynamics of the system,
are forced to follow the execution of algorithms. Motivated by applications in
DNA-nanotechnology, investigations in algorithmic tile-based self-assembly have
blossomed into a mature theory with research leveraging tools from
computability theory, complexity theory, information theory, and graph theory
to develop a wide range of models and show that many are computationally
universal, while also exposing powers and limitations of each. Beyond
computational universality, the abstract Tile Assembly Model (aTAM) was shown
to be intrinsically universal (IU), a strong notion of completeness where a
single tile set is capable of simulating all systems within the model; however,
this result required non-deterministic tile attachments. This was later
confirmed necessary when it was shown that the class of directed aTAM systems
is not IU. Building on these results to further investigate the impacts of
other dynamics, Hader et al. examined several tile-assembly models which varied
across (1) the numbers of dimensions used, (2) restrictions based on diffusion
of tiles through space, and (3) whether each system is directed, and showed
which models are IU. Such results have shed much light on the roles of various
aspects of the dynamics of tile-assembly and their effects on the intrinsic
universality of each model. Here we provide direct comparisons of the various
models by considering intrinsic simulations between models. We show that in
some cases one model is more powerful than another, and in others, pairs of
models have mutually exclusive capabilities. This comparison helps to expose
the impacts of these three important aspects and further helps define a
hierarchy of tile-assembly models.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Hader_D/0/1/0/all/0/1">Daniel Hader</a>, <a href="http://arxiv.org/find/cs/1/au:+Patitz_M/0/1/0/all/0/1">Matthew J. Patitz</a></p><p>Algorithmic self-assembly occurs when disorganized components autonomously
combine to form structures and, by their design and the dynamics of the system,
are forced to follow the execution of algorithms. Motivated by applications in
DNA-nanotechnology, investigations in algorithmic tile-based self-assembly have
blossomed into a mature theory with research leveraging tools from
computability theory, complexity theory, information theory, and graph theory
to develop a wide range of models and show that many are computationally
universal, while also exposing powers and limitations of each. Beyond
computational universality, the abstract Tile Assembly Model (aTAM) was shown
to be intrinsically universal (IU), a strong notion of completeness where a
single tile set is capable of simulating all systems within the model; however,
this result required non-deterministic tile attachments. This was later
confirmed necessary when it was shown that the class of directed aTAM systems
is not IU. Building on these results to further investigate the impacts of
other dynamics, Hader et al. examined several tile-assembly models which varied
across (1) the numbers of dimensions used, (2) restrictions based on diffusion
of tiles through space, and (3) whether each system is directed, and showed
which models are IU. Such results have shed much light on the roles of various
aspects of the dynamics of tile-assembly and their effects on the intrinsic
universality of each model. Here we provide direct comparisons of the various
models by considering intrinsic simulations between models. We show that in
some cases one model is more powerful than another, and in others, pairs of
models have mutually exclusive capabilities. This comparison helps to expose
the impacts of these three important aspects and further helps define a
hierarchy of tile-assembly models.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-04T00:30:00Z">Thursday, May 04 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.01883'>A Lightweight CNN-Transformer Model for Learning Traveling Salesman Problems</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CG/recent'>arXiv: Computational Geometry</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Minseop Jung, Jaeseung Lee, Jibum Kim</p><p>Transformer-based models show state-of-the-art performance even for
large-scale Traveling Salesman Problems (TSPs). However, they are based on
fully-connected attention models and suffer from large computational complexity
and GPU memory usage. We propose a lightweight CNN-Transformer model based on a
CNN embedding layer and partial self-attention. Our CNN-Transformer model is
able to better learn spatial features from input data using a CNN embedding
layer compared with the standard Transformer models. It also removes
considerable redundancy in fully connected attention models using the proposed
partial self-attention. Experiments show that the proposed model outperforms
other state-of-the-art Transformer-based models in terms of TSP solution
quality, GPU memory usage, and inference time. Our model consumes approximately
20% less GPU memory usage and has 45% faster inference time compared with other
state-of-the-art Transformer-based models. Our code is publicly available at
github.com/cm8908/CNN_Transformer3
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Jung_M/0/1/0/all/0/1">Minseop Jung</a>, <a href="http://arxiv.org/find/cs/1/au:+Lee_J/0/1/0/all/0/1">Jaeseung Lee</a>, <a href="http://arxiv.org/find/cs/1/au:+Kim_J/0/1/0/all/0/1">Jibum Kim</a></p><p>Transformer-based models show state-of-the-art performance even for
large-scale Traveling Salesman Problems (TSPs). However, they are based on
fully-connected attention models and suffer from large computational complexity
and GPU memory usage. We propose a lightweight CNN-Transformer model based on a
CNN embedding layer and partial self-attention. Our CNN-Transformer model is
able to better learn spatial features from input data using a CNN embedding
layer compared with the standard Transformer models. It also removes
considerable redundancy in fully connected attention models using the proposed
partial self-attention. Experiments show that the proposed model outperforms
other state-of-the-art Transformer-based models in terms of TSP solution
quality, GPU memory usage, and inference time. Our model consumes approximately
20% less GPU memory usage and has 45% faster inference time compared with other
state-of-the-art Transformer-based models. Our code is publicly available at
https://github.com/cm8908/CNN_Transformer3
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-04T00:30:00Z">Thursday, May 04 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.02056'>Approximate Evaluation of Quantitative Second Order Queries</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Jan Dreier, Robert Ganian, Thekla Hamm</p><p>Courcelle's theorem and its adaptations to cliquewidth have shaped the field
of exact parameterized algorithms and are widely considered the archetype of
algorithmic meta-theorems. In the past decade, there has been growing interest
in developing parameterized approximation algorithms for problems which are not
captured by Courcelle's theorem and, in particular, are considered not
fixed-parameter tractable under the associated widths.
</p>
<p>We develop a generalization of Courcelle's theorem that yields efficient
approximation schemes for any problem that can be captured by an expanded logic
we call Blocked CMSO, capable of making logical statements about the sizes of
set variables via so-called weight comparisons. The logic controls weight
comparisons via the quantifier-alternation depth of the involved variables,
allowing full comparisons for zero-alternation variables and limited
comparisons for one-alternation variables. We show that the developed framework
threads the very needle of tractability: on one hand it can describe a broad
range of approximable problems, while on the other hand we show that the
restrictions of our logic cannot be relaxed under well-established complexity
assumptions.
</p>
<p>The running time of our approximation scheme is polynomial in
$1/\varepsilon$, allowing us to fully interpolate between faster approximate
algorithms and slower exact algorithms. This provides a unified framework to
explain the tractability landscape of graph problems parameterized by treewidth
and cliquewidth, as well as classical non-graph problems such as Subset Sum and
Knapsack.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Dreier_J/0/1/0/all/0/1">Jan Dreier</a>, <a href="http://arxiv.org/find/cs/1/au:+Ganian_R/0/1/0/all/0/1">Robert Ganian</a>, <a href="http://arxiv.org/find/cs/1/au:+Hamm_T/0/1/0/all/0/1">Thekla Hamm</a></p><p>Courcelle's theorem and its adaptations to cliquewidth have shaped the field
of exact parameterized algorithms and are widely considered the archetype of
algorithmic meta-theorems. In the past decade, there has been growing interest
in developing parameterized approximation algorithms for problems which are not
captured by Courcelle's theorem and, in particular, are considered not
fixed-parameter tractable under the associated widths.
</p>
<p>We develop a generalization of Courcelle's theorem that yields efficient
approximation schemes for any problem that can be captured by an expanded logic
we call Blocked CMSO, capable of making logical statements about the sizes of
set variables via so-called weight comparisons. The logic controls weight
comparisons via the quantifier-alternation depth of the involved variables,
allowing full comparisons for zero-alternation variables and limited
comparisons for one-alternation variables. We show that the developed framework
threads the very needle of tractability: on one hand it can describe a broad
range of approximable problems, while on the other hand we show that the
restrictions of our logic cannot be relaxed under well-established complexity
assumptions.
</p>
<p>The running time of our approximation scheme is polynomial in
$1/\varepsilon$, allowing us to fully interpolate between faster approximate
algorithms and slower exact algorithms. This provides a unified framework to
explain the tractability landscape of graph problems parameterized by treewidth
and cliquewidth, as well as classical non-graph problems such as Subset Sum and
Knapsack.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-04T00:30:00Z">Thursday, May 04 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.02271'>$L$ is unequal $NL$ under the Strong Exponential Time Hypothesis</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Reiner Czerwinski</p><p>Due to Savitch's theorem we know $NL\subseteq DSPACE(\log^2(n))$. To show
this upper bound, Savitch constructed an algorithm with $O(\log^2(n))$ space on
the working tape. We will show that Savitch's algorithm also described a lower
bound under the Strong Exponential Time Hypothesis. Every algorithm for the
Connectivity Problem needs $O(\log^2(n))$ space in this case.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Czerwinski_R/0/1/0/all/0/1">Reiner Czerwinski</a></p><p>Due to Savitch's theorem we know $NL\subseteq DSPACE(\log^2(n))$. To show
this upper bound, Savitch constructed an algorithm with $O(\log^2(n))$ space on
the working tape. We will show that Savitch's algorithm also described a lower
bound under the Strong Exponential Time Hypothesis. Every algorithm for the
Connectivity Problem needs $O(\log^2(n))$ space in this case.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-04T00:30:00Z">Thursday, May 04 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.01892'>On the Fine-Grained Complexity of Small-Size Geometric Set Cover and Discrete $k$-Center for Small $k$</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Timothy M. Chan, Qizheng He, Yuancheng Yu</p><p>We study the time complexity of the discrete $k$-center problem and related
(exact) geometric set cover problems when $k$ or the size of the cover is
small. We obtain a plethora of new results:
</p>
<p>- We give the first subquadratic algorithm for rectilinear discrete 3-center
in 2D, running in $\widetilde{O}(n^{3/2})$ time.
</p>
<p>- We prove a lower bound of $\Omega(n^{4/3-\delta})$ for rectilinear discrete
3-center in 4D, for any constant $\delta&gt;0$, under a standard hypothesis about
triangle detection in sparse graphs.
</p>
<p>- Given $n$ points and $n$ weighted axis-aligned unit squares in 2D, we give
the first subquadratic algorithm for finding a minimum-weight cover of the
points by 3 unit squares, running in $\widetilde{O}(n^{8/5})$ time. We also
prove a lower bound of $\Omega(n^{3/2-\delta})$ for the same problem in 2D,
under the well-known APSP Hypothesis. For arbitrary axis-aligned rectangles in
2D, our upper bound is $\widetilde{O}(n^{7/4})$.
</p>
<p>- We prove a lower bound of $\Omega(n^{2-\delta})$ for Euclidean discrete
2-center in 13D, under the Hyperclique Hypothesis. This lower bound nearly
matches the straightforward upper bound of $\widetilde{O}(n^\omega)$, if the
matrix multiplication exponent $\omega$ is equal to 2.
</p>
<p>- We similarly prove an $\Omega(n^{k-\delta})$ lower bound for Euclidean
discrete $k$-center in $O(k)$ dimensions for any constant $k\ge 3$, under the
Hyperclique Hypothesis. This lower bound again nearly matches known upper
bounds if $\omega=2$.
</p>
<p>- We also prove an $\Omega(n^{2-\delta})$ lower bound for the problem of
finding 2 boxes to cover the largest number of points, given $n$ points and $n$
boxes in 12D. This matches the straightforward near-quadratic upper bound.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Chan_T/0/1/0/all/0/1">Timothy M. Chan</a>, <a href="http://arxiv.org/find/cs/1/au:+He_Q/0/1/0/all/0/1">Qizheng He</a>, <a href="http://arxiv.org/find/cs/1/au:+Yu_Y/0/1/0/all/0/1">Yuancheng Yu</a></p><p>We study the time complexity of the discrete $k$-center problem and related
(exact) geometric set cover problems when $k$ or the size of the cover is
small. We obtain a plethora of new results:
</p>
<p>- We give the first subquadratic algorithm for rectilinear discrete 3-center
in 2D, running in $\widetilde{O}(n^{3/2})$ time.
</p>
<p>- We prove a lower bound of $\Omega(n^{4/3-\delta})$ for rectilinear discrete
3-center in 4D, for any constant $\delta&gt;0$, under a standard hypothesis about
triangle detection in sparse graphs.
</p>
<p>- Given $n$ points and $n$ weighted axis-aligned unit squares in 2D, we give
the first subquadratic algorithm for finding a minimum-weight cover of the
points by 3 unit squares, running in $\widetilde{O}(n^{8/5})$ time. We also
prove a lower bound of $\Omega(n^{3/2-\delta})$ for the same problem in 2D,
under the well-known APSP Hypothesis. For arbitrary axis-aligned rectangles in
2D, our upper bound is $\widetilde{O}(n^{7/4})$.
</p>
<p>- We prove a lower bound of $\Omega(n^{2-\delta})$ for Euclidean discrete
2-center in 13D, under the Hyperclique Hypothesis. This lower bound nearly
matches the straightforward upper bound of $\widetilde{O}(n^\omega)$, if the
matrix multiplication exponent $\omega$ is equal to 2.
</p>
<p>- We similarly prove an $\Omega(n^{k-\delta})$ lower bound for Euclidean
discrete $k$-center in $O(k)$ dimensions for any constant $k\ge 3$, under the
Hyperclique Hypothesis. This lower bound again nearly matches known upper
bounds if $\omega=2$.
</p>
<p>- We also prove an $\Omega(n^{2-\delta})$ lower bound for the problem of
finding 2 boxes to cover the largest number of points, given $n$ points and $n$
boxes in 12D. This matches the straightforward near-quadratic upper bound.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-04T00:30:00Z">Thursday, May 04 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.01714'>Streaming Edge Coloring with Asymptotically Optimal Colors</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Soheil Behnezhad, Mohammad Saneian</p><p>Given a graph $G$, an edge-coloring is an assignment of colors to edges of
$G$ such that any two edges sharing an endpoint receive different colors. By
Vizing's celebrated theorem, any graph of maximum degree $\Delta$ needs at
least $\Delta$ and at most $(\Delta + 1)$ colors to be properly edge colored.
In this paper, we study edge colorings in the streaming setting. The edges
arrive one by one in an arbitrary order. The algorithm takes a single pass over
the input and must output a solution using a much smaller space than the input
size. Since the output of edge coloring is as large as its input, the assigned
colors should also be reported in a streaming fashion.
</p>
<p>The streaming edge coloring problem has been studied in a series of works
over the past few years. The main challenge is that the algorithm cannot
"remember" all the color assignments that it returns. To ensure the validity of
the solution, existing algorithms use many more colors than Vizing's bound.
Namely, in $n$-vertex graphs, the state-of-the-art algorithm with
$\widetilde{O}(n s)$ space requires $O(\Delta^2/s + \Delta)$ colors. Note, in
particular, that for an asymptotically optimal $O(\Delta)$ coloring, this
algorithm requires $\Omega(n\Delta)$ space which is as large as the input.
Whether such a coloring can be achieved with sublinear space has been left
open.
</p>
<p>In this paper, we answer this question in the affirmative. We present a
randomized algorithm that returns an asymptotically optimal $O(\Delta)$ edge
coloring using $\widetilde{O}(n \sqrt{\Delta})$ space. More generally, our
algorithm returns a proper $O(\Delta^{1.5}/s + \Delta)$ edge coloring with
$\widetilde{O}(n s)$ space, improving prior algorithms for the whole range of
$s$.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Behnezhad_S/0/1/0/all/0/1">Soheil Behnezhad</a>, <a href="http://arxiv.org/find/cs/1/au:+Saneian_M/0/1/0/all/0/1">Mohammad Saneian</a></p><p>Given a graph $G$, an edge-coloring is an assignment of colors to edges of
$G$ such that any two edges sharing an endpoint receive different colors. By
Vizing's celebrated theorem, any graph of maximum degree $\Delta$ needs at
least $\Delta$ and at most $(\Delta + 1)$ colors to be properly edge colored.
In this paper, we study edge colorings in the streaming setting. The edges
arrive one by one in an arbitrary order. The algorithm takes a single pass over
the input and must output a solution using a much smaller space than the input
size. Since the output of edge coloring is as large as its input, the assigned
colors should also be reported in a streaming fashion.
</p>
<p>The streaming edge coloring problem has been studied in a series of works
over the past few years. The main challenge is that the algorithm cannot
"remember" all the color assignments that it returns. To ensure the validity of
the solution, existing algorithms use many more colors than Vizing's bound.
Namely, in $n$-vertex graphs, the state-of-the-art algorithm with
$\widetilde{O}(n s)$ space requires $O(\Delta^2/s + \Delta)$ colors. Note, in
particular, that for an asymptotically optimal $O(\Delta)$ coloring, this
algorithm requires $\Omega(n\Delta)$ space which is as large as the input.
Whether such a coloring can be achieved with sublinear space has been left
open.
</p>
<p>In this paper, we answer this question in the affirmative. We present a
randomized algorithm that returns an asymptotically optimal $O(\Delta)$ edge
coloring using $\widetilde{O}(n \sqrt{\Delta})$ space. More generally, our
algorithm returns a proper $O(\Delta^{1.5}/s + \Delta)$ edge coloring with
$\widetilde{O}(n s)$ space, improving prior algorithms for the whole range of
$s$.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-04T00:30:00Z">Thursday, May 04 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.01756'>Connectivity Queries under Vertex Failures: Not Optimal, but Practical</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Evangelos Kosinas</p><p>We revisit once more the problem of designing an oracle for answering
connectivity queries in undirected graphs in the presence of vertex failures.
Specifically, given an undirected graph $G$ with $n$ vertices and $m$ edges and
an integer $d_{\star}\ll n$, the goal is to preprocess the graph in order to
construct a data structure $\mathcal{D}$ such that, given a set of vertices $F$
with $|F|=d\leq d_{\star}$, we can derive an oracle from $\mathcal{D}$ that can
efficiently answer queries of the form "is $x$ connected with $y$ in
$G\setminus F$?". Very recently, Long and Saranurak (FOCS 2022) provided a
solution to this problem that is almost optimal with respect to the
preprocessing time, the space usage, the update time, and the query time.
However, their solution is highly complicated, and it seems very difficult to
be implemented efficiently. Furthermore, it does not settle the complexity of
the problem in the regime where $d_{\star}$ is a constant. Here, we provide a
much simpler solution to this problem, that uses only textbook data structures.
Our algorithm is deterministic, it has preprocessing time and space complexity
$O(d_{\star}m\log n)$, update time $O(d^4 \log n)$, and query time $O(d)$.
These bounds compare very well with the previous best, especially considering
the simplicity of our approach. In fact, if we assume that $d_{\star}$ is a
constant ($d_{\star}\geq 4$), then our algorithm improves on the
state-of-the-art in every respect, except space. Nevertheless, even our space
usage in this case is almost linear. Finally, the data structure that we
provide is flexible with respect to $d_{\star}$: it can be adapted to increases
and decreases, in time and space that are almost proportional to the change in
$d_{\star}$ and the size of the graph.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Kosinas_E/0/1/0/all/0/1">Evangelos Kosinas</a></p><p>We revisit once more the problem of designing an oracle for answering
connectivity queries in undirected graphs in the presence of vertex failures.
Specifically, given an undirected graph $G$ with $n$ vertices and $m$ edges and
an integer $d_{\star}\ll n$, the goal is to preprocess the graph in order to
construct a data structure $\mathcal{D}$ such that, given a set of vertices $F$
with $|F|=d\leq d_{\star}$, we can derive an oracle from $\mathcal{D}$ that can
efficiently answer queries of the form "is $x$ connected with $y$ in
$G\setminus F$?". Very recently, Long and Saranurak (FOCS 2022) provided a
solution to this problem that is almost optimal with respect to the
preprocessing time, the space usage, the update time, and the query time.
However, their solution is highly complicated, and it seems very difficult to
be implemented efficiently. Furthermore, it does not settle the complexity of
the problem in the regime where $d_{\star}$ is a constant. Here, we provide a
much simpler solution to this problem, that uses only textbook data structures.
Our algorithm is deterministic, it has preprocessing time and space complexity
$O(d_{\star}m\log n)$, update time $O(d^4 \log n)$, and query time $O(d)$.
These bounds compare very well with the previous best, especially considering
the simplicity of our approach. In fact, if we assume that $d_{\star}$ is a
constant ($d_{\star}\geq 4$), then our algorithm improves on the
state-of-the-art in every respect, except space. Nevertheless, even our space
usage in this case is almost linear. Finally, the data structure that we
provide is flexible with respect to $d_{\star}$: it can be adapted to increases
and decreases, in time and space that are almost proportional to the change in
$d_{\star}$ and the size of the graph.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-04T00:30:00Z">Thursday, May 04 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.01942'>Experimental Design for Any $p$-Norm</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Lap Chi Lau, Robert Wang, Hong Zhou</p><p>We consider a general $p$-norm objective for experimental design problems
that captures some well-studied objectives (D/A/E-design) as special cases. We
prove that a randomized local search approach provides a unified algorithm to
solve this problem for all $p$. This provides the first approximation algorithm
for the general $p$-norm objective, and a nice interpolation of the best known
bounds of the special cases.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Lau_L/0/1/0/all/0/1">Lap Chi Lau</a>, <a href="http://arxiv.org/find/cs/1/au:+Wang_R/0/1/0/all/0/1">Robert Wang</a>, <a href="http://arxiv.org/find/cs/1/au:+Zhou_H/0/1/0/all/0/1">Hong Zhou</a></p><p>We consider a general $p$-norm objective for experimental design problems
that captures some well-studied objectives (D/A/E-design) as special cases. We
prove that a randomized local search approach provides a unified algorithm to
solve this problem for all $p$. This provides the first approximation algorithm
for the general $p$-norm objective, and a nice interpolation of the best known
bounds of the special cases.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-04T00:30:00Z">Thursday, May 04 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.01993'>Computing paths of large rank in planar frameworks deterministically</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Fedor V. Fomin, Petr A. Golovach, Tuukka Korhonen, Giannos Stamoulis</p><p>A framework consists of an undirected graph $G$ and a matroid $M$ whose
elements correspond to the vertices of $G$. Recently, Fomin et al. [SODA 2023]
and Eiben et al. [ArXiV 2023] developed parameterized algorithms for computing
paths of rank $k$ in frameworks. More precisely, for vertices $s$ and $t$ of
$G$, and an integer $k$, they gave FPT algorithms parameterized by $k$ deciding
whether there is an $(s,t)$-path in $G$ whose vertex set contains a subset of
elements of $M$ of rank $k$. These algorithms are based on Schwartz-Zippel
lemma for polynomial identity testing and thus are randomized, and therefore
the existence of a deterministic FPT algorithm for this problem remains open.
We present the first deterministic FPT algorithm that solves the problem in
frameworks whose underlying graph $G$ is planar. While the running time of our
algorithm is worse than the running times of the recent randomized algorithms,
our algorithm works on more general classes of matroids. In particular, this is
the first FPT algorithm for the case when matroid $M$ is represented over
rationals. Our main technical contribution is the nontrivial adaptation of the
classic irrelevant vertex technique to frameworks to reduce the given instance
to one of bounded treewidth. This allows us to employ the toolbox of
representative sets to design a dynamic programming procedure solving the
problem efficiently on instances of bounded treewidth.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Fomin_F/0/1/0/all/0/1">Fedor V. Fomin</a>, <a href="http://arxiv.org/find/cs/1/au:+Golovach_P/0/1/0/all/0/1">Petr A. Golovach</a>, <a href="http://arxiv.org/find/cs/1/au:+Korhonen_T/0/1/0/all/0/1">Tuukka Korhonen</a>, <a href="http://arxiv.org/find/cs/1/au:+Stamoulis_G/0/1/0/all/0/1">Giannos Stamoulis</a></p><p>A framework consists of an undirected graph $G$ and a matroid $M$ whose
elements correspond to the vertices of $G$. Recently, Fomin et al. [SODA 2023]
and Eiben et al. [ArXiV 2023] developed parameterized algorithms for computing
paths of rank $k$ in frameworks. More precisely, for vertices $s$ and $t$ of
$G$, and an integer $k$, they gave FPT algorithms parameterized by $k$ deciding
whether there is an $(s,t)$-path in $G$ whose vertex set contains a subset of
elements of $M$ of rank $k$. These algorithms are based on Schwartz-Zippel
lemma for polynomial identity testing and thus are randomized, and therefore
the existence of a deterministic FPT algorithm for this problem remains open.
We present the first deterministic FPT algorithm that solves the problem in
frameworks whose underlying graph $G$ is planar. While the running time of our
algorithm is worse than the running times of the recent randomized algorithms,
our algorithm works on more general classes of matroids. In particular, this is
the first FPT algorithm for the case when matroid $M$ is represented over
rationals. Our main technical contribution is the nontrivial adaptation of the
classic irrelevant vertex technique to frameworks to reduce the given instance
to one of bounded treewidth. This allows us to employ the toolbox of
representative sets to design a dynamic programming procedure solving the
problem efficiently on instances of bounded treewidth.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-04T00:30:00Z">Thursday, May 04 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.02011'>Approximating Long Cycle Above Dirac's Guarantee</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Fedor F. Fomin, Petr A. Golovach, Danil Sagunov, Kirill Simonov</p><p>Parameterization above (or below) a guarantee is a successful concept in
parameterized algorithms. The idea is that many computational problems admit
``natural'' guarantees bringing to algorithmic questions whether a better
solution (above the guarantee) could be obtained efficiently. The above
guarantee paradigm has led to several exciting discoveries in the areas of
parameterized algorithms and kernelization. We argue that this paradigm could
bring forth fresh perspectives on well-studied problems in approximation
algorithms. Our example is the longest cycle problem. One of the oldest results
in extremal combinatorics is the celebrated Dirac's theorem from 1952. Dirac's
theorem provides the following guarantee on the length of the longest cycle:
for every 2-connected n-vertex graph G with minimum degree \delta(G)\leq n/2,
the length of a longest cycle L is at least 2\delta(G). Thus, the ``essential''
part in finding the longest cycle is in approximating the ``offset'' k = L - 2
\delta(G). The main result of this paper is the above-guarantee approximation
theorem for k. Informally, the theorem says that approximating the offset k is
not harder than approximating the total length L of a cycle. In other words,
for any (reasonably well-behaved) function f, a polynomial time algorithm
constructing a cycle of length f(L) in an undirected graph with a cycle of
length L, yields a polynomial time algorithm constructing a cycle of length
2\delta(G)+\Omega(f(k)).
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Fomin_F/0/1/0/all/0/1">Fedor F. Fomin</a>, <a href="http://arxiv.org/find/cs/1/au:+Golovach_P/0/1/0/all/0/1">Petr A. Golovach</a>, <a href="http://arxiv.org/find/cs/1/au:+Sagunov_D/0/1/0/all/0/1">Danil Sagunov</a>, <a href="http://arxiv.org/find/cs/1/au:+Simonov_K/0/1/0/all/0/1">Kirill Simonov</a></p><p>Parameterization above (or below) a guarantee is a successful concept in
parameterized algorithms. The idea is that many computational problems admit
``natural'' guarantees bringing to algorithmic questions whether a better
solution (above the guarantee) could be obtained efficiently. The above
guarantee paradigm has led to several exciting discoveries in the areas of
parameterized algorithms and kernelization. We argue that this paradigm could
bring forth fresh perspectives on well-studied problems in approximation
algorithms. Our example is the longest cycle problem. One of the oldest results
in extremal combinatorics is the celebrated Dirac's theorem from 1952. Dirac's
theorem provides the following guarantee on the length of the longest cycle:
for every 2-connected n-vertex graph G with minimum degree \delta(G)\leq n/2,
the length of a longest cycle L is at least 2\delta(G). Thus, the ``essential''
part in finding the longest cycle is in approximating the ``offset'' k = L - 2
\delta(G). The main result of this paper is the above-guarantee approximation
theorem for k. Informally, the theorem says that approximating the offset k is
not harder than approximating the total length L of a cycle. In other words,
for any (reasonably well-behaved) function f, a polynomial time algorithm
constructing a cycle of length f(L) in an undirected graph with a cycle of
length L, yields a polynomial time algorithm constructing a cycle of length
2\delta(G)+\Omega(f(k)).
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-04T00:30:00Z">Thursday, May 04 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.02059'>Algorithmic Theory of Qubit Routing</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Takehiro Ito, Naonori Kakimura, Naoyuki Kamiyama, Yusuke Kobayashi, Yoshio Okamoto</p><p>The qubit routing problem, also known as the swap minimization problem, is a
(classical) combinatorial optimization problem that arises in the design of
compilers of quantum programs. We study the qubit routing problem from the
viewpoint of theoretical computer science, while most of the existing studies
investigated the practical aspects. We concentrate on the linear nearest
neighbor (LNN) architectures of quantum computers, in which the graph topology
is a path. Our results are three-fold. (1) We prove that the qubit routing
problem is NP-hard. (2) We give a fixed-parameter algorithm when the number of
two-qubit gates is a parameter. (3) We give a polynomial-time algorithm when
each qubit is involved in at most one two-qubit gate.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Ito_T/0/1/0/all/0/1">Takehiro Ito</a>, <a href="http://arxiv.org/find/cs/1/au:+Kakimura_N/0/1/0/all/0/1">Naonori Kakimura</a>, <a href="http://arxiv.org/find/cs/1/au:+Kamiyama_N/0/1/0/all/0/1">Naoyuki Kamiyama</a>, <a href="http://arxiv.org/find/cs/1/au:+Kobayashi_Y/0/1/0/all/0/1">Yusuke Kobayashi</a>, <a href="http://arxiv.org/find/cs/1/au:+Okamoto_Y/0/1/0/all/0/1">Yoshio Okamoto</a></p><p>The qubit routing problem, also known as the swap minimization problem, is a
(classical) combinatorial optimization problem that arises in the design of
compilers of quantum programs. We study the qubit routing problem from the
viewpoint of theoretical computer science, while most of the existing studies
investigated the practical aspects. We concentrate on the linear nearest
neighbor (LNN) architectures of quantum computers, in which the graph topology
is a path. Our results are three-fold. (1) We prove that the qubit routing
problem is NP-hard. (2) We give a fixed-parameter algorithm when the number of
two-qubit gates is a parameter. (3) We give a polynomial-time algorithm when
each qubit is involved in at most one two-qubit gate.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-04T00:30:00Z">Thursday, May 04 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.02132'>An Efficient Algorithm for All-Pairs Bounded Edge Connectivity</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Shyan Akmal, Ce Jin</p><p>Our work concerns algorithms for an unweighted variant of Maximum Flow. In
the All-Pairs Connectivity (APC) problem, we are given a graph $G$ on $n$
vertices and $m$ edges, and are tasked with computing the maximum number of
edge-disjoint paths from $s$ to $t$ (equivalently, the size of a minimum
$(s,t)$-cut) in $G$, for all pairs of vertices $(s,t)$. Although over
undirected graphs APC can be solved in essentially optimal $n^{2+o(1)}$ time,
the true time complexity of APC over directed graphs remains open: this problem
can be solved in $\tilde{O}(m^\omega)$ time, where $\omega \in [2, 2.373)$ is
the exponent of matrix multiplication, but no matching conditional lower bound
is known.
</p>
<p>We study a variant of APC called the $k$-Bounded All Pairs Connectivity
($k$-APC) problem. In this problem, we are given an integer $k$ and graph $G$,
and are tasked with reporting the size of a minimum $(s,t)$-cut only for pairs
$(s,t)$ of vertices with a minimum cut size less than $k$ (if the minimum
$(s,t)$-cut has size at least $k$, we just report it is "large" instead of
computing the exact value).
</p>
<p>We present an algorithm solving $k$-APC in directed graphs in
$\tilde{O}((kn)^\omega)$ time. This runtime is $\tilde O(n^\omega)$ for all $k$
polylogarithmic in $n$, which is essentially optimal under popular conjectures
from fine-grained complexity. Previously, this runtime was only known for $k\le
2$ [Georgiadis et al., ICALP 2017].
</p>
<p>We also study a variant of $k$-APC, the $k$-Bounded All-Pairs Vertex
Connectivity ($k$-APVC) problem, which considers internally vertex-disjoint
paths instead of edge-disjoint paths. We present an algorithm solving $k$-APVC
in directed graphs in $\tilde{O}(k^2n^\omega)$ time. Previous work solved an
easier version of the $k$-APVC problem in $\tilde O((kn)^\omega)$ time [Abboud
et al, ICALP 2019].
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Akmal_S/0/1/0/all/0/1">Shyan Akmal</a>, <a href="http://arxiv.org/find/cs/1/au:+Jin_C/0/1/0/all/0/1">Ce Jin</a></p><p>Our work concerns algorithms for an unweighted variant of Maximum Flow. In
the All-Pairs Connectivity (APC) problem, we are given a graph $G$ on $n$
vertices and $m$ edges, and are tasked with computing the maximum number of
edge-disjoint paths from $s$ to $t$ (equivalently, the size of a minimum
$(s,t)$-cut) in $G$, for all pairs of vertices $(s,t)$. Although over
undirected graphs APC can be solved in essentially optimal $n^{2+o(1)}$ time,
the true time complexity of APC over directed graphs remains open: this problem
can be solved in $\tilde{O}(m^\omega)$ time, where $\omega \in [2, 2.373)$ is
the exponent of matrix multiplication, but no matching conditional lower bound
is known.
</p>
<p>We study a variant of APC called the $k$-Bounded All Pairs Connectivity
($k$-APC) problem. In this problem, we are given an integer $k$ and graph $G$,
and are tasked with reporting the size of a minimum $(s,t)$-cut only for pairs
$(s,t)$ of vertices with a minimum cut size less than $k$ (if the minimum
$(s,t)$-cut has size at least $k$, we just report it is "large" instead of
computing the exact value).
</p>
<p>We present an algorithm solving $k$-APC in directed graphs in
$\tilde{O}((kn)^\omega)$ time. This runtime is $\tilde O(n^\omega)$ for all $k$
polylogarithmic in $n$, which is essentially optimal under popular conjectures
from fine-grained complexity. Previously, this runtime was only known for $k\le
2$ [Georgiadis et al., ICALP 2017].
</p>
<p>We also study a variant of $k$-APC, the $k$-Bounded All-Pairs Vertex
Connectivity ($k$-APVC) problem, which considers internally vertex-disjoint
paths instead of edge-disjoint paths. We present an algorithm solving $k$-APVC
in directed graphs in $\tilde{O}(k^2n^\omega)$ time. Previous work solved an
easier version of the $k$-APVC problem in $\tilde O((kn)^\omega)$ time [Abboud
et al, ICALP 2019].
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-04T00:30:00Z">Thursday, May 04 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.02154'>Random Shreier graphs of the general linear group over finite fields and expanders</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Geoffroy Caillat-Grenier</p><p>In this paper we discuss potentially practical ways to produce expander
graphs with good spectral properties and a compact description. We focus on
several classes of uniform and bipartite expander graphs defined as random
Schreier graphs of the general linear group over the finite field of size two.
We perform numerical experiments and show that such constructions produce
spectral expanders that can be useful for practical applications. To find a
theoretical explanation of the observed experimental results, we used the
method of moments to prove upper bounds for the expected second largest
eigenvalue of the random Schreier graphs used in our constructions. We focus on
bounds for which it is difficult to study the asymptotic behaviour but it is
possible to compute non-trivial conclusions for relatively small graphs with
parameters from our numerical experiments (e.g., with less than 2^200 vertices
and degree at least logarithmic in the number of vertices).
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/math/1/au:+Caillat_Grenier_G/0/1/0/all/0/1">Geoffroy Caillat-Grenier</a></p><p>In this paper we discuss potentially practical ways to produce expander
graphs with good spectral properties and a compact description. We focus on
several classes of uniform and bipartite expander graphs defined as random
Schreier graphs of the general linear group over the finite field of size two.
We perform numerical experiments and show that such constructions produce
spectral expanders that can be useful for practical applications. To find a
theoretical explanation of the observed experimental results, we used the
method of moments to prove upper bounds for the expected second largest
eigenvalue of the random Schreier graphs used in our constructions. We focus on
bounds for which it is difficult to study the asymptotic behaviour but it is
possible to compute non-trivial conclusions for relatively small graphs with
parameters from our numerical experiments (e.g., with less than 2^200 vertices
and degree at least logarithmic in the number of vertices).
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-04T00:30:00Z">Thursday, May 04 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.02166'>Minimum Chain Cover in Almost Linear Time</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Manuel Caceres</p><p>A minimum chain cover (MCC) of a $k$-width directed acyclic graph (DAG) $G =
(V, E)$ is a set of $k$ chains (paths in the transitive closure) of $G$ such
that every vertex appears in at least one chain in the cover. The
state-of-the-art solutions for MCC run in time $\tilde{O}(k(|V|+|E|))$
[M\"akinen et at., TALG], $O(T_{MF}(|E|) + k|V|)$, $O(k^2|V| + |E|)$ [C\'aceres
et al., SODA 2022], $\tilde{O}(|V|^{3/2} + |E|)$ [Kogan and Parter, ICALP 2022]
and $\tilde{O}(T_{MCF}(|E|) + \sqrt{k}|V|)$ [Kogan and Parter, SODA 2023],
where $T_{MF}(|E|)$ and $T_{MCF}(|E|)$ are the running times for solving
maximum flow (MF) and minimum-cost flow (MCF), respectively.
</p>
<p>In this work we present an algorithm running in time $O(T_{MF}(|E|) +
(|V|+|E|)\log{k})$. By considering the recent result for solving MF [Chen et
al., FOCS 2022] our algorithm is the first running in almost linear time.
Moreover, our techniques are deterministic and derive a deterministic
near-linear time algorithm for MCC if the same is provided for MF. At the core
of our solution we use a modified version of the mergeable dictionaries [Farach
and Thorup, Algorithmica], [Iacono and \"Ozkan, ICALP 2010] data structure
boosted with the SIZE-SPLIT operation and answering queries in amortized
logarithmic time, which can be of independent interest.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Caceres_M/0/1/0/all/0/1">Manuel Caceres</a></p><p>A minimum chain cover (MCC) of a $k$-width directed acyclic graph (DAG) $G =
(V, E)$ is a set of $k$ chains (paths in the transitive closure) of $G$ such
that every vertex appears in at least one chain in the cover. The
state-of-the-art solutions for MCC run in time $\tilde{O}(k(|V|+|E|))$
[M\"akinen et at., TALG], $O(T_{MF}(|E|) + k|V|)$, $O(k^2|V| + |E|)$ [C\'aceres
et al., SODA 2022], $\tilde{O}(|V|^{3/2} + |E|)$ [Kogan and Parter, ICALP 2022]
and $\tilde{O}(T_{MCF}(|E|) + \sqrt{k}|V|)$ [Kogan and Parter, SODA 2023],
where $T_{MF}(|E|)$ and $T_{MCF}(|E|)$ are the running times for solving
maximum flow (MF) and minimum-cost flow (MCF), respectively.
</p>
<p>In this work we present an algorithm running in time $O(T_{MF}(|E|) +
(|V|+|E|)\log{k})$. By considering the recent result for solving MF [Chen et
al., FOCS 2022] our algorithm is the first running in almost linear time.
Moreover, our techniques are deterministic and derive a deterministic
near-linear time algorithm for MCC if the same is provided for MF. At the core
of our solution we use a modified version of the mergeable dictionaries [Farach
and Thorup, Algorithmica], [Iacono and \"Ozkan, ICALP 2010] data structure
boosted with the SIZE-SPLIT operation and answering queries in amortized
logarithmic time, which can be of independent interest.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-04T00:30:00Z">Thursday, May 04 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.02169'>Learning-Augmented Online TSP on Rings, Trees, Flowers and (almost) Everywhere Else</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Evripidis Bampis, Bruno Escoffier, Themis Gouleakis, Niklas Hahn, Kostas Lakis, Golnoosh Shahkarami, Michalis Xefteris</p><p>We study the Online Traveling Salesperson Problem (OLTSP) with predictions.
In OLTSP, a sequence of initially unknown requests arrive over time at points
(locations) of a metric space. The goal is, starting from a particular point of
the metric space (the origin), to serve all these requests while minimizing the
total time spent. The server moves with unit speed or is "waiting" (zero speed)
at some location. We consider two variants: in the open variant, the goal is
achieved when the last request is served. In the closed one, the server
additionally has to return to the origin. We adopt a prediction model,
introduced for OLTSP on the line, in which the predictions correspond to the
locations of the requests and extend it to more general metric spaces.
</p>
<p>We first propose an oracle-based algorithmic framework, inspired by previous
work. This framework allows us to design online algorithms for general metric
spaces that provide competitive ratio guarantees which, given perfect
predictions, beat the best possible classical guarantee (consistency).
Moreover, they degrade gracefully along with the increase in error
(smoothness), but always within a constant factor of the best known competitive
ratio in the classical case (robustness).
</p>
<p>Having reduced the problem to designing suitable efficient oracles, we
describe how to achieve this for general metric spaces as well as specific
metric spaces (rings, trees and flowers), the resulting algorithms being
tractable in the latter case. The consistency guarantees of our algorithms are
tight in almost all cases, and their smoothness guarantees only suffer a linear
dependency on the error, which we show is necessary. Finally, we provide
robustness guarantees improving previous results.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Bampis_E/0/1/0/all/0/1">Evripidis Bampis</a>, <a href="http://arxiv.org/find/cs/1/au:+Escoffier_B/0/1/0/all/0/1">Bruno Escoffier</a>, <a href="http://arxiv.org/find/cs/1/au:+Gouleakis_T/0/1/0/all/0/1">Themis Gouleakis</a>, <a href="http://arxiv.org/find/cs/1/au:+Hahn_N/0/1/0/all/0/1">Niklas Hahn</a>, <a href="http://arxiv.org/find/cs/1/au:+Lakis_K/0/1/0/all/0/1">Kostas Lakis</a>, <a href="http://arxiv.org/find/cs/1/au:+Shahkarami_G/0/1/0/all/0/1">Golnoosh Shahkarami</a>, <a href="http://arxiv.org/find/cs/1/au:+Xefteris_M/0/1/0/all/0/1">Michalis Xefteris</a></p><p>We study the Online Traveling Salesperson Problem (OLTSP) with predictions.
In OLTSP, a sequence of initially unknown requests arrive over time at points
(locations) of a metric space. The goal is, starting from a particular point of
the metric space (the origin), to serve all these requests while minimizing the
total time spent. The server moves with unit speed or is "waiting" (zero speed)
at some location. We consider two variants: in the open variant, the goal is
achieved when the last request is served. In the closed one, the server
additionally has to return to the origin. We adopt a prediction model,
introduced for OLTSP on the line, in which the predictions correspond to the
locations of the requests and extend it to more general metric spaces.
</p>
<p>We first propose an oracle-based algorithmic framework, inspired by previous
work. This framework allows us to design online algorithms for general metric
spaces that provide competitive ratio guarantees which, given perfect
predictions, beat the best possible classical guarantee (consistency).
Moreover, they degrade gracefully along with the increase in error
(smoothness), but always within a constant factor of the best known competitive
ratio in the classical case (robustness).
</p>
<p>Having reduced the problem to designing suitable efficient oracles, we
describe how to achieve this for general metric spaces as well as specific
metric spaces (rings, trees and flowers), the resulting algorithms being
tractable in the latter case. The consistency guarantees of our algorithms are
tight in almost all cases, and their smoothness guarantees only suffer a linear
dependency on the error, which we show is necessary. Finally, we provide
robustness guarantees improving previous results.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-04T00:30:00Z">Thursday, May 04 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.02240'>A $4/3$ Approximation for $2$-Vertex-Connectivity</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Miguel Bosch-Calvo, Fabrizio Grandoni, Afrouz Jabal Ameli</p><p>The 2-Vertex-Connected Spanning Subgraph problem (2VCSS) is among the most
basic NP-hard (Survivable) Network Design problems: we are given an
(unweighted) undirected graph $G$. Our goal is to find a subgraph $S$ of $G$
with the minimum number of edges which is $2$-vertex-connected, namely $S$
remains connected after the deletion of an arbitrary node. 2VCSS is
well-studied in terms of approximation algorithms, and the current best
(polynomial-time) approximation factor is $10/7$ by Heeger and Vygen [SIDMA'17]
(improving on earlier results by Khuller and Vishkin [STOC'92] and Garg,
Vempala and Singla [SODA'93]).
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Bosch_Calvo_M/0/1/0/all/0/1">Miguel Bosch-Calvo</a>, <a href="http://arxiv.org/find/cs/1/au:+Grandoni_F/0/1/0/all/0/1">Fabrizio Grandoni</a>, <a href="http://arxiv.org/find/cs/1/au:+Ameli_A/0/1/0/all/0/1">Afrouz Jabal Ameli</a></p><p>The 2-Vertex-Connected Spanning Subgraph problem (2VCSS) is among the most
basic NP-hard (Survivable) Network Design problems: we are given an
(unweighted) undirected graph $G$. Our goal is to find a subgraph $S$ of $G$
with the minimum number of edges which is $2$-vertex-connected, namely $S$
remains connected after the deletion of an arbitrary node. 2VCSS is
well-studied in terms of approximation algorithms, and the current best
(polynomial-time) approximation factor is $10/7$ by Heeger and Vygen [SIDMA'17]
(improving on earlier results by Khuller and Vishkin [STOC'92] and Garg,
Vempala and Singla [SODA'93]).
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-04T00:30:00Z">Thursday, May 04 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.02263'>Triangle Counting with Local Edge Differential Privacy</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Talya Eden, Quanquan C. Liu, Sofya Raskhodnikova, Adam Smith</p><p>Many deployments of differential privacy in industry are in the local model,
where each party releases its private information via a differentially private
randomizer. We study triangle counting in the noninteractive and interactive
local model with edge differential privacy (that, intuitively, requires that
the outputs of the algorithm on graphs that differ in one edge be
indistinguishable). In this model, each party's local view consists of the
adjacency list of one vertex.
</p>
<p>In the noninteractive model, we prove that additive $\Omega(n^2)$ error is
necessary, where $n$ is the number of nodes. This lower bound is our main
technical contribution. It uses a reconstruction attack with a new class of
linear queries and a novel mix-and-match strategy of running the local
randomizers with different completions of their adjacency lists. It matches the
additive error of the algorithm based on Randomized Response, proposed by
Imola, Murakami and Chaudhuri (USENIX2021) and analyzed by Imola, Murakami and
Chaudhuri (CCS2022) for constant $\varepsilon$. We use a different
postprocessing of Randomized Response and provide tight bounds on the variance
of the resulting algorithm.
</p>
<p>In the interactive setting, we prove a lower bound of $\Omega(n^{3/2})$ on
the additive error. Previously, no hardness results were known for interactive,
edge-private algorithms in the local model, except for those that follow
trivially from the results for the central model. Our work significantly
improves on the state of the art in differentially private graph analysis in
the local model.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Eden_T/0/1/0/all/0/1">Talya Eden</a>, <a href="http://arxiv.org/find/cs/1/au:+Liu_Q/0/1/0/all/0/1">Quanquan C. Liu</a>, <a href="http://arxiv.org/find/cs/1/au:+Raskhodnikova_S/0/1/0/all/0/1">Sofya Raskhodnikova</a>, <a href="http://arxiv.org/find/cs/1/au:+Smith_A/0/1/0/all/0/1">Adam Smith</a></p><p>Many deployments of differential privacy in industry are in the local model,
where each party releases its private information via a differentially private
randomizer. We study triangle counting in the noninteractive and interactive
local model with edge differential privacy (that, intuitively, requires that
the outputs of the algorithm on graphs that differ in one edge be
indistinguishable). In this model, each party's local view consists of the
adjacency list of one vertex.
</p>
<p>In the noninteractive model, we prove that additive $\Omega(n^2)$ error is
necessary, where $n$ is the number of nodes. This lower bound is our main
technical contribution. It uses a reconstruction attack with a new class of
linear queries and a novel mix-and-match strategy of running the local
randomizers with different completions of their adjacency lists. It matches the
additive error of the algorithm based on Randomized Response, proposed by
Imola, Murakami and Chaudhuri (USENIX2021) and analyzed by Imola, Murakami and
Chaudhuri (CCS2022) for constant $\varepsilon$. We use a different
postprocessing of Randomized Response and provide tight bounds on the variance
of the resulting algorithm.
</p>
<p>In the interactive setting, we prove a lower bound of $\Omega(n^{3/2})$ on
the additive error. Previously, no hardness results were known for interactive,
edge-private algorithms in the local model, except for those that follow
trivially from the results for the central model. Our work significantly
improves on the state of the art in differentially private graph analysis in
the local model.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-04T00:30:00Z">Thursday, May 04 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='https://blog.simons.berkeley.edu/2023/05/mechanisms-inside-or-in-between/'>Mechanisms: Inside or In-Between?</a></h3>
        <p class='tr-article-feed'>from <a href='https://blog.simons.berkeley.edu'>Simons Institute Blog</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          by Issa Kohler-Hausmann (Senior Law and Society Fellow, Spring 2022, Simons Institute)1 This work was made possible by the Simons Institute’s Causality program in the spring of 2022, where I was the Law and Society fellow and had the opportunity &#8230; Continue reading &#8594;<p>By Simons Institute Editor</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          by Issa Kohler-Hausmann (Senior Law and Society Fellow, Spring 2022, Simons Institute)1 This work was made possible by the Simons Institute’s Causality program in the spring of 2022, where I was the Law and Society fellow and had the opportunity &#8230; <a href="https://blog.simons.berkeley.edu/2023/05/mechanisms-inside-or-in-between/">Continue reading <span class="meta-nav">&#8594;</span></a><p class="authors">By Simons Institute Editor</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-04T00:00:00Z">Thursday, May 04 2023, 00:00</time>
        </div>
      </div>
    </details>
  
    
    <h2 class='tr-new-date'>
      <i class='fa-regular fa-calendar'></i> Wednesday, May 03
    </h2>
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='https://cstheory-jobs.org/2023/05/03/postdocs-at-aalto-university-apply-by-june-1-2023/'>Postdocs at Aalto University (apply by June 1, 2023)</a></h3>
        <p class='tr-article-feed'>from <a href='https://cstheory-jobs.org'>CCI: jobs</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          The research group of Jukka Suomela at Aalto University is looking for postdoctoral researchers to work on the foundations of distributed and parallel computing. Website: research.cs.aalto.fi/da/jobs/ Email: jukka.suomela@aalto.fi
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p>The research group of Jukka Suomela at Aalto University is looking for postdoctoral researchers to work on the foundations of distributed and parallel computing.</p>
<p>Website: <a href="https://research.cs.aalto.fi/da/jobs/">https://research.cs.aalto.fi/da/jobs/</a><br />
Email: jukka.suomela@aalto.fi</p>
<p class="authors">By shacharlovett</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-03T20:30:59Z">Wednesday, May 03 2023, 20:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='https://eccc.weizmann.ac.il/report/2023/064'>TR23-064 |   On the Lower Bound on the Length of Relaxed Locally Decodable Codes | 

	Oded Goldreich</a></h3>
        <p class='tr-article-feed'>from <a href='https://eccc.weizmann.ac.il/'>ECCC Papers</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          We revisit the known proof of the lower bound on the length of relaxed locally decodable codes, providing an arguably simpler exposition that yields a slightly better lower bound for the non-adaptive case and a weaker bound in the general case.

Recall that a locally decodable code is an error correcting code that allows for the recovery of any desired bit in the message based on a constant number of randomly selected bits in the possibly corrupted codeword.
The relaxed version requires correct recovery only in case of actual codewords, while requiring that for strings that are (only) close to the code, with high probability, the local decoder outputs either the correct value or a special failure symbol (but not a wrong value). 

The lower bounds we prove are $n\geq k^{1+\Omega(1/q^2)}$ for the non-adaptive case and $n\geq k^{1+\Omega(1/q^3)}$ for the general case, where $k$ denotes the message length, $n$ denotes the length of the codewords, and $q$ denotes the (constant) number of queries.
        
        </div>

        <div class='tr-article-summary'>
        
          
          We revisit the known proof of the lower bound on the length of relaxed locally decodable codes, providing an arguably simpler exposition that yields a slightly better lower bound for the non-adaptive case and a weaker bound in the general case.

Recall that a locally decodable code is an error correcting code that allows for the recovery of any desired bit in the message based on a constant number of randomly selected bits in the possibly corrupted codeword.
The relaxed version requires correct recovery only in case of actual codewords, while requiring that for strings that are (only) close to the code, with high probability, the local decoder outputs either the correct value or a special failure symbol (but not a wrong value). 

The lower bounds we prove are $n\geq k^{1+\Omega(1/q^2)}$ for the non-adaptive case and $n\geq k^{1+\Omega(1/q^3)}$ for the general case, where $k$ denotes the message length, $n$ denotes the length of the codewords, and $q$ denotes the (constant) number of queries.
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-03T14:52:01Z">Wednesday, May 03 2023, 14:52</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2305.01064'>Questions and Concerns About Google's Quantum Supremacy Claim</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Gil Kalai, Yosef Rinott, Tomer Shoham</p><p>In October 2019, Nature published a paper [6] describing an experimental work
that was performed at Google. The paper claims to demonstrate quantum
(computational) supremacy on a 53-qubit quantum computer. Since then we have
been involved in a long-term project to study various statistical aspects of
the Google experiment. In [30] we studied Google's statistical framework that
we found to be very sound and offered some technical improvements. This
document describes three main concerns (based on statistical analysis) about
the Google 2019 experiment. The first concern is that the data do not agree
with Google's noise model (or any other specific model). The second concern is
that a crucial simple formula for a priori estimation of the fidelity seems to
involve an unexpected independence assumption, and yet it gives very accurate
predictions. The third concern is about statistical properties of the
calibration process.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/quant-ph/1/au:+Kalai_G/0/1/0/all/0/1">Gil Kalai</a>, <a href="http://arxiv.org/find/quant-ph/1/au:+Rinott_Y/0/1/0/all/0/1">Yosef Rinott</a>, <a href="http://arxiv.org/find/quant-ph/1/au:+Shoham_T/0/1/0/all/0/1">Tomer Shoham</a></p><p>In October 2019, Nature published a paper [6] describing an experimental work
that was performed at Google. The paper claims to demonstrate quantum
(computational) supremacy on a 53-qubit quantum computer. Since then we have
been involved in a long-term project to study various statistical aspects of
the Google experiment. In [30] we studied Google's statistical framework that
we found to be very sound and offered some technical improvements. This
document describes three main concerns (based on statistical analysis) about
the Google 2019 experiment. The first concern is that the data do not agree
with Google's noise model (or any other specific model). The second concern is
that a crucial simple formula for a priori estimation of the fidelity seems to
involve an unexpected independence assumption, and yet it gives very accurate
predictions. The third concern is about statistical properties of the
calibration process.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-05-03T00:30:00Z">Wednesday, May 03 2023, 00:30</time>
        </div>
      </div>
    </details>
  
  </div>

  <script src='https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.1/jquery.min.js' type="text/javascript"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-timeago/1.6.7/jquery.timeago.min.js" type="text/javascript"></script>
  <script src='js/theory.js'></script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>
