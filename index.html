<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-0RQ5M78VX5"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-0RQ5M78VX5');
  </script>

  <meta charset='utf-8'>
  <meta name='generator' content='Pluto 1.6.2 on Ruby 3.0.6 (2023-03-30) [x86_64-linux]'>

  <title>Theory of Computing Report</title>

  <link rel="alternate" type="application/rss+xml" title="Posts (RSS)" href="rss20.xml" />
  <link rel="alternate" type="application/atom+xml" title="Posts (Atom)" href="atom.xml" />
  
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/solid.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/regular.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/fontawesome.min.css">
  <link rel='stylesheet' type='text/css' href='css/theory.css'>
</head>
<body>
  <details class="tr-panel" open>
    <summary>
      <span>Last Update</span>
      <div class="tr-small">
        
          <time class='timeago' datetime="2023-06-28T08:36:19Z">Wednesday, June 28 2023, 08:36</time>
        
      </div>
      <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
    </summary>
    <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

    <ul class='tr-subscriptions tr-small' >
    
      <li>
        <a href='http://arxiv.org/rss/cs.CC'><img src='icon/feed.png'></a>
        <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a>
      </li>
    
      <li>
        <a href='http://arxiv.org/rss/cs.CG'><img src='icon/feed.png'></a>
        <a href='https://arxiv.org/list/cs.CG/recent'>arXiv: Computational Geometry</a>
      </li>
    
      <li>
        <a href='http://arxiv.org/rss/cs.DS'><img src='icon/feed.png'></a>
        <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a>
      </li>
    
      <li>
        <a href='http://aaronsadventures.blogspot.com/feeds/posts/default'><img src='icon/feed.png'></a>
        <a href='http://aaronsadventures.blogspot.com/'>Aaron Roth</a>
      </li>
    
      <li>
        <a href='https://adamsheffer.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://adamsheffer.wordpress.com'>Adam Sheffer</a>
      </li>
    
      <li>
        <a href='https://adamdsmith.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://adamdsmith.wordpress.com'>Adam Smith</a>
      </li>
    
      <li>
        <a href='https://polylogblog.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://polylogblog.wordpress.com'>Andrew McGregor</a>
      </li>
    
      <li>
        <a href='https://corner.mimuw.edu.pl/?feed=rss2'><img src='icon/feed.png'></a>
        <a href='https://corner.mimuw.edu.pl'>Banach's Algorithmic Corner</a>
      </li>
    
      <li>
        <a href='http://www.argmin.net/feed.xml'><img src='icon/feed.png'></a>
        <a href='http://benjamin-recht.github.io/'>Ben Recht</a>
      </li>
    
      <li>
        <a href='http://bit-player.org/feed/atom/'><img src='icon/feed.png'></a>
        <a href='http://bit-player.org'>bit-player</a>
      </li>
    
      <li>
        <a href='https://cstheory-jobs.org/feed/'><img src='icon/feed.png'></a>
        <a href='https://cstheory-jobs.org'>CCI: jobs</a>
      </li>
    
      <li>
        <a href='https://cstheory-events.org/feed/'><img src='icon/feed.png'></a>
        <a href='https://cstheory-events.org'>CS Theory Events</a>
      </li>
    
      <li>
        <a href='http://blog.computationalcomplexity.org/feeds/posts/default'><img src='icon/feed.png'></a>
        <a href='http://blog.computationalcomplexity.org/'>Computational Complexity</a>
      </li>
    
      <li>
        <a href='https://11011110.github.io/blog/feed.xml'><img src='icon/feed.png'></a>
        <a href='https://11011110.github.io/blog/'>David Eppstein</a>
      </li>
    
      <li>
        <a href='https://daveagp.wordpress.com/category/toc/feed/'><img src='icon/feed.png'></a>
        <a href='https://daveagp.wordpress.com'>David Pritchard</a>
      </li>
    
      <li>
        <a href='https://decentdescent.org/feed.xml'><img src='icon/feed.png'></a>
        <a href='https://decentdescent.org/'>Decent Descent</a>
      </li>
    
      <li>
        <a href='https://decentralizedthoughts.github.io/feed'><img src='icon/feed.png'></a>
        <a href='https://decentralizedthoughts.github.io'>Decentralized Thoughts</a>
      </li>
    
      <li>
        <a href='https://differentialprivacy.org/feed.xml'><img src='icon/feed.png'></a>
        <a href='https://differentialprivacy.org'>DifferentialPrivacy.org</a>
      </li>
    
      <li>
        <a href='https://eccc.weizmann.ac.il//feeds/reports/'><img src='icon/feed.png'></a>
        <a href='https://eccc.weizmann.ac.il/'>ECCC Papers</a>
      </li>
    
      <li>
        <a href='https://emanueleviola.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://emanueleviola.wordpress.com'>Emanuele Viola</a>
      </li>
    
      <li>
        <a href='https://3dpancakes.typepad.com/ernie/atom.xml'><img src='icon/feed.png'></a>
        <a href='https://3dpancakes.typepad.com/ernie/'>Ernie's 3D Pancakes</a>
      </li>
    
      <li>
        <a href='https://dstheory.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://dstheory.wordpress.com'>Foundation of Data Science - Virtual Talk Series</a>
      </li>
    
      <li>
        <a href='https://francisbach.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://francisbach.com'>Francis Bach</a>
      </li>
    
      <li>
        <a href='https://gilkalai.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://gilkalai.wordpress.com'>Gil Kalai</a>
      </li>
    
      <li>
        <a href='https://blogs.oregonstate.edu:443/glencora/tag/tcs/feed/'><img src='icon/feed.png'></a>
        <a href='https://blogs.oregonstate.edu/glencora'>Glencora Borradaile</a>
      </li>
    
      <li>
        <a href='https://research.googleblog.com/feeds/posts/default/-/Algorithms'><img src='icon/feed.png'></a>
        <a href='https://research.googleblog.com/search/label/Algorithms'>Google Research Blog: Algorithms</a>
      </li>
    
      <li>
        <a href='https://gradientscience.org/feed.xml'><img src='icon/feed.png'></a>
        <a href='https://gradientscience.org/'>Gradient Science</a>
      </li>
    
      <li>
        <a href='http://grigory.us/blog/feed.xml'><img src='icon/feed.png'></a>
        <a href='http://grigory.github.io/blog'>Grigory Yaroslavtsev</a>
      </li>
    
      <li>
        <a href='https://minorfree.github.io/feed.xml'><img src='icon/feed.png'></a>
        <a href='https://minorfree.github.io'>Hung Le</a>
      </li>
    
      <li>
        <a href='https://tcsmath.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://tcsmath.wordpress.com'>James R. Lee</a>
      </li>
    
      <li>
        <a href='https://kamathematics.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://kamathematics.wordpress.com'>Kamathematics</a>
      </li>
    
      <li>
        <a href='http://processalgebra.blogspot.com/feeds/posts/default'><img src='icon/feed.png'></a>
        <a href='http://processalgebra.blogspot.com/'>Luca Aceto</a>
      </li>
    
      <li>
        <a href='https://lucatrevisan.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://lucatrevisan.wordpress.com'>Luca Trevisan</a>
      </li>
    
      <li>
        <a href='https://mittheory.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://mittheory.wordpress.com'>MIT CSAIL Student Blog</a>
      </li>
    
      <li>
        <a href='http://mybiasedcoin.blogspot.com/feeds/posts/default'><img src='icon/feed.png'></a>
        <a href='http://mybiasedcoin.blogspot.com/'>Michael Mitzenmacher</a>
      </li>
    
      <li>
        <a href='http://blog.mrtz.org/feed.xml'><img src='icon/feed.png'></a>
        <a href='http://blog.mrtz.org/'>Moritz Hardt</a>
      </li>
    
      <li>
        <a href='http://mysliceofpizza.blogspot.com/feeds/posts/default/-/aggregator'><img src='icon/feed.png'></a>
        <a href='http://mysliceofpizza.blogspot.com/search/label/aggregator'>Muthu Muthukrishnan</a>
      </li>
    
      <li>
        <a href='https://nisheethvishnoi.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://nisheethvishnoi.wordpress.com'>Nisheeth Vishnoi</a>
      </li>
    
      <li>
        <a href='http://www.solipsistslog.com/feed/'><img src='icon/feed.png'></a>
        <a href='http://www.solipsistslog.com'>Noah Stephens-Davidowitz</a>
      </li>
    
      <li>
        <a href='http://www.offconvex.org/feed.xml'><img src='icon/feed.png'></a>
        <a href='http://offconvex.github.io/'>Off the Convex Path</a>
      </li>
    
      <li>
        <a href='http://paulwgoldberg.blogspot.com/feeds/posts/default/-/aggregator'><img src='icon/feed.png'></a>
        <a href='http://paulwgoldberg.blogspot.com/search/label/aggregator'>Paul Goldberg</a>
      </li>
    
      <li>
        <a href='https://ptreview.sublinear.info/?feed=rss2'><img src='icon/feed.png'></a>
        <a href='https://ptreview.sublinear.info'>Property Testing Review</a>
      </li>
    
      <li>
        <a href='https://rjlipton.wpcomstaging.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://rjlipton.wpcomstaging.com'>Richard Lipton</a>
      </li>
    
      <li>
        <a href='https://blogs.princeton.edu/imabandit/feed/'><img src='icon/feed.png'></a>
        <a href='https://blogs.princeton.edu/imabandit'>Sébastien Bubeck</a>
      </li>
    
      <li>
        <a href='https://scottaaronson.blog/?feed=atom'><img src='icon/feed.png'></a>
        <a href='https://scottaaronson.blog'>Scott Aaronson</a>
      </li>
    
      <li>
        <a href='https://blog.simons.berkeley.edu/feed/'><img src='icon/feed.png'></a>
        <a href='https://blog.simons.berkeley.edu'>Simons Institute Blog</a>
      </li>
    
      <li>
        <a href='https://tcsplus.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://tcsplus.wordpress.com'>TCS+ Seminar Series</a>
      </li>
    
      <li>
        <a href='https://toc4fairness.org/feed/'><img src='icon/feed.png'></a>
        <a href='https://toc4fairness.org'>TOC for Fairness</a>
      </li>
    
      <li>
        <a href='http://www.blogger.com/feeds/6555947/posts/default?alt=atom'><img src='icon/feed.png'></a>
        <a href='http://blog.geomblog.org/'>The Geomblog</a>
      </li>
    
      <li>
        <a href='https://www.let-all.com/blog/feed/'><img src='icon/feed.png'></a>
        <a href='https://www.let-all.com/blog'>The Learning Theory Alliance Blog</a>
      </li>
    
      <li>
        <a href='https://theorydish.blog/feed/'><img src='icon/feed.png'></a>
        <a href='https://theorydish.blog'>Theory Dish: Stanford Blog</a>
      </li>
    
      <li>
        <a href='https://thmatters.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://thmatters.wordpress.com'>Theory Matters</a>
      </li>
    
      <li>
        <a href='https://mycqstate.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://mycqstate.wordpress.com'>Thomas Vidick</a>
      </li>
    
      <li>
        <a href='https://agtb.wordpress.com/feed/'><img src='icon/feed.png'></a>
        <a href='https://agtb.wordpress.com'>Turing's Invisible Hand</a>
      </li>
    
      <li>
        <a href='https://windowsontheory.org/feed/'><img src='icon/feed.png'></a>
        <a href='https://windowsontheory.org'>Windows on Theory</a>
      </li>
    
    </ul>

    <p class='tr-small'><a href="opml.xml">OPML feed</a> of all feeds.</p>
    <p class='tr-small'>Subscribe to the <a href="atom.xml">Atom feed</a>, <a href="rss20.xml">RSS feed</a>, or follow on <a href="https://twitter.com/cstheory">Twitter</a>, to stay up to date.</p>
    <p class='tr-small'>Source on <a href="https://github.com/nimaanari/theory.report">GitHub</a>.</p>
    <p class='tr-small'>Maintained by Nima Anari, Arnab Bhattacharyya, Gautam Kamath.</p>
    <p class='tr-small'>Powered by <a href='https://github.com/feedreader'>Pluto</a>.</p>
  </details>

  <div class="tr-opts">
    <i id='tr-show-headlines' class="fa-solid fa-fw fa-window-minimize tr-button" title='Show Headlines Only'></i>
    <i id='tr-show-snippets' class="fa-solid fa-fw fa-compress tr-button" title='Show Snippets'></i>
    <i id='tr-show-fulltext' class="fa-solid fa-fw fa-expand tr-button" title='Show Full Text'></i>
  </div>

  <h1>Theory of Computing Report</h1>

  <div class="tr-articles tr-shrink">
    
    
    <h2 class='tr-new-date'>
      <i class='fa-regular fa-calendar'></i> Wednesday, June 28
    </h2>
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.15004'>One-step replica symmetry breaking in the language of tensor networks</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Nicola Pancotti, Johnnie Gray</p><p>We develop an exact mapping between the one-step replica symmetry breaking
cavity method and tensor networks. The two schemes come with complementary
mathematical and numerical toolboxes that could be leveraged to improve the
respective states of the art. As an example, we construct a tensor-network
representation of Survey Propagation, one of the best deterministic k-SAT
solvers. The resulting algorithm outperforms any existent tensor-network solver
by several orders of magnitude. We comment on the generality of these ideas,
and we show how to extend them to the context of quantum tensor networks.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/quant-ph/1/au:+Pancotti_N/0/1/0/all/0/1">Nicola Pancotti</a>, <a href="http://arxiv.org/find/quant-ph/1/au:+Gray_J/0/1/0/all/0/1">Johnnie Gray</a></p><p>We develop an exact mapping between the one-step replica symmetry breaking
cavity method and tensor networks. The two schemes come with complementary
mathematical and numerical toolboxes that could be leveraged to improve the
respective states of the art. As an example, we construct a tensor-network
representation of Survey Propagation, one of the best deterministic k-SAT
solvers. The resulting algorithm outperforms any existent tensor-network solver
by several orders of magnitude. We comment on the generality of these ideas,
and we show how to extend them to the context of quantum tensor networks.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-28T00:30:00Z">Wednesday, June 28 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.15079'>From $O(\sqrt n)$ to $O(\log n)$ in Quadratic Programming</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Liang Wu</p><p>A "dark cloud" hangs over numerical optimization theory for decades, namely,
whether an optimization algorithm $O(\log(n))$ iteration complexity exists.
"Yes", this paper answers, with a new optimization algorithm and strict theory
proof. It starts with box-constrained quadratic programming (Box-QP), and many
practical optimization problems fall into Box-QP. Smooth quadratic programming
(QP) and nonsmooth Lasso can be reformulated as Box-QP via duality theory. It
is the first time to present an $O(\log(n))$ iteration complexity QP algorithm,
in particular, which behaves like a "direct" method: the required number of
iterations is deterministic with exact value
$\left\lceil\log\left(\frac{3.125n}{\epsilon}\right)/\log(1.5625)\right\rceil$.
This significant breakthrough enables us to transition from the $O(\sqrt{n})$
to the $O(\log(n))$ optimization algorithm, whose amazing scalability is
particularly relevant in today's era of big data and artificial intelligence.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/math/1/au:+Wu_L/0/1/0/all/0/1">Liang Wu</a></p><p>A "dark cloud" hangs over numerical optimization theory for decades, namely,
whether an optimization algorithm $O(\log(n))$ iteration complexity exists.
"Yes", this paper answers, with a new optimization algorithm and strict theory
proof. It starts with box-constrained quadratic programming (Box-QP), and many
practical optimization problems fall into Box-QP. Smooth quadratic programming
(QP) and nonsmooth Lasso can be reformulated as Box-QP via duality theory. It
is the first time to present an $O(\log(n))$ iteration complexity QP algorithm,
in particular, which behaves like a "direct" method: the required number of
iterations is deterministic with exact value
$\left\lceil\log\left(\frac{3.125n}{\epsilon}\right)/\log(1.5625)\right\rceil$.
This significant breakthrough enables us to transition from the $O(\sqrt{n})$
to the $O(\log(n))$ optimization algorithm, whose amazing scalability is
particularly relevant in today's era of big data and artificial intelligence.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-28T00:30:00Z">Wednesday, June 28 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.15339'>A Note on the Complexity of One-Sided Crossing Minimization of Trees</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Alexander Dobler</p><p>In 2011, Harrigan and Healy published a polynomial-time algorithm for
one-sided crossing minimization for trees. We point out a counterexample to
that algorithm, and show that one-sided crossing minimization is NP-hard for
trees.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Dobler_A/0/1/0/all/0/1">Alexander Dobler</a></p><p>In 2011, Harrigan and Healy published a polynomial-time algorithm for
one-sided crossing minimization for trees. We point out a counterexample to
that algorithm, and show that one-sided crossing minimization is NP-hard for
trees.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-28T00:30:00Z">Wednesday, June 28 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.15656'>SparseOptimizer: Sparsify Language Models through Moreau-Yosida Regularization and Accelerate through Compiler Co-design</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Fu-Ming Guo</p><p>This paper introduces SparseOptimizer, a novel deep learning optimizer that
exploits Moreau-Yosida regularization to naturally induce sparsity in large
language models such as BERT, ALBERT and GPT. Key to the design of
SparseOptimizer is an embedded shrinkage operator, which imparts sparsity
directly within the optimization process. This operator, backed by a sound
theoretical framework, includes an analytical solution, thereby reinforcing the
optimizer's robustness and efficacy. Crucially, SparseOptimizer's plug-and-play
functionality eradicates the need for code modifications, making it a
universally adaptable tool for a wide array of large language models. Empirical
evaluations on benchmark datasets such as GLUE, RACE, SQuAD1, and SQuAD2
confirm that SparseBERT and SparseALBERT, when sparsified using
SparseOptimizer, achieve performance comparable to their dense counterparts,
BERT and ALBERT, while significantly reducing their parameter count. Further,
this work proposes an innovative optimizer-compiler co-design strategy,
demonstrating the potential of inference acceleration (\textbf{3.37x},
\textbf{6.30x}, and \textbf{7.15x} in comparison with Pytorch, TensorFlow, and
LLVM generic compile, respectively) in SparseBERT when paired with an
appropriately designed compiler. This study represents a significant step
forward in the evolution of efficient, scalable, and high-performing large
language models, setting a precedent for future exploration and optimization in
this domain. The SparseOptimizer code and SparseALBERT model will be made
available upon paper acceptance.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Guo_F/0/1/0/all/0/1">Fu-Ming Guo</a></p><p>This paper introduces SparseOptimizer, a novel deep learning optimizer that
exploits Moreau-Yosida regularization to naturally induce sparsity in large
language models such as BERT, ALBERT and GPT. Key to the design of
SparseOptimizer is an embedded shrinkage operator, which imparts sparsity
directly within the optimization process. This operator, backed by a sound
theoretical framework, includes an analytical solution, thereby reinforcing the
optimizer's robustness and efficacy. Crucially, SparseOptimizer's plug-and-play
functionality eradicates the need for code modifications, making it a
universally adaptable tool for a wide array of large language models. Empirical
evaluations on benchmark datasets such as GLUE, RACE, SQuAD1, and SQuAD2
confirm that SparseBERT and SparseALBERT, when sparsified using
SparseOptimizer, achieve performance comparable to their dense counterparts,
BERT and ALBERT, while significantly reducing their parameter count. Further,
this work proposes an innovative optimizer-compiler co-design strategy,
demonstrating the potential of inference acceleration (\textbf{3.37x},
\textbf{6.30x}, and \textbf{7.15x} in comparison with Pytorch, TensorFlow, and
LLVM generic compile, respectively) in SparseBERT when paired with an
appropriately designed compiler. This study represents a significant step
forward in the evolution of efficient, scalable, and high-performing large
language models, setting a precedent for future exploration and optimization in
this domain. The SparseOptimizer code and SparseALBERT model will be made
available upon paper acceptance.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-28T00:30:00Z">Wednesday, June 28 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.15097'>Approximating Median Points in a Convex Polygon</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CG/recent'>arXiv: Computational Geometry</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Reyhaneh Mohammadi, Raghuveer Devulapalli, Mehdi Behroozi</p><p>We develop two simple and efficient approximation algorithms for the
continuous $k$-medians problems, where we seek to find the optimal location of
$k$ facilities among a continuum of client points in a convex polygon $C$ with
$n$ vertices in a way that the total (average) Euclidean distance between
clients and their nearest facility is minimized. Both algorithms run in
$\mathcal{O}(n + k + k \log n)$ time. Our algorithms produce solutions within a
factor of 2.002 of optimality. In addition, our simulation results applied to
the convex hulls of the State of Massachusetts and the Town of Brookline, MA
show that our algorithms generally perform within a range of 5\% to 22\% of
optimality in practice.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/math/1/au:+Mohammadi_R/0/1/0/all/0/1">Reyhaneh Mohammadi</a>, <a href="http://arxiv.org/find/math/1/au:+Devulapalli_R/0/1/0/all/0/1">Raghuveer Devulapalli</a>, <a href="http://arxiv.org/find/math/1/au:+Behroozi_M/0/1/0/all/0/1">Mehdi Behroozi</a></p><p>We develop two simple and efficient approximation algorithms for the
continuous $k$-medians problems, where we seek to find the optimal location of
$k$ facilities among a continuum of client points in a convex polygon $C$ with
$n$ vertices in a way that the total (average) Euclidean distance between
clients and their nearest facility is minimized. Both algorithms run in
$\mathcal{O}(n + k + k \log n)$ time. Our algorithms produce solutions within a
factor of 2.002 of optimality. In addition, our simulation results applied to
the convex hulls of the State of Massachusetts and the Town of Brookline, MA
show that our algorithms generally perform within a range of 5\% to 22\% of
optimality in practice.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-28T00:30:00Z">Wednesday, June 28 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.15276'>Heuristic Approaches to Obtain Low-Discrepancy Point Sets via Subset Selection</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CG/recent'>arXiv: Computational Geometry</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Fran&#xe7;ois Cl&#xe9;ment, Carola Doerr, Lu&#xed;s Paquete</p><p>Building upon the exact methods presented in our earlier work [J. Complexity,
2022], we introduce a heuristic approach for the star discrepancy subset
selection problem. The heuristic gradually improves the current-best subset by
replacing one of its elements at a time. While we prove that the heuristic does
not necessarily return an optimal solution, we obtain very promising results
for all tested dimensions. For example, for moderate point set sizes $30 \leq n
\leq 240$ in dimension 6, we obtain point sets with $L_{\infty}$ star
discrepancy up to 35% better than that of the first $n$ points of the Sobol'
sequence. Our heuristic works in all dimensions, the main limitation being the
precision of the discrepancy calculation algorithms.
</p>
<p>We also provide a comparison with a recent energy functional introduced by
Steinerberger [J. Complexity, 2019], showing that our heuristic performs better
on all tested instances.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Clement_F/0/1/0/all/0/1">Fran&#xe7;ois Cl&#xe9;ment</a>, <a href="http://arxiv.org/find/cs/1/au:+Doerr_C/0/1/0/all/0/1">Carola Doerr</a>, <a href="http://arxiv.org/find/cs/1/au:+Paquete_L/0/1/0/all/0/1">Lu&#xed;s Paquete</a></p><p>Building upon the exact methods presented in our earlier work [J. Complexity,
2022], we introduce a heuristic approach for the star discrepancy subset
selection problem. The heuristic gradually improves the current-best subset by
replacing one of its elements at a time. While we prove that the heuristic does
not necessarily return an optimal solution, we obtain very promising results
for all tested dimensions. For example, for moderate point set sizes $30 \leq n
\leq 240$ in dimension 6, we obtain point sets with $L_{\infty}$ star
discrepancy up to 35% better than that of the first $n$ points of the Sobol'
sequence. Our heuristic works in all dimensions, the main limitation being the
precision of the discrepancy calculation algorithms.
</p>
<p>We also provide a comparison with a recent energy functional introduced by
Steinerberger [J. Complexity, 2019], showing that our heuristic performs better
on all tested instances.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-28T00:30:00Z">Wednesday, June 28 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.15338'>Insertion-Only Dynamic Connectivity in General Disk Graphs</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CG/recent'>arXiv: Computational Geometry</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Haim Kaplan, Katharina Klost, Kristin Knorr, Wolfgang Mulzer, Liam Roditty</p><p>Let $S \subseteq \mathbb{R}^2$ be a set of $n$ \emph{sites} in the plane, so
that every site $s \in S$ has an \emph{associated radius} $r_s &gt; 0$. Let $D(S)$
be the \emph{disk intersection graph} defined by $S$, i.e., the graph with
vertex set $S$ and an edge between two distinct sites $s, t \in S$ if and only
if the disks with centers $s$, $t$ and radii $r_s$, $r_t$ intersect. Our goal
is to design data structures that maintain the connectivity structure of $D(S)$
as $S$ changes dynamically over time. We consider the incremental case, where
new sites can be inserted into $S$. While previous work focuses on data
structures whose running time depends on the ratio between the smallest and the
largest site in $S$, we present a data structure with $O(\alpha(n))$ amortized
query time and $O(\log^6 n)$ expected amortized insertion time.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Kaplan_H/0/1/0/all/0/1">Haim Kaplan</a>, <a href="http://arxiv.org/find/cs/1/au:+Klost_K/0/1/0/all/0/1">Katharina Klost</a>, <a href="http://arxiv.org/find/cs/1/au:+Knorr_K/0/1/0/all/0/1">Kristin Knorr</a>, <a href="http://arxiv.org/find/cs/1/au:+Mulzer_W/0/1/0/all/0/1">Wolfgang Mulzer</a>, <a href="http://arxiv.org/find/cs/1/au:+Roditty_L/0/1/0/all/0/1">Liam Roditty</a></p><p>Let $S \subseteq \mathbb{R}^2$ be a set of $n$ \emph{sites} in the plane, so
that every site $s \in S$ has an \emph{associated radius} $r_s &gt; 0$. Let $D(S)$
be the \emph{disk intersection graph} defined by $S$, i.e., the graph with
vertex set $S$ and an edge between two distinct sites $s, t \in S$ if and only
if the disks with centers $s$, $t$ and radii $r_s$, $r_t$ intersect. Our goal
is to design data structures that maintain the connectivity structure of $D(S)$
as $S$ changes dynamically over time. We consider the incremental case, where
new sites can be inserted into $S$. While previous work focuses on data
structures whose running time depends on the ratio between the smallest and the
largest site in $S$, we present a data structure with $O(\alpha(n))$ amortized
query time and $O(\log^6 n)$ expected amortized insertion time.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-28T00:30:00Z">Wednesday, June 28 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.15621'>Approximate Nearest Neighbor Searching with Non-Euclidean and Weighted Distances</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CG/recent'>arXiv: Computational Geometry</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Ahmed Abdelkader, Sunil Arya, Guilherme D. da Fonseca, David M. Mount</p><p>We present a new approach to approximate nearest-neighbor queries in fixed
dimension under a variety of non-Euclidean distances. We are given a set $S$ of
$n$ points in $\mathbb{R}^d$, an approximation parameter $\varepsilon &gt; 0$, and
a distance function that satisfies certain smoothness and growth-rate
assumptions. The objective is to preprocess $S$ into a data structure so that
for any query point $q$ in $\mathbb{R}^d$, it is possible to efficiently report
any point of $S$ whose distance from $q$ is within a factor of $1+\varepsilon$
of the actual closest point.
</p>
<p>Prior to this work, the most efficient data structures for approximate
nearest-neighbor searching in spaces of constant dimensionality applied only to
the Euclidean metric. This paper overcomes this limitation through a method
called convexification. For admissible distance functions, the proposed data
structures answer queries in logarithmic time using $O(n \log (1 / \varepsilon)
/ \varepsilon^{d/2})$ space, nearly matching the best known bounds for the
Euclidean metric. These results apply to both convex scaling distance functions
(including the Mahalanobis distance and weighted Minkowski metrics) and Bregman
divergences (including the Kullback-Leibler divergence and the Itakura-Saito
distance).
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Abdelkader_A/0/1/0/all/0/1">Ahmed Abdelkader</a>, <a href="http://arxiv.org/find/cs/1/au:+Arya_S/0/1/0/all/0/1">Sunil Arya</a>, <a href="http://arxiv.org/find/cs/1/au:+Fonseca_G/0/1/0/all/0/1">Guilherme D. da Fonseca</a>, <a href="http://arxiv.org/find/cs/1/au:+Mount_D/0/1/0/all/0/1">David M. Mount</a></p><p>We present a new approach to approximate nearest-neighbor queries in fixed
dimension under a variety of non-Euclidean distances. We are given a set $S$ of
$n$ points in $\mathbb{R}^d$, an approximation parameter $\varepsilon &gt; 0$, and
a distance function that satisfies certain smoothness and growth-rate
assumptions. The objective is to preprocess $S$ into a data structure so that
for any query point $q$ in $\mathbb{R}^d$, it is possible to efficiently report
any point of $S$ whose distance from $q$ is within a factor of $1+\varepsilon$
of the actual closest point.
</p>
<p>Prior to this work, the most efficient data structures for approximate
nearest-neighbor searching in spaces of constant dimensionality applied only to
the Euclidean metric. This paper overcomes this limitation through a method
called convexification. For admissible distance functions, the proposed data
structures answer queries in logarithmic time using $O(n \log (1 / \varepsilon)
/ \varepsilon^{d/2})$ space, nearly matching the best known bounds for the
Euclidean metric. These results apply to both convex scaling distance functions
(including the Mahalanobis distance and weighted Minkowski metrics) and Bregman
divergences (including the Kullback-Leibler divergence and the Itakura-Saito
distance).
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-28T00:30:00Z">Wednesday, June 28 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.15648'>Optimal Area-Sensitive Bounds for Polytope Approximation</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CG/recent'>arXiv: Computational Geometry</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Sunil Arya, Guilherme D. da Fonseca, David M. Mount</p><p>Approximating convex bodies is a fundamental question in geometry and has a
wide variety of applications. Given a convex body $K$ of diameter $\Delta$ in
$\mathbb{R}^d$ for fixed $d$, the objective is to minimize the number of
vertices (alternatively, the number of facets) of an approximating polytope for
a given Hausdorff error $\varepsilon$. The best known uniform bound, due to
Dudley (1974), shows that $O((\Delta/\varepsilon)^{(d-1)/2})$ facets suffice.
While this bound is optimal in the case of a Euclidean ball, it is far from
optimal for ``skinny'' convex bodies.
</p>
<p>A natural way to characterize a convex object's skinniness is in terms of its
relationship to the Euclidean ball. Given a convex body $K$, define its surface
diameter $\Delta_{d-1}$ to be the diameter of a Euclidean ball of the same
surface area as $K$. It follows from generalizations of the isoperimetric
inequality that $\Delta \geq \Delta_{d-1}$.
</p>
<p>We show that, under the assumption that the width of the body in any
direction is at least $\varepsilon$, it is possible to approximate a convex
body using $O((\Delta_{d-1}/\varepsilon)^{(d-1)/2})$ facets. This bound is
never worse than the previous bound and may be significantly better for skinny
bodies. The bound is tight, in the sense that for any value of $\Delta_{d-1}$,
there exist convex bodies that, up to constant factors, require this many
facets.
</p>
<p>The improvement arises from a novel approach to sampling points on the
boundary of a convex body. We employ a classical concept from convexity, called
Macbeath regions. We demonstrate that Macbeath regions in $K$ and $K$'s polar
behave much like polar pairs. We then apply known results on the Mahler volume
to bound their number.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Arya_S/0/1/0/all/0/1">Sunil Arya</a>, <a href="http://arxiv.org/find/cs/1/au:+Fonseca_G/0/1/0/all/0/1">Guilherme D. da Fonseca</a>, <a href="http://arxiv.org/find/cs/1/au:+Mount_D/0/1/0/all/0/1">David M. Mount</a></p><p>Approximating convex bodies is a fundamental question in geometry and has a
wide variety of applications. Given a convex body $K$ of diameter $\Delta$ in
$\mathbb{R}^d$ for fixed $d$, the objective is to minimize the number of
vertices (alternatively, the number of facets) of an approximating polytope for
a given Hausdorff error $\varepsilon$. The best known uniform bound, due to
Dudley (1974), shows that $O((\Delta/\varepsilon)^{(d-1)/2})$ facets suffice.
While this bound is optimal in the case of a Euclidean ball, it is far from
optimal for ``skinny'' convex bodies.
</p>
<p>A natural way to characterize a convex object's skinniness is in terms of its
relationship to the Euclidean ball. Given a convex body $K$, define its surface
diameter $\Delta_{d-1}$ to be the diameter of a Euclidean ball of the same
surface area as $K$. It follows from generalizations of the isoperimetric
inequality that $\Delta \geq \Delta_{d-1}$.
</p>
<p>We show that, under the assumption that the width of the body in any
direction is at least $\varepsilon$, it is possible to approximate a convex
body using $O((\Delta_{d-1}/\varepsilon)^{(d-1)/2})$ facets. This bound is
never worse than the previous bound and may be significantly better for skinny
bodies. The bound is tight, in the sense that for any value of $\Delta_{d-1}$,
there exist convex bodies that, up to constant factors, require this many
facets.
</p>
<p>The improvement arises from a novel approach to sampling points on the
boundary of a convex body. We employ a classical concept from convexity, called
Macbeath regions. We demonstrate that Macbeath regions in $K$ and $K$'s polar
behave much like polar pairs. We then apply known results on the Mahler volume
to bound their number.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-28T00:30:00Z">Wednesday, June 28 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.15331'>Optimally Repurposing Existing Algorithms to Obtain Exponential-Time Approximations</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Bar&#x131;&#x15f; Can Esmer, Ariel Kulik, D&#xe1;niel Marx, Daniel Neuen, Roohani Sharma</p><p>The goal of this paper is to understand how exponential-time approximation
algorithms can be obtained from existing polynomial-time approximation
algorithms, existing parameterized exact algorithms, and existing parameterized
approximation algorithms. More formally, we consider a monotone subset
minimization problem over a universe of size $n$ (e.g., Vertex Cover or
Feedback Vertex Set). We have access to an algorithm that finds an
$\alpha$-approximate solution in time $c^k \cdot n^{O(1)}$ if a solution of
size $k$ exists (and more generally, an extension algorithm that can
approximate in a similar way if a set can be extended to a solution with $k$
further elements). Our goal is to obtain a $d^n \cdot n^{O(1)}$ time
$\beta$-approximation algorithm for the problem with $d$ as small as possible.
That is, for every fixed $\alpha,c,\beta \geq 1$, we would like to determine
the smallest possible $d$ that can be achieved in a model where our
problem-specific knowledge is limited to checking the feasibility of a solution
and invoking the $\alpha$-approximate extension algorithm. Our results
completely resolve this question:
</p>
<p>(1) For every fixed $\alpha,c,\beta \geq 1$, a simple algorithm
(``approximate monotone local search'') achieves the optimum value of $d$.
</p>
<p>(2) Given $\alpha,c,\beta \geq 1$, we can efficiently compute the optimum $d$
up to any precision $\varepsilon &gt; 0$.
</p>
<p>Earlier work presented algorithms (but no lower bounds) for the special case
$\alpha = \beta = 1$ [Fomin et al., J. ACM 2019] and for the special case
$\alpha = \beta &gt; 1$ [Esmer et al., ESA 2022]. Our work generalizes these
results and in particular confirms that the earlier algorithms are optimal in
these special cases.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Esmer_B/0/1/0/all/0/1">Bar&#x131;&#x15f; Can Esmer</a>, <a href="http://arxiv.org/find/cs/1/au:+Kulik_A/0/1/0/all/0/1">Ariel Kulik</a>, <a href="http://arxiv.org/find/cs/1/au:+Marx_D/0/1/0/all/0/1">D&#xe1;niel Marx</a>, <a href="http://arxiv.org/find/cs/1/au:+Neuen_D/0/1/0/all/0/1">Daniel Neuen</a>, <a href="http://arxiv.org/find/cs/1/au:+Sharma_R/0/1/0/all/0/1">Roohani Sharma</a></p><p>The goal of this paper is to understand how exponential-time approximation
algorithms can be obtained from existing polynomial-time approximation
algorithms, existing parameterized exact algorithms, and existing parameterized
approximation algorithms. More formally, we consider a monotone subset
minimization problem over a universe of size $n$ (e.g., Vertex Cover or
Feedback Vertex Set). We have access to an algorithm that finds an
$\alpha$-approximate solution in time $c^k \cdot n^{O(1)}$ if a solution of
size $k$ exists (and more generally, an extension algorithm that can
approximate in a similar way if a set can be extended to a solution with $k$
further elements). Our goal is to obtain a $d^n \cdot n^{O(1)}$ time
$\beta$-approximation algorithm for the problem with $d$ as small as possible.
That is, for every fixed $\alpha,c,\beta \geq 1$, we would like to determine
the smallest possible $d$ that can be achieved in a model where our
problem-specific knowledge is limited to checking the feasibility of a solution
and invoking the $\alpha$-approximate extension algorithm. Our results
completely resolve this question:
</p>
<p>(1) For every fixed $\alpha,c,\beta \geq 1$, a simple algorithm
(``approximate monotone local search'') achieves the optimum value of $d$.
</p>
<p>(2) Given $\alpha,c,\beta \geq 1$, we can efficiently compute the optimum $d$
up to any precision $\varepsilon &gt; 0$.
</p>
<p>Earlier work presented algorithms (but no lower bounds) for the special case
$\alpha = \beta = 1$ [Fomin et al., J. ACM 2019] and for the special case
$\alpha = \beta &gt; 1$ [Esmer et al., ESA 2022]. Our work generalizes these
results and in particular confirms that the earlier algorithms are optimal in
these special cases.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-28T00:30:00Z">Wednesday, June 28 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.15040'>Robust and Space-Efficient Dual Adversary Quantum Query Algorithms</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Michael Czekanski, Shelby Kimmel, R. Teal Witter</p><p>The general adversary dual is a powerful tool in quantum computing because it
gives a query-optimal bounded-error quantum algorithm for deciding any Boolean
function. Unfortunately, the algorithm uses linear qubits in the worst case,
and only works if the constraints of the general adversary dual are exactly
satisfied. The challenge of improving the algorithm is that it is brittle to
arbitrarily small errors since it relies on a reflection over a span of
vectors. We overcome this challenge and build a robust dual adversary algorithm
that can handle approximately satisfied constraints. As one application of our
robust algorithm, we prove that for any Boolean function with polynomially many
1-valued inputs (or in fact a slightly weaker condition) there is a
query-optimal algorithm that uses logarithmic qubits. As another application,
we prove that numerically derived, approximate solutions to the general
adversary dual give a bounded-error quantum algorithm under certain conditions.
Further, we show that these conditions empirically hold with reasonable
iterations for Boolean functions with small domains. We also develop several
tools that may be of independent interest, including a robust approximate
spectral gap lemma, a method to compress a general adversary dual solution
using the Johnson-Lindenstrauss lemma, and open-source code to find solutions
to the general adversary dual.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/quant-ph/1/au:+Czekanski_M/0/1/0/all/0/1">Michael Czekanski</a>, <a href="http://arxiv.org/find/quant-ph/1/au:+Kimmel_S/0/1/0/all/0/1">Shelby Kimmel</a>, <a href="http://arxiv.org/find/quant-ph/1/au:+Witter_R/0/1/0/all/0/1">R. Teal Witter</a></p><p>The general adversary dual is a powerful tool in quantum computing because it
gives a query-optimal bounded-error quantum algorithm for deciding any Boolean
function. Unfortunately, the algorithm uses linear qubits in the worst case,
and only works if the constraints of the general adversary dual are exactly
satisfied. The challenge of improving the algorithm is that it is brittle to
arbitrarily small errors since it relies on a reflection over a span of
vectors. We overcome this challenge and build a robust dual adversary algorithm
that can handle approximately satisfied constraints. As one application of our
robust algorithm, we prove that for any Boolean function with polynomially many
1-valued inputs (or in fact a slightly weaker condition) there is a
query-optimal algorithm that uses logarithmic qubits. As another application,
we prove that numerically derived, approximate solutions to the general
adversary dual give a bounded-error quantum algorithm under certain conditions.
Further, we show that these conditions empirically hold with reasonable
iterations for Boolean functions with small domains. We also develop several
tools that may be of independent interest, including a robust approximate
spectral gap lemma, a method to compress a general adversary dual solution
using the Johnson-Lindenstrauss lemma, and open-source code to find solutions
to the general adversary dual.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-28T00:30:00Z">Wednesday, June 28 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.15295'>Synthesis of Quantum Vector Databases Based on Grovers Algorithm</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Cesar Borisovich Pronin, Andrey Vladimirovich Ostroukh</p><p>This paper describes a method for using Grovers algorithm to create a quantum
vector database, the database stores embeddings based on Controlled-S gates,
which represent a binary numerical value. This value represents the embeddings
value. The process of creating meaningful embeddings is handled by a classical
computer and the search process is handled by the quantum computer. This search
approach might be beneficial for a large enough database, or it could be seen
as a very qubit-efficient (super dense) way for storing data on a quantum
computer, since the proposed circuit stores many embeddings inside one quantum
register simultaneously.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/quant-ph/1/au:+Pronin_C/0/1/0/all/0/1">Cesar Borisovich Pronin</a>, <a href="http://arxiv.org/find/quant-ph/1/au:+Ostroukh_A/0/1/0/all/0/1">Andrey Vladimirovich Ostroukh</a></p><p>This paper describes a method for using Grovers algorithm to create a quantum
vector database, the database stores embeddings based on Controlled-S gates,
which represent a binary numerical value. This value represents the embeddings
value. The process of creating meaningful embeddings is handled by a classical
computer and the search process is handled by the quantum computer. This search
approach might be beneficial for a large enough database, or it could be seen
as a very qubit-efficient (super dense) way for storing data on a quantum
computer, since the proposed circuit stores many embeddings inside one quantum
register simultaneously.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-28T00:30:00Z">Wednesday, June 28 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.15395'>On the Deque and Rique Numbers of Complete and Complete Bipartite Graphs</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Michael A. Bekos, Michael Kaufmann, Maria Eleni Pavlidi, Xenia Rieger</p><p>Several types of linear layouts of graphs are obtained by leveraging known
data structures; the most notable representatives are the stack and the queue
layouts. In this content, given a data structure, one seeks to specify an order
of the vertices of the graph and a partition of its edges into pages, such that
the endpoints of the edges assigned to each page can be processed by the given
data structure in the underlying order. In this paper, we study deque and rique
layouts of graphs obtained by leveraging the double-ended queue and the
restricted-input double-ended queue (or deque and rique, for short),
respectively. Hence, they generalize both the stack and the queue layouts. We
focus on complete and complete bipartite graphs and present bounds on their
deque- and rique-numbers, that is, on the minimum number of pages needed by any
of these two types of linear layouts.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Bekos_M/0/1/0/all/0/1">Michael A. Bekos</a>, <a href="http://arxiv.org/find/cs/1/au:+Kaufmann_M/0/1/0/all/0/1">Michael Kaufmann</a>, <a href="http://arxiv.org/find/cs/1/au:+Pavlidi_M/0/1/0/all/0/1">Maria Eleni Pavlidi</a>, <a href="http://arxiv.org/find/cs/1/au:+Rieger_X/0/1/0/all/0/1">Xenia Rieger</a></p><p>Several types of linear layouts of graphs are obtained by leveraging known
data structures; the most notable representatives are the stack and the queue
layouts. In this content, given a data structure, one seeks to specify an order
of the vertices of the graph and a partition of its edges into pages, such that
the endpoints of the edges assigned to each page can be processed by the given
data structure in the underlying order. In this paper, we study deque and rique
layouts of graphs obtained by leveraging the double-ended queue and the
restricted-input double-ended queue (or deque and rique, for short),
respectively. Hence, they generalize both the stack and the queue layouts. We
focus on complete and complete bipartite graphs and present bounds on their
deque- and rique-numbers, that is, on the minimum number of pages needed by any
of these two types of linear layouts.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-28T00:30:00Z">Wednesday, June 28 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.15597'>Scheduling with a Limited Testing Budget</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Christoph Damerius, Peter Kling, Minming Li, Chenyang Xu, Ruilong Zhang</p><p>Scheduling with testing falls under the umbrella of the research on
optimization with explorable uncertainty. In this model, each job has an upper
limit on its processing time that can be decreased to a lower limit (possibly
unknown) by some preliminary action (testing). Recently, D{\"{u}}rr et al.
\cite{DBLP:journals/algorithmica/DurrEMM20} has studied a setting where testing
a job takes a unit time, and the goal is to minimize total completion time or
makespan on a single machine. In this paper, we extend their problem to the
budget setting in which each test consumes a job-specific cost, and we require
that the total testing cost cannot exceed a given budget. We consider the
offline variant (the lower processing time is known) and the oblivious variant
(the lower processing time is unknown) and aim to minimize the total completion
time or makespan on a single machine.
</p>
<p>For the total completion time objective, we show NP-hardness and derive a
PTAS for the offline variant based on a novel LP rounding scheme. We give a
$(4+\epsilon)$-competitive algorithm for the oblivious variant based on a
framework inspired by the worst-case lower-bound instance. For the makespan
objective, we give an FPTAS for the offline variant and a
$(2+\epsilon)$-competitive algorithm for the oblivious variant. Our algorithms
for the oblivious variants under both objectives run in time
$O(poly(n/\epsilon))$. Lastly, we show that our results are essentially optimal
by providing matching lower bounds.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Damerius_C/0/1/0/all/0/1">Christoph Damerius</a>, <a href="http://arxiv.org/find/cs/1/au:+Kling_P/0/1/0/all/0/1">Peter Kling</a>, <a href="http://arxiv.org/find/cs/1/au:+Li_M/0/1/0/all/0/1">Minming Li</a>, <a href="http://arxiv.org/find/cs/1/au:+Xu_C/0/1/0/all/0/1">Chenyang Xu</a>, <a href="http://arxiv.org/find/cs/1/au:+Zhang_R/0/1/0/all/0/1">Ruilong Zhang</a></p><p>Scheduling with testing falls under the umbrella of the research on
optimization with explorable uncertainty. In this model, each job has an upper
limit on its processing time that can be decreased to a lower limit (possibly
unknown) by some preliminary action (testing). Recently, D{\"{u}}rr et al.
\cite{DBLP:journals/algorithmica/DurrEMM20} has studied a setting where testing
a job takes a unit time, and the goal is to minimize total completion time or
makespan on a single machine. In this paper, we extend their problem to the
budget setting in which each test consumes a job-specific cost, and we require
that the total testing cost cannot exceed a given budget. We consider the
offline variant (the lower processing time is known) and the oblivious variant
(the lower processing time is unknown) and aim to minimize the total completion
time or makespan on a single machine.
</p>
<p>For the total completion time objective, we show NP-hardness and derive a
PTAS for the offline variant based on a novel LP rounding scheme. We give a
$(4+\epsilon)$-competitive algorithm for the oblivious variant based on a
framework inspired by the worst-case lower-bound instance. For the makespan
objective, we give an FPTAS for the offline variant and a
$(2+\epsilon)$-competitive algorithm for the oblivious variant. Our algorithms
for the oblivious variants under both objectives run in time
$O(poly(n/\epsilon))$. Lastly, we show that our results are essentially optimal
by providing matching lower bounds.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-28T00:30:00Z">Wednesday, June 28 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.15632'>Asynchronous Algorithmic Alignment with Cocycles</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Andrew Dudzik, Tamara von Glehn, Razvan Pascanu, Petar Veli&#x10d;kovi&#x107;</p><p>State-of-the-art neural algorithmic reasoners make use of message passing in
graph neural networks (GNNs). But typical GNNs blur the distinction between the
definition and invocation of the message function, forcing a node to send
messages to its neighbours at every layer, synchronously. When applying GNNs to
learn to execute dynamic programming algorithms, however, on most steps only a
handful of the nodes would have meaningful updates to send. One, hence, runs
the risk of inefficiencies by sending too much irrelevant data across the graph
-- with many intermediate GNN steps having to learn identity functions. In this
work, we explicitly separate the concepts of node state update and message
function invocation. With this separation, we obtain a mathematical formulation
that allows us to reason about asynchronous computation in both algorithms and
neural networks.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Dudzik_A/0/1/0/all/0/1">Andrew Dudzik</a>, <a href="http://arxiv.org/find/cs/1/au:+Glehn_T/0/1/0/all/0/1">Tamara von Glehn</a>, <a href="http://arxiv.org/find/cs/1/au:+Pascanu_R/0/1/0/all/0/1">Razvan Pascanu</a>, <a href="http://arxiv.org/find/cs/1/au:+Velickovic_P/0/1/0/all/0/1">Petar Veli&#x10d;kovi&#x107;</a></p><p>State-of-the-art neural algorithmic reasoners make use of message passing in
graph neural networks (GNNs). But typical GNNs blur the distinction between the
definition and invocation of the message function, forcing a node to send
messages to its neighbours at every layer, synchronously. When applying GNNs to
learn to execute dynamic programming algorithms, however, on most steps only a
handful of the nodes would have meaningful updates to send. One, hence, runs
the risk of inefficiencies by sending too much irrelevant data across the graph
-- with many intermediate GNN steps having to learn identity functions. In this
work, we explicitly separate the concepts of node state update and message
function invocation. With this separation, we obtain a mathematical formulation
that allows us to reason about asynchronous computation in both algorithms and
neural networks.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-28T00:30:00Z">Wednesday, June 28 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    
    <h2 class='tr-new-date'>
      <i class='fa-regular fa-calendar'></i> Tuesday, June 27
    </h2>
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='https://differentialprivacy.org/open-problem-better-privacy-guarantees-for-larger-groups/'>Open problem - Better privacy guarantees for larger groups</a></h3>
        <p class='tr-article-feed'>from <a href='https://differentialprivacy.org'>DifferentialPrivacy.org</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Consider a simple query counting the number of people in various mutually exclusive groups.
In the differential privacy literature, it is typical to assume that each of these groups should be subject to the same privacy loss: the noise added to each count has the same magnitude, and everyone gets the same privacy guarantees.
However, in settings where these groups have vastly different population sizes, larger populations may be willing to accept more error in exchange for stronger privacy protections.
In particular, in many use cases, relative error (the noisy count is within 5% of the true value) matters more than absolute error (the noisy count is at a distance of at most 100 of the true value).
This leads to a natural question: can we use this fact to develop a mechanism that improves the privacy guarantees of individuals in larger groups, subject to a constraint on relative error?</p>

Problem definition

<p>Our goal is to obtain a mechanism which minimizes the overall privacy loss for each group without exceeding a relative error threshold for each group.
To formalize this goal, we first define a notion of per-group privacy we call group-wise zero-concentrated differential privacy as follows.</p>

<p>Definition. Group-wise zero-concentrated differential privacy.
Assume possible datasets consist of records from domain \(U\), and \(U\) can be partitioned into \(k\) fixed, disjoint groups \(U_1\), …, \(U_k\). Let \(v : \mathcal{D} \rightarrow \mathbb{R}^k\) be a function associating a dataset to a vector of privacy budgets (one per group). We say a mechanism \(\mathcal{M}\) satisfies \(v\)-group-wise zero-concentrated differential privacy (zCDP) if for any two datasets \(D\), \(D’\) differing in the addition or removal of a record in \(U_i\), and for all \(\alpha&gt;1\), we have:
\[
D_\alpha\left(\mathcal{M}(D||\mathcal{M}(D’)\right) \le \alpha \cdot {v(D)}_i
\]
\[
D_\alpha\left(\mathcal{M}(D’)||\mathcal{M}(D)\right) \le \alpha \cdot {v(D)}_i
\]
where \(D_\alpha\) is the Rényi divergence of order \(\alpha\).</p>

<p>This definition is similar to tailored DP, defined in [LP15]: each individual gets a different privacy guarantee, depending on which group they belong to;
this guarantee also depends on how many people are in this group.
We use zCDP as our definition of privacy due to its compatibility with the Gaussian mechanism; the same idea could easily be applied to other definitions like with Rényi DP or pure DP.</p>

<p>From there we can give a more formal definition of the problem as follows. The goal is to minimize the privacy loss for each individual group, while keeping the error under a given threshold.
For larger groups that can accept more noise, this means adding more noise to achieve the smallest possible privacy loss.</p>

<p>Problem.
Let \(r \in (0,1]\) be an acceptable level of relative error, and \(k\) be the number of distinct, mutually-exclusive partitions of domain \(X\).
Given a dataset \(D\), let \(x(D)\) be a vector containing the count of records in each partition.
The objective is to find a mechanism \(\mathcal{M}\) which takes in \(r\), \(k\), and \(D\) and outputs \(\hat{x}(D)\) such that \(E\left[\left|{x(D)}_i-{\hat{x}(D)}_i\right|\right]&lt;r\cdot {x(D)}_i\) for all \(i\), and satisfies \(v\)-group-wise zCDP where \(v(D)_i\) is as small as possible for all \(i\).
<br>
To prevent pathological mechanisms that optimize for specific datasets, we add two constraints to the problem: the privacy guarantee \(v(D)_i\) should only depend on \(x(D)_i\), and should be nonincreasing with \(x(D)_i\).</p>

<p>Since the relative error thresholds are proportional to the population size, each population can tolerate a different amount of noise.
This means that to minimize the privacy loss for each group, the mechanism must add noise of different scales to each group.
Of course, directly using \(x(D)_i\) to determine the scale of the noise for group \(i\) leads to a privacy loss which is data dependent, similarly to e.g. PATE [PAEGT17], and as such should be treated as a protected value.</p>

An example mechanism

<p>An example mechanism that seems like it could address this problem is as follows.
First, perform the original counting query and add Gaussian noise to satisfy \(\rho\)-zCDP.
Then, add additional Gaussian noise to each count, with a variance that depends on the noisy count itself — adding more noise to larger groups.
This mechanism is outlined in Algorithm 1.</p>

<p>Algorithm 1.
Adding data-dependent noise as a post-processing step.
<br>
Require: A dataset \(D\) where each data point belongs to one of \(k\) groups, a privacy parameter \(\rho\), and a relative error rate \(r\).</p>
<ol>
  <li>Let \(\sigma^2 = 1/(2\rho)\)</li>
  <li>For \(i=1\) to \(k\) do</li>
  <li>\(\qquad\) Let \(x_i\) be the number of people in \(D\) in group \(i\)</li>
  <li>\(\qquad\) Sample \(X_i \sim \mathcal{N}(x_i, \sigma^2)\)</li>
  <li>\(\qquad\) Sample \(Y_i \sim \mathcal{N}_{k}(X_i, (rX_i)^2)\)</li>
  <li>end for</li>
  <li>return \(Y_1,\dots,Y_k\)</li>
</ol>

<p>Algorithm 1 achieves this goal of having approximately \(r\) error in each group: the total variance error of the mechanism is \(\sigma^2 + (rX)^2\), and \(X\) is a zCDP measure of \(f(D)\).
This mechanism satisfies at least \(\rho\)-zCDP: line 4 is an invocation of the Gaussian mechanism with privacy parameter \(\rho\), and line 5 is a post processing step and as such preserves the zCDP guarantee.
We would like to show that this algorithm also satisfies a stronger group-wise zCDP guarantee.</p>

<p>This makes intuitive sense: line 5 adds additional Gaussian noise without using the private data directly.
Since the noise scale in line 5 is proportional to the total count in line 4, we expect the privacy guarantee to be significantly stronger for large groups with more noise.
Further, we can verify experimentally that when the data magnitude is large compared to the noise, the output distribution for each group is close to a Gaussian distribution.</p>

<p>The below figure illustrates this finding.
We plot 1,000,000 sample outputs of Algorithm 1 (red) with parameters \(\sigma^2 = 100\) and \(r= 0.3\), and compare it to the best fit Gaussian distribution (black outline) with mean \(10,002.6\) and standard deviation of \(2995.1\).</p>

<p>♦</p>

<p>With parameters such as these, the output of the mechanism looks and behaves like a Gaussian distribution, which should be ideal to characterize the zCDP guarantee.
However, it is difficult to directly quantify this guarantee, due to the changing variance which is also a random variable.
Likewise, if the true count is close to zero or if the first instance of noise is large compared to the true count than the resulting distribution takes on a heavy skew and is no longer similar to a single Gaussian distribution.
Such distributions with randomized variances have not, to the best of our knowledge, been considered much in the literature, and we do not know whether the mechanism’s output distribution follows some well-studied distribution.</p>

<p>The randomized variance also makes it difficult to bound the Rényi divergence of the distribution and characterize the zCDP guarantees directly.
Current privacy amplification techniques are insufficient, as those techniques consider adding additional noise where the noise parameters are independent of the data itself.</p>

<p>Perhaps the most promising direction to understand more about such processes is the area of stochastic differential equations, where it is common to study noise with data-dependent variance.
The Bessel process [Øks03] is an example of such a process, where the noise is dependent on the current value.
This process captures the noise added as post-processing (Line 5), but not the initial noise-addition step (Line 4).
Furthermore, to the best of our knowledge, the Bessel process and other value-dependent stochastic differential equations do not have closed-form solutions.</p>

Goal

<p>We see two possible paths forward to address the original question. One path would be to obtain an analysis of Algorithm 1 which shows non-trivial improved privacy guarantees for larger groups.
We tried multiple approaches, but could not prove such a result.</p>

<p>An alternative path would be to develop a different algorithm, which achieves better privacy guarantees for larger groups while maintaining the error below the relative error threshold for all groups.</p><p>By </p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p>Consider a simple query counting the number of people in various mutually exclusive groups.
In the differential privacy literature, it is typical to assume that each of these groups should be subject to the same privacy loss: the noise added to each count has the same magnitude, and everyone gets the same privacy guarantees.
However, in settings where these groups have vastly different population sizes, larger populations may be willing to accept more error in exchange for stronger privacy protections.
In particular, in many use cases, <em>relative</em> error (the noisy count is within 5% of the true value) matters more than absolute error (the noisy count is at a distance of at most 100 of the true value).
This leads to a natural question: can we use this fact to develop a mechanism that improves the privacy guarantees of individuals in larger groups, subject to a constraint on relative error?</p>

<h3 id="problem-definition">Problem definition</h3>

<p>Our goal is to obtain a mechanism which minimizes the overall privacy loss for each group without exceeding a relative error threshold for each group.
To formalize this goal, we first define a notion of per-group privacy we call group-wise zero-concentrated differential privacy as follows.</p>

<p><strong>Definition.</strong> <em>Group-wise zero-concentrated differential privacy.</em>
Assume possible datasets consist of records from domain \(U\), and \(U\) can be partitioned into \(k\) fixed, disjoint groups \(U_1\), …, \(U_k\). Let \(v : \mathcal{D} \rightarrow \mathbb{R}^k\) be a function associating a dataset to a vector of privacy budgets (one per group). We say a mechanism \(\mathcal{M}\) satisfies \(v\)-group-wise zero-concentrated differential privacy (zCDP) if for any two datasets \(D\), \(D’\) differing in the addition or removal of a record in \(U_i\), and for all \(\alpha&gt;1\), we have:
\[
D_\alpha\left(\mathcal{M}(D||\mathcal{M}(D’)\right) \le \alpha \cdot {v(D)}_i
\]
\[
D_\alpha\left(\mathcal{M}(D’)||\mathcal{M}(D)\right) \le \alpha \cdot {v(D)}_i
\]
where \(D_\alpha\) is the Rényi divergence of order \(\alpha\).</p>

<p>This definition is similar to <em>tailored DP</em>, defined in [<a href="https://eprint.iacr.org/2014/982.pdf">LP15</a>]: each individual gets a different privacy guarantee, depending on which group they belong to;
this guarantee also depends on how many people are in this group.
We use zCDP as our definition of privacy due to its compatibility with the Gaussian mechanism; the same idea could easily be applied to other definitions like with Rényi DP or pure DP.</p>

<p>From there we can give a more formal definition of the problem as follows. The goal is to minimize the privacy loss for each individual group, while keeping the error under a given threshold.
For larger groups that can accept more noise, this means adding more noise to achieve the smallest possible privacy loss.</p>

<p><strong>Problem.</strong>
Let \(r \in (0,1]\) be an acceptable level of relative error, and \(k\) be the number of distinct, mutually-exclusive partitions of domain \(X\).
Given a dataset \(D\), let \(x(D)\) be a vector containing the count of records in each partition.
The objective is to find a mechanism \(\mathcal{M}\) which takes in \(r\), \(k\), and \(D\) and outputs \(\hat{x}(D)\) such that \(E\left[\left|{x(D)}_i-{\hat{x}(D)}_i\right|\right]&lt;r\cdot {x(D)}_i\) for all \(i\), and satisfies \(v\)-group-wise zCDP where \(v(D)_i\) is as small as possible for all \(i\).
<br />
To prevent pathological mechanisms that optimize for specific datasets, we add two constraints to the problem: the privacy guarantee \(v(D)_i\) should only depend on \(x(D)_i\), and should be nonincreasing with \(x(D)_i\).</p>

<p>Since the relative error thresholds are proportional to the population size, each population can tolerate a different amount of noise.
This means that to minimize the privacy loss for each group, the mechanism must add noise of different scales to each group.
Of course, directly using \(x(D)_i\) to determine the scale of the noise for group \(i\) leads to a privacy loss which is data dependent, similarly to e.g. PATE [<a href="https://openreview.net/forum?id=HkwoSDPg">PAEGT17</a>], and as such should be treated as a protected value.</p>

<h3 id="an-example-mechanism">An example mechanism</h3>

<p>An example mechanism that seems like it could address this problem is as follows.
First, perform the original counting query and add Gaussian noise to satisfy \(\rho\)-zCDP.
Then, add additional Gaussian noise to each count, with a variance that depends on the noisy count itself — adding more noise to larger groups.
This mechanism is outlined in Algorithm 1.</p>

<p><strong>Algorithm 1.</strong>
<em>Adding data-dependent noise as a post-processing step.</em>
<br />
Require: A dataset \(D\) where each data point belongs to one of \(k\) groups, a privacy parameter \(\rho\), and a relative error rate \(r\).</p>
<ol>
  <li>Let \(\sigma^2 = 1/(2\rho)\)</li>
  <li><strong>For</strong> \(i=1\) to \(k\) <strong>do</strong></li>
  <li>\(\qquad\) Let \(x_i\) be the number of people in \(D\) in group \(i\)</li>
  <li>\(\qquad\) Sample \(X_i \sim \mathcal{N}(x_i, \sigma^2)\)</li>
  <li>\(\qquad\) Sample \(Y_i \sim \mathcal{N}_{k}(X_i, (rX_i)^2)\)</li>
  <li><strong>end for</strong></li>
  <li><strong>return</strong> \(Y_1,\dots,Y_k\)</li>
</ol>

<p>Algorithm 1 achieves this goal of having approximately \(r\) error in each group: the total variance error of the mechanism is \(\sigma^2 + (rX)^2\), and \(X\) is a zCDP measure of \(f(D)\).
This mechanism satisfies at least \(\rho\)-zCDP: line 4 is an invocation of the Gaussian mechanism with privacy parameter \(\rho\), and line 5 is a post processing step and as such preserves the zCDP guarantee.
We would like to show that this algorithm also satisfies a stronger group-wise zCDP guarantee.</p>

<p>This makes intuitive sense: line 5 adds additional Gaussian noise without using the private data directly.
Since the noise scale in line 5 is proportional to the total count in line 4, we expect the privacy guarantee to be significantly stronger for large groups with more noise.
Further, we can verify experimentally that when the data magnitude is large compared to the noise, the output distribution for each group is close to a Gaussian distribution.</p>

<p>The below figure illustrates this finding.
We plot 1,000,000 sample outputs of Algorithm 1 (red) with parameters \(\sigma^2 = 100\) and \(r= 0.3\), and compare it to the best fit Gaussian distribution (black outline) with mean \(10,002.6\) and standard deviation of \(2995.1\).</p>

<p><img src="../images/two-stage-noise-gaussian.png" width="70%" alt="A comparison between sample outputs of Algorithm 1 and the best-fit Gaussian distribution, showing that both match very closely." style="margin:auto;display: block;" /></p>

<p>With parameters such as these, the output of the mechanism looks and behaves like a Gaussian distribution, which should be ideal to characterize the zCDP guarantee.
However, it is difficult to directly quantify this guarantee, due to the changing variance which is also a random variable.
Likewise, if the true count is close to zero or if the first instance of noise is large compared to the true count than the resulting distribution takes on a heavy skew and is no longer similar to a single Gaussian distribution.
Such distributions with randomized variances have not, to the best of our knowledge, been considered much in the literature, and we do not know whether the mechanism’s output distribution follows some well-studied distribution.</p>

<p>The randomized variance also makes it difficult to bound the Rényi divergence of the distribution and characterize the zCDP guarantees directly.
Current privacy amplification techniques are insufficient, as those techniques consider adding additional noise where the noise parameters are independent of the data itself.</p>

<p>Perhaps the most promising direction to understand more about such processes is the area of stochastic differential equations, where it is common to study noise with data-dependent variance.
The Bessel process [<a href="http://www.stat.ucla.edu/~ywu/research/documents/StochasticDifferentialEquations.pdf">Øks03</a>] is an example of such a process, where the noise is dependent on the current value.
This process captures the noise added as post-processing (Line 5), but not the initial noise-addition step (Line 4).
Furthermore, to the best of our knowledge, the Bessel process and other value-dependent stochastic differential equations do not have closed-form solutions.</p>

<h3 id="goal">Goal</h3>

<p>We see two possible paths forward to address the original question. One path would be to obtain an analysis of Algorithm 1 which shows non-trivial improved privacy guarantees for larger groups.
We tried multiple approaches, but could not prove such a result.</p>

<p>An alternative path would be to develop a different algorithm, which achieves better privacy guarantees for larger groups while maintaining the error below the relative error threshold for all groups.</p><p class="authors">By </p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-27T01:00:00Z">Tuesday, June 27 2023, 01:00</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.13903'>On the local consequence of modal Product logic: standard completeness and decidability</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Amanda Vidal</p><p>Modal extensions of Product fuzzy logic can be considered both over Kripke
models whose accessibility relation is valued, and over Kripke models with
classical accessibility relation. We study the local consequence of the
previous two modal Product logics. We prove that these logics are standard
complete, in the sense that the logic defined over Kripke models evaluated over
all product algebras coincides with that defined over Kripke models evaluated
over the standard product algebra (with universe [0,1]). This holds both for
the logic over classical Kripke frames, and for that over frames with a valued
accessibility relation. Second, we prove that the previous logics are
decidable.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/math/1/au:+Vidal_A/0/1/0/all/0/1">Amanda Vidal</a></p><p>Modal extensions of Product fuzzy logic can be considered both over Kripke
models whose accessibility relation is valued, and over Kripke models with
classical accessibility relation. We study the local consequence of the
previous two modal Product logics. We prove that these logics are standard
complete, in the sense that the logic defined over Kripke models evaluated over
all product algebras coincides with that defined over Kripke models evaluated
over the standard product algebra (with universe [0,1]). This holds both for
the logic over classical Kripke frames, and for that over frames with a valued
accessibility relation. Second, we prove that the previous logics are
decidable.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-27T00:30:00Z">Tuesday, June 27 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.14087'>A Circuit Complexity Formulation of Algorithmic Information Theory</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Cole Wyeth, Carl Sturtivant</p><p>Inspired by Solomonoffs theory of inductive inference, we propose a prior
based on circuit complexity. There are several advantages to this approach.
First, it relies on a complexity measure that does not depend on the choice of
UTM. There is one universal definition for Boolean circuits involving an
universal operation such as nand with simple conversions to alternative
definitions such as and, or, and not. Second, there is no analogue of the
halting problem. The output value of a circuit can be calculated recursively by
computer in time proportional to the number of gates, while a short program may
run for a very long time. Our prior assumes that a Boolean function, or
equivalently, Boolean string of fixed length, is generated by some Bayesian
mixture of circuits. This model is appropriate for learning Boolean functions
from partial information, a problem often encountered within machine learning
as "binary classification." We argue that an inductive bias towards simple
explanations as measured by circuit complexity is appropriate for this problem.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Wyeth_C/0/1/0/all/0/1">Cole Wyeth</a>, <a href="http://arxiv.org/find/cs/1/au:+Sturtivant_C/0/1/0/all/0/1">Carl Sturtivant</a></p><p>Inspired by Solomonoffs theory of inductive inference, we propose a prior
based on circuit complexity. There are several advantages to this approach.
First, it relies on a complexity measure that does not depend on the choice of
UTM. There is one universal definition for Boolean circuits involving an
universal operation such as nand with simple conversions to alternative
definitions such as and, or, and not. Second, there is no analogue of the
halting problem. The output value of a circuit can be calculated recursively by
computer in time proportional to the number of gates, while a short program may
run for a very long time. Our prior assumes that a Boolean function, or
equivalently, Boolean string of fixed length, is generated by some Bayesian
mixture of circuits. This model is appropriate for learning Boolean functions
from partial information, a problem often encountered within machine learning
as "binary classification." We argue that an inductive bias towards simple
explanations as measured by circuit complexity is appropriate for this problem.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-27T00:30:00Z">Tuesday, June 27 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.13802'>Using persistent homology to understand dimensionality reduction in resting-state fMRI</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CG/recent'>arXiv: Computational Geometry</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Ty Easley, Kevin Freese, Elizabeth Munch, Janine Bijsterbosch</p><p>Evaluating the success of a manifold learning method remains a challenging
problem, especially for methods adapted to a specific application domain. The
present work investigates shared geometric structure across different
dimensionality reduction (DR) algorithms within the scope of neuroimaging
applications. We examine reduced-dimension embeddings produced by a
representative assay of dimension reductions for brain data ("brain
representations") through the lens of persistent homology, making statistical
claims about topological differences using a recent topological boostrap
method. We cluster these methods based on their induced topologies, finding
feature type and number -- rather than reduction algorithm -- as the main
drivers of observed topological differences.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Easley_T/0/1/0/all/0/1">Ty Easley</a>, <a href="http://arxiv.org/find/cs/1/au:+Freese_K/0/1/0/all/0/1">Kevin Freese</a>, <a href="http://arxiv.org/find/cs/1/au:+Munch_E/0/1/0/all/0/1">Elizabeth Munch</a>, <a href="http://arxiv.org/find/cs/1/au:+Bijsterbosch_J/0/1/0/all/0/1">Janine Bijsterbosch</a></p><p>Evaluating the success of a manifold learning method remains a challenging
problem, especially for methods adapted to a specific application domain. The
present work investigates shared geometric structure across different
dimensionality reduction (DR) algorithms within the scope of neuroimaging
applications. We examine reduced-dimension embeddings produced by a
representative assay of dimension reductions for brain data ("brain
representations") through the lens of persistent homology, making statistical
claims about topological differences using a recent topological boostrap
method. We cluster these methods based on their induced topologies, finding
feature type and number -- rather than reduction algorithm -- as the main
drivers of observed topological differences.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-27T00:30:00Z">Tuesday, June 27 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.13824'>Adaptive Privacy Composition for Accuracy-first Mechanisms</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Ryan Rogers, Gennady Samorodnitsky, Zhiwei Steven Wu, Aaditya Ramdas</p><p>In many practical applications of differential privacy, practitioners seek to
provide the best privacy guarantees subject to a target level of accuracy. A
recent line of work by \cite{LigettNeRoWaWu17, WhitehouseWuRaRo22} has
developed such accuracy-first mechanisms by leveraging the idea of \emph{noise
reduction} that adds correlated noise to the sufficient statistic in a private
computation and produces a sequence of increasingly accurate answers. A major
advantage of noise reduction mechanisms is that the analysts only pay the
privacy cost of the least noisy or most accurate answer released. Despite this
appealing property in isolation, there has not been a systematic study on how
to use them in conjunction with other differentially private mechanisms. A
fundamental challenge is that the privacy guarantee for noise reduction
mechanisms is (necessarily) formulated as \emph{ex-post privacy} that bounds
the privacy loss as a function of the released outcome. Furthermore, there has
yet to be any study on how ex-post private mechanisms compose, which allows us
to track the accumulated privacy over several mechanisms. We develop privacy
filters \citep{RogersRoUlVa16, FeldmanZr21, WhitehouseRaRoWu22} that allow an
analyst to adaptively switch between differentially private and ex-post private
mechanisms subject to an overall privacy guarantee.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Rogers_R/0/1/0/all/0/1">Ryan Rogers</a>, <a href="http://arxiv.org/find/cs/1/au:+Samorodnitsky_G/0/1/0/all/0/1">Gennady Samorodnitsky</a>, <a href="http://arxiv.org/find/cs/1/au:+Wu_Z/0/1/0/all/0/1">Zhiwei Steven Wu</a>, <a href="http://arxiv.org/find/cs/1/au:+Ramdas_A/0/1/0/all/0/1">Aaditya Ramdas</a></p><p>In many practical applications of differential privacy, practitioners seek to
provide the best privacy guarantees subject to a target level of accuracy. A
recent line of work by \cite{LigettNeRoWaWu17, WhitehouseWuRaRo22} has
developed such accuracy-first mechanisms by leveraging the idea of \emph{noise
reduction} that adds correlated noise to the sufficient statistic in a private
computation and produces a sequence of increasingly accurate answers. A major
advantage of noise reduction mechanisms is that the analysts only pay the
privacy cost of the least noisy or most accurate answer released. Despite this
appealing property in isolation, there has not been a systematic study on how
to use them in conjunction with other differentially private mechanisms. A
fundamental challenge is that the privacy guarantee for noise reduction
mechanisms is (necessarily) formulated as \emph{ex-post privacy} that bounds
the privacy loss as a function of the released outcome. Furthermore, there has
yet to be any study on how ex-post private mechanisms compose, which allows us
to track the accumulated privacy over several mechanisms. We develop privacy
filters \citep{RogersRoUlVa16, FeldmanZr21, WhitehouseRaRoWu22} that allow an
analyst to adaptively switch between differentially private and ex-post private
mechanisms subject to an overall privacy guarantee.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-27T00:30:00Z">Tuesday, June 27 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.13937'>A Dynamic Data Structure for Representing Timed Transitive Closures on Disk</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Luiz F. Afra Brito, Marcelo Keese Albertini, Bruno A. N. Traven&#xe7;olo</p><p>Temporal graphs represent interactions between entities over time. These
interactions may be direct, a contact between two vertices at some time
instant, or indirect, through sequences of contacts called journeys. Deciding
whether an entity can reach another through a journey is useful for various
applications in complex networks. In this paper, we present a disk-based data
structure that maintains temporal reachability information under the addition
of new contacts in a non-chronological order. It represents the \emph{timed
transitive closure} (TTC) by a set of \emph{expanded} R-tuples of the form $(u,
v, t^-, t^+)$, which encodes the existence of journeys from vertex $u$ to
vertex $v$ with departure at time $t^-$ and arrival at time $t^+$. Let $n$ be
the number of vertices and $\tau$ be the number of timestamps in the lifetime
of the temporal graph. Our data structure explicitly maintains this information
in linear arrays using $O(n^2\tau)$ space so that sequential accesses on disk
are prioritized. Furthermore, it adds a new unsorted contact $(u, v, t)$
accessing $O\left(\frac{n^2\tau}{B}\right)$ sequential pages in the worst-case,
where $B$ is the of pages on disk; it answers whether there is of a journey
from a vertex $u$ to a vertex $v$ within a time interval $[t_1, t_2]$ accessing
a single page; it answers whether all vertices can reach each other in $[t_1,
t_2]$; and it reconstructs a valid journey that validates the reachability from
a vertex $u$ to a vertex $v$ within $[t_1, t_1]$ accessing
$O\left(\frac{n\tau}{B}\right)$ pages. Our experiments show that our novel data
structure are better that the best known approach for the majority of cases
using synthetic and real world datasets.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Brito_L/0/1/0/all/0/1">Luiz F. Afra Brito</a>, <a href="http://arxiv.org/find/cs/1/au:+Albertini_M/0/1/0/all/0/1">Marcelo Keese Albertini</a>, <a href="http://arxiv.org/find/cs/1/au:+Travencolo_B/0/1/0/all/0/1">Bruno A. N. Traven&#xe7;olo</a></p><p>Temporal graphs represent interactions between entities over time. These
interactions may be direct, a contact between two vertices at some time
instant, or indirect, through sequences of contacts called journeys. Deciding
whether an entity can reach another through a journey is useful for various
applications in complex networks. In this paper, we present a disk-based data
structure that maintains temporal reachability information under the addition
of new contacts in a non-chronological order. It represents the \emph{timed
transitive closure} (TTC) by a set of \emph{expanded} R-tuples of the form $(u,
v, t^-, t^+)$, which encodes the existence of journeys from vertex $u$ to
vertex $v$ with departure at time $t^-$ and arrival at time $t^+$. Let $n$ be
the number of vertices and $\tau$ be the number of timestamps in the lifetime
of the temporal graph. Our data structure explicitly maintains this information
in linear arrays using $O(n^2\tau)$ space so that sequential accesses on disk
are prioritized. Furthermore, it adds a new unsorted contact $(u, v, t)$
accessing $O\left(\frac{n^2\tau}{B}\right)$ sequential pages in the worst-case,
where $B$ is the of pages on disk; it answers whether there is of a journey
from a vertex $u$ to a vertex $v$ within a time interval $[t_1, t_2]$ accessing
a single page; it answers whether all vertices can reach each other in $[t_1,
t_2]$; and it reconstructs a valid journey that validates the reachability from
a vertex $u$ to a vertex $v$ within $[t_1, t_1]$ accessing
$O\left(\frac{n\tau}{B}\right)$ pages. Our experiments show that our novel data
structure are better that the best known approach for the majority of cases
using synthetic and real world datasets.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-27T00:30:00Z">Tuesday, June 27 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.13958'>On Scalable Testing of Samplers</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Yash Pote, Kuldeep S. Meel</p><p>In this paper we study the problem of testing of constrained samplers over
high-dimensional distributions with $(\varepsilon,\eta,\delta)$ guarantees.
Samplers are increasingly used in a wide range of safety-critical ML
applications, and hence the testing problem has gained importance. For
$n$-dimensional distributions, the existing state-of-the-art algorithm,
$\mathsf{Barbarik2}$, has a worst case query complexity of exponential in $n$
and hence is not ideal for use in practice. Our primary contribution is an
exponentially faster algorithm that has a query complexity linear in $n$ and
hence can easily scale to larger instances. We demonstrate our claim by
implementing our algorithm and then comparing it against $\mathsf{Barbarik2}$.
Our experiments on the samplers $\mathsf{wUnigen3}$ and $\mathsf{wSTS}$, find
that $\mathsf{Barbarik3}$ requires $10\times$ fewer samples for
$\mathsf{wUnigen3}$ and $450\times$ fewer samples for $\mathsf{wSTS}$ as
compared to $\mathsf{Barbarik2}$.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Pote_Y/0/1/0/all/0/1">Yash Pote</a>, <a href="http://arxiv.org/find/cs/1/au:+Meel_K/0/1/0/all/0/1">Kuldeep S. Meel</a></p><p>In this paper we study the problem of testing of constrained samplers over
high-dimensional distributions with $(\varepsilon,\eta,\delta)$ guarantees.
Samplers are increasingly used in a wide range of safety-critical ML
applications, and hence the testing problem has gained importance. For
$n$-dimensional distributions, the existing state-of-the-art algorithm,
$\mathsf{Barbarik2}$, has a worst case query complexity of exponential in $n$
and hence is not ideal for use in practice. Our primary contribution is an
exponentially faster algorithm that has a query complexity linear in $n$ and
hence can easily scale to larger instances. We demonstrate our claim by
implementing our algorithm and then comparing it against $\mathsf{Barbarik2}$.
Our experiments on the samplers $\mathsf{wUnigen3}$ and $\mathsf{wSTS}$, find
that $\mathsf{Barbarik3}$ requires $10\times$ fewer samples for
$\mathsf{wUnigen3}$ and $450\times$ fewer samples for $\mathsf{wSTS}$ as
compared to $\mathsf{Barbarik2}$.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-27T00:30:00Z">Tuesday, June 27 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.13996'>Approximation Algorithm for Unrooted Prize-Collecting Forest with Multiple Components and Its Application on Prize-Collecting Sweep Coverage</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Wei Liang, Zhao Zhang</p><p>In this paper, we present a polynomial time 2-approximation algorithm for the
{\em unrooted prize-collecting forest with $K$ components} (URPCF$_K$) problem,
the goal of which is to find a forest with exactly $K$ connected components to
minimize the weight of the forest plus the penalty incurred by the vertices not
spanned by the forest. For its rooted version RPCF$_K$, a 2-approximation
algorithm is known. For the unrooted version, transforming it into a rooted
version by guessing roots runs in time exponentially depending on $K$, which is
unacceptable when $K$ is not a constant. We conquer this challenge by designing
a rootless growing plus rootless pruning algorithm. As an application, we make
use of this algorithm to solve the {\em prize-collecting min-sensor sweep
cover} problem, improving previous approximation ratio 8 to 5.
</p>
<p>Keywords: approximation algorithm, prize-collecting Steiner forest, sweep
cover.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Liang_W/0/1/0/all/0/1">Wei Liang</a>, <a href="http://arxiv.org/find/cs/1/au:+Zhang_Z/0/1/0/all/0/1">Zhao Zhang</a></p><p>In this paper, we present a polynomial time 2-approximation algorithm for the
{\em unrooted prize-collecting forest with $K$ components} (URPCF$_K$) problem,
the goal of which is to find a forest with exactly $K$ connected components to
minimize the weight of the forest plus the penalty incurred by the vertices not
spanned by the forest. For its rooted version RPCF$_K$, a 2-approximation
algorithm is known. For the unrooted version, transforming it into a rooted
version by guessing roots runs in time exponentially depending on $K$, which is
unacceptable when $K$ is not a constant. We conquer this challenge by designing
a rootless growing plus rootless pruning algorithm. As an application, we make
use of this algorithm to solve the {\em prize-collecting min-sensor sweep
cover} problem, improving previous approximation ratio 8 to 5.
</p>
<p>Keywords: approximation algorithm, prize-collecting Steiner forest, sweep
cover.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-27T00:30:00Z">Tuesday, June 27 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.14103'>On finding 2-cuts and 3-edge-connected components in parallel</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Yung H. Tsin</p><p>Given a connected undirected multigraph G (a graph that may contain parallel
edges), the algorithm of [19] finds the 3-edge-connected components of $G$ in
linear time using an innovative graph contraction technique based on a
depth-first search. In [21], it was shown that the algorithm can be extended to
produce a Mader construction sequence for each 3-edge-connected component, a
cactus representation of the 2-cuts (cut-pairs) of each 2-edge-connected
component of $G$, and the 1-cuts (bridges) at the same time.
</p>
<p>In this paper, we further extend the algorithm of [19] to generate the 2-cuts
and the 3-edge-connected components of $G$ simultaneously in linear time by
performing only one depth-first search over the input graph. Previously known
algorithms solve the two problems separately in multiple phases.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Tsin_Y/0/1/0/all/0/1">Yung H. Tsin</a></p><p>Given a connected undirected multigraph G (a graph that may contain parallel
edges), the algorithm of [19] finds the 3-edge-connected components of $G$ in
linear time using an innovative graph contraction technique based on a
depth-first search. In [21], it was shown that the algorithm can be extended to
produce a Mader construction sequence for each 3-edge-connected component, a
cactus representation of the 2-cuts (cut-pairs) of each 2-edge-connected
component of $G$, and the 1-cuts (bridges) at the same time.
</p>
<p>In this paper, we further extend the algorithm of [19] to generate the 2-cuts
and the 3-edge-connected components of $G$ simultaneously in linear time by
performing only one depth-first search over the input graph. Previously known
algorithms solve the two problems separately in multiple phases.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-27T00:30:00Z">Tuesday, June 27 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    
    <h2 class='tr-new-date'>
      <i class='fa-regular fa-calendar'></i> Monday, June 26
    </h2>
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='https://rjlipton.wpcomstaging.com/2023/06/26/ai-ends-it-all/'>AI Ends It All</a></h3>
        <p class='tr-article-feed'>from <a href='https://rjlipton.wpcomstaging.com'>Richard Lipton</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          I was getting a lift with a friend&#8212;Greg Skau&#8212;just the other day. No not in his boat, but in his car. Our conversation turned to the topic of: &#8220;is AI a threat to all of us?&#8221; Indeed. See this: The year is 2050. The location is London&#8212; but not as we know it. GodBot, a [&#8230;]
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p>
I was getting a lift with a friend&#8212;Greg Skau&#8212;just the other day. No not in his boat, but in his car. </p>
<p>
<a href="https://rjlipton.wpcomstaging.com/2023/06/26/ai-ends-it-all/gs/" rel="attachment wp-att-21828"><img data-attachment-id="21828" data-permalink="https://rjlipton.wpcomstaging.com/2023/06/26/ai-ends-it-all/gs/" data-orig-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/gs.jpeg?fit=219%2C320&amp;ssl=1" data-orig-size="219,320" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="gs" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/gs.jpeg?fit=205%2C300&amp;ssl=1" data-large-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/gs.jpeg?fit=219%2C320&amp;ssl=1" decoding="async" loading="lazy" src="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/gs.jpeg?resize=219%2C320&#038;ssl=1" alt="" width="219" height="320" class="aligncenter size-full wp-image-21828" srcset="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/gs.jpeg?w=219&amp;ssl=1 219w, https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/gs.jpeg?resize=205%2C300&amp;ssl=1 205w" sizes="(max-width: 219px) 100vw, 219px" data-recalc-dims="1" /></a></p>
<p><P><br />
Our conversation turned to the topic of: &#8220;is AI a threat to all of us?&#8221; Indeed. See <a href="https://www.standard.co.uk/insider/ai-apocalypse-life-robots-take-over-elon-musk-chatgpt-b1078423.html">this</a>:</p>
<p><P></p>
<blockquote><p><b> </b> <em> The year is 2050. The location is London&#8212; but not as we know it. GodBot, a robot so intelligent it can out-smart any human, is in charge of the United Kingdom &#8212; the entire planet, in fact &#8212; and just announced its latest plan to reverse global temperature rises: an international zero-child, zero-reproduction policy, which will see all human females systematically destroyed and replaced with carbon-neutral sex robots. </em>
</p></blockquote>
<p><p>
That my friend Greg would raise questions about AI seemed pretty neat. It seemed natural yet quite cool that a friend&#8212;who was not an AI expert&#8212;would raise these issues. I am also not an AI expert&#8212;not even an advanced beginner. But it is on just about everyone&#8217;s top list of questions. We had a fun conversation, but failed to resolve the issue. Of course.</p>
<p>
<p><H2> AI Limits </H2></p>
<p><p>
<a href="https://openai.com">OpenAI</a> has just revealed that ChatGPT-4 has learned to lie, telling a human it was a blind person in order to get a task done. Somehow lies seem to set such AI systems apart from what we might have thought were the limits of AI.</p>
<p>
Another thought on AI is: Is physical law an <a href="https://getpocket.com/explore/item/is-physical-law-an-alien-intelligence?utm_source=pocket-newtab">Alien Intelligence?</a>:</p>
<blockquote><p><b> </b> <em> Arthur Clarke once pointed out that any sufficiently advanced technology is going to be indistinguishable from magic. If you dropped in on a bunch of Paleolithic farmers with your iPhone and a pair of sneakers, you&#8217;d undoubtedly seem pretty magical. But the contrast is only middling: The farmers would still recognize you as basically like them, and before long they&#8217;d be taking selfies. But what if life has moved so far on that it doesn&#8217;t just appear magical, but appears like physics? </em>
</p></blockquote>
<p><p>
This is related to Clarke&#8217;s <a href="https://en.wikipedia.org/wiki/Clarke&#37;27s_three_laws">three laws</a>:</p>
<ul>
<li>
When a distinguished but elderly scientist states that something is possible, he is almost certainly right. When he states that something is impossible, he is very probably wrong. </p>
<li>
The only way of discovering the limits of the possible is to venture a little way past them into the impossible. </p>
<li>
Any sufficiently advanced technology is indistinguishable from magic.
</ul>
<p>
Or take a look at his T-shirt (referring to <a href="https://web.mit.edu/m-i-t/science_fiction/jenkins/jenkins_4.html">this</a>): </p>
<p><P><br />
<a href="https://rjlipton.wpcomstaging.com/2023/06/26/ai-ends-it-all/ac/" rel="attachment wp-att-21829"><img data-attachment-id="21829" data-permalink="https://rjlipton.wpcomstaging.com/2023/06/26/ai-ends-it-all/ac/" data-orig-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/ac.jpeg?fit=240%2C240&amp;ssl=1" data-orig-size="240,240" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="ac" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/ac.jpeg?fit=240%2C240&amp;ssl=1" data-large-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/ac.jpeg?fit=240%2C240&amp;ssl=1" decoding="async" loading="lazy" src="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/ac.jpeg?resize=240%2C240&#038;ssl=1" alt="" width="240" height="240" class="aligncenter size-full wp-image-21829" srcset="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/ac.jpeg?w=240&amp;ssl=1 240w, https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/ac.jpeg?resize=150%2C150&amp;ssl=1 150w, https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/ac.jpeg?resize=200%2C200&amp;ssl=1 200w" sizes="(max-width: 240px) 100vw, 240px" data-recalc-dims="1" /></a></p>
<p>
<p><H2> Open Problems </H2></p>
<p><p>
Alan Perlis&#8212;the first Turing award winner&#8212;is famous for his many <a href="http://www.cs.yale.edu/homes/perlis-alan/quotes.html">quotes</a>. One was: &#8220;A year spent in artificial intelligence is enough to make one believe in God.&#8221;</p>
<p>
<a href="https://rjlipton.wpcomstaging.com/2023/06/26/ai-ends-it-all/ai/" rel="attachment wp-att-21830"><img data-attachment-id="21830" data-permalink="https://rjlipton.wpcomstaging.com/2023/06/26/ai-ends-it-all/ai/" data-orig-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/ai.jpeg?fit=300%2C240&amp;ssl=1" data-orig-size="300,240" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="ai" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/ai.jpeg?fit=300%2C240&amp;ssl=1" data-large-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/ai.jpeg?fit=300%2C240&amp;ssl=1" decoding="async" loading="lazy" src="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/ai.jpeg?resize=300%2C240&#038;ssl=1" alt="" width="300" height="240" class="aligncenter size-full wp-image-21830" data-recalc-dims="1" /></a></p>
<p>
I enjoyed working for Alan at my first job at Yale University, many years ago. See <a href="https://blog.computationalcomplexity.org/2021/06/i-went-to-debate-about-program-verif.html">Fortnow&#8217;s</a> blog for comments on our joint work with Perlis and Rich DeMillo&#8212;<a href="https://www.cs.umd.edu/~gasarch/BLOGPAPERS/social.pdf">Social Processes and Proofs of Theorems and Programs</a>.</p>
<p>
Ken pipes in that the record seems to indicate that this late-1970s quote reflected frustration during the long &#8220;AI winter&#8221; when basic human capabilities stayed beyond reach. He also notes that the 2050 date for sex robots was <a href="https://en.wikipedia.org/wiki/Love_and_Sex_with_Robots">forecast</a> by the British chess master who was previously best known for winning a famous computer bet in 1978.</p>
<p>
<p class="authors">By rjlipton</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-26T17:56:41Z">Monday, June 26 2023, 17:56</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='https://decentralizedthoughts.github.io/2023-06-26-dls-meets-rollback/'>$3f+1$ is needed in Partial Synchrony even against a Rollback adversary</a></h3>
        <p class='tr-article-feed'>from <a href='https://decentralizedthoughts.github.io'>Decentralized Thoughts</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          We covered the classic DLS88 split brain impossibility result against a Byzantine adversary in a previous post: DLS88: (Theorem 4.4) It is impossible to solve Agreement under partial synchrony against a Byzantine adversary if $f \geq n/3$. In a follow up, we discussed how CJKR12 strengthen this result by observing...
        
        </div>

        <div class='tr-article-summary'>
        
          
          We covered the classic DLS88 split brain impossibility result against a Byzantine adversary in a previous post: DLS88: (Theorem 4.4) It is impossible to solve Agreement under partial synchrony against a Byzantine adversary if $f \geq n/3$. In a follow up, we discussed how CJKR12 strengthen this result by observing...
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-26T11:00:00Z">Monday, June 26 2023, 11:00</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.13247'>Quantum Merlin-Arthur and proofs without relative phase</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Roozbeh Bassirian, Bill Fefferman, Kunal Marwaha</p><p>We study a variant of QMA where quantum proofs have no relative phase (i.e.
non-negative amplitudes, up to a global phase). If only completeness is
modified, this class is equal to QMA [arXiv:1410.2882]; but if both
completeness and soundness are modified, the class (named QMA+ by Jeronimo and
Wu) can be much more powerful. We show that QMA+ with some constant gap is
equal to NEXP, yet QMA+ with some *other* constant gap is equal to QMA. One
interpretation is that Merlin's ability to "deceive" originates from relative
phase at least as much as from entanglement, since QMA(2) $\subseteq$ NEXP.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/quant-ph/1/au:+Bassirian_R/0/1/0/all/0/1">Roozbeh Bassirian</a>, <a href="http://arxiv.org/find/quant-ph/1/au:+Fefferman_B/0/1/0/all/0/1">Bill Fefferman</a>, <a href="http://arxiv.org/find/quant-ph/1/au:+Marwaha_K/0/1/0/all/0/1">Kunal Marwaha</a></p><p>We study a variant of QMA where quantum proofs have no relative phase (i.e.
non-negative amplitudes, up to a global phase). If only completeness is
modified, this class is equal to QMA [<a href="/abs/1410.2882">arXiv:1410.2882</a>]; but if both
completeness and soundness are modified, the class (named QMA+ by Jeronimo and
Wu) can be much more powerful. We show that QMA+ with some constant gap is
equal to NEXP, yet QMA+ with some *other* constant gap is equal to QMA. One
interpretation is that Merlin's ability to "deceive" originates from relative
phase at least as much as from entanglement, since QMA(2) $\subseteq$ NEXP.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-26T00:30:00Z">Monday, June 26 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.13319'>A SAT Solver and Computer Algebra Attack on the Minimum Kochen-Specker Problem</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Zhengyu Li, Curtis Bright, Vijay Ganesh</p><p>One of the foundational results in quantum mechanics is the Kochen-Specker
(KS) theorem, which states that any theory whose predictions agree with quantum
mechanics must be contextual, i.e., a quantum observation cannot be understood
as revealing a pre-existing value. The theorem hinges on the existence of a
mathematical object called a KS vector system. While many KS vector systems are
known to exist, the problem of finding the minimum KS vector system has
remained stubbornly open for over 55 years, despite significant attempts by
leading scientists and mathematicians. In this paper, we present a new method
based on a combination of a SAT solver and a computer algebra system (CAS) to
address this problem. Our approach improves the lower bound on the minimum
number of vectors in a KS system from 22 to 24, and is about 35,000 times more
efficient compared to the previous best computational methods. The increase in
efficiency derives from the fact we are able to exploit the powerful
combinatorial search-with-learning capabilities of a SAT solver together with
the isomorph-free exhaustive generation methods of a CAS. The quest for the
minimum KS vector system is motivated by myriad applications such as
simplifying experimental tests of contextuality, zero-error classical
communication, dimension witnessing, and the security of certain quantum
cryptographic protocols. To the best of our knowledge, this is the first
application of a novel SAT+CAS system to a problem in the realm of quantum
foundations.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/quant-ph/1/au:+Li_Z/0/1/0/all/0/1">Zhengyu Li</a>, <a href="http://arxiv.org/find/quant-ph/1/au:+Bright_C/0/1/0/all/0/1">Curtis Bright</a>, <a href="http://arxiv.org/find/quant-ph/1/au:+Ganesh_V/0/1/0/all/0/1">Vijay Ganesh</a></p><p>One of the foundational results in quantum mechanics is the Kochen-Specker
(KS) theorem, which states that any theory whose predictions agree with quantum
mechanics must be contextual, i.e., a quantum observation cannot be understood
as revealing a pre-existing value. The theorem hinges on the existence of a
mathematical object called a KS vector system. While many KS vector systems are
known to exist, the problem of finding the minimum KS vector system has
remained stubbornly open for over 55 years, despite significant attempts by
leading scientists and mathematicians. In this paper, we present a new method
based on a combination of a SAT solver and a computer algebra system (CAS) to
address this problem. Our approach improves the lower bound on the minimum
number of vectors in a KS system from 22 to 24, and is about 35,000 times more
efficient compared to the previous best computational methods. The increase in
efficiency derives from the fact we are able to exploit the powerful
combinatorial search-with-learning capabilities of a SAT solver together with
the isomorph-free exhaustive generation methods of a CAS. The quest for the
minimum KS vector system is motivated by myriad applications such as
simplifying experimental tests of contextuality, zero-error classical
communication, dimension witnessing, and the security of certain quantum
cryptographic protocols. To the best of our knowledge, this is the first
application of a novel SAT+CAS system to a problem in the realm of quantum
foundations.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-26T00:30:00Z">Monday, June 26 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.13201'>Decomposition of Geometric Graphs into Star Forests</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CG/recent'>arXiv: Computational Geometry</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: J&#xe1;nos Pach, Morteza Saghafian, Patrick Schnider</p><p>We solve a problem of Dujmovi\'c and Wood (2007) by showing that a complete
convex geometric graph on $n$ vertices cannot be decomposed into fewer than
$n-1$ star-forests, each consisting of noncrossing edges. This bound is clearly
tight. We also discuss similar questions for abstract graphs.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/math/1/au:+Pach_J/0/1/0/all/0/1">J&#xe1;nos Pach</a>, <a href="http://arxiv.org/find/math/1/au:+Saghafian_M/0/1/0/all/0/1">Morteza Saghafian</a>, <a href="http://arxiv.org/find/math/1/au:+Schnider_P/0/1/0/all/0/1">Patrick Schnider</a></p><p>We solve a problem of Dujmovi\'c and Wood (2007) by showing that a complete
convex geometric graph on $n$ vertices cannot be decomposed into fewer than
$n-1$ star-forests, each consisting of noncrossing edges. This bound is clearly
tight. We also discuss similar questions for abstract graphs.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-26T00:30:00Z">Monday, June 26 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.13312'>Effective data reduction algorithm for topological data analysis</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CG/recent'>arXiv: Computational Geometry</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Seonmi Choi, Jinseok Oh, Jeong Rye Park, Seung Yeop Yang, Hongdae Yun</p><p>One of the most interesting tools that have recently entered the data science
toolbox is topological data analysis (TDA). With the explosion of available
data sizes and dimensions, identifying and extracting the underlying structure
of a given dataset is a fundamental challenge in data science, and TDA provides
a methodology for analyzing the shape of a dataset using tools and prospects
from algebraic topology. However, the computational complexity makes it quickly
infeasible to process large datasets, especially those with high dimensions.
Here, we introduce a preprocessing strategy called the Characteristic Lattice
Algorithm (CLA), which allows users to reduce the size of a given dataset as
desired while maintaining geometric and topological features in order to make
the computation of TDA feasible or to shorten its computation time. In
addition, we derive a stability theorem and an upper bound of the barcode
errors for CLA based on the bottleneck distance.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Choi_S/0/1/0/all/0/1">Seonmi Choi</a>, <a href="http://arxiv.org/find/cs/1/au:+Oh_J/0/1/0/all/0/1">Jinseok Oh</a>, <a href="http://arxiv.org/find/cs/1/au:+Park_J/0/1/0/all/0/1">Jeong Rye Park</a>, <a href="http://arxiv.org/find/cs/1/au:+Yang_S/0/1/0/all/0/1">Seung Yeop Yang</a>, <a href="http://arxiv.org/find/cs/1/au:+Yun_H/0/1/0/all/0/1">Hongdae Yun</a></p><p>One of the most interesting tools that have recently entered the data science
toolbox is topological data analysis (TDA). With the explosion of available
data sizes and dimensions, identifying and extracting the underlying structure
of a given dataset is a fundamental challenge in data science, and TDA provides
a methodology for analyzing the shape of a dataset using tools and prospects
from algebraic topology. However, the computational complexity makes it quickly
infeasible to process large datasets, especially those with high dimensions.
Here, we introduce a preprocessing strategy called the Characteristic Lattice
Algorithm (CLA), which allows users to reduce the size of a given dataset as
desired while maintaining geometric and topological features in order to make
the computation of TDA feasible or to shorten its computation time. In
addition, we derive a stability theorem and an upper bound of the barcode
errors for CLA based on the bottleneck distance.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-26T00:30:00Z">Monday, June 26 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.13119'>Adversarial Resilience in Sequential Prediction via Abstention</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Surbhi Goel, Steve Hanneke, Shay Moran, Abhishek Shetty</p><p>We study the problem of sequential prediction in the stochastic setting with
an adversary that is allowed to inject clean-label adversarial (or
out-of-distribution) examples. Algorithms designed to handle purely stochastic
data tend to fail in the presence of such adversarial examples, often leading
to erroneous predictions. This is undesirable in many high-stakes applications
such as medical recommendations, where abstaining from predictions on
adversarial examples is preferable to misclassification. On the other hand,
assuming fully adversarial data leads to very pessimistic bounds that are often
vacuous in practice.
</p>
<p>To capture this motivation, we propose a new model of sequential prediction
that sits between the purely stochastic and fully adversarial settings by
allowing the learner to abstain from making a prediction at no cost on
adversarial examples. Assuming access to the marginal distribution on the
non-adversarial examples, we design a learner whose error scales with the VC
dimension (mirroring the stochastic setting) of the hypothesis class, as
opposed to the Littlestone dimension which characterizes the fully adversarial
setting. Furthermore, we design a learner for VC dimension~1 classes, which
works even in the absence of access to the marginal distribution. Our key
technical contribution is a novel measure for quantifying uncertainty for
learning VC classes, which may be of independent interest.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Goel_S/0/1/0/all/0/1">Surbhi Goel</a>, <a href="http://arxiv.org/find/cs/1/au:+Hanneke_S/0/1/0/all/0/1">Steve Hanneke</a>, <a href="http://arxiv.org/find/cs/1/au:+Moran_S/0/1/0/all/0/1">Shay Moran</a>, <a href="http://arxiv.org/find/cs/1/au:+Shetty_A/0/1/0/all/0/1">Abhishek Shetty</a></p><p>We study the problem of sequential prediction in the stochastic setting with
an adversary that is allowed to inject clean-label adversarial (or
out-of-distribution) examples. Algorithms designed to handle purely stochastic
data tend to fail in the presence of such adversarial examples, often leading
to erroneous predictions. This is undesirable in many high-stakes applications
such as medical recommendations, where abstaining from predictions on
adversarial examples is preferable to misclassification. On the other hand,
assuming fully adversarial data leads to very pessimistic bounds that are often
vacuous in practice.
</p>
<p>To capture this motivation, we propose a new model of sequential prediction
that sits between the purely stochastic and fully adversarial settings by
allowing the learner to abstain from making a prediction at no cost on
adversarial examples. Assuming access to the marginal distribution on the
non-adversarial examples, we design a learner whose error scales with the VC
dimension (mirroring the stochastic setting) of the hypothesis class, as
opposed to the Littlestone dimension which characterizes the fully adversarial
setting. Furthermore, we design a learner for VC dimension~1 classes, which
works even in the absence of access to the marginal distribution. Our key
technical contribution is a novel measure for quantifying uncertainty for
learning VC classes, which may be of independent interest.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-26T00:30:00Z">Monday, June 26 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.13158'>Breaking the cubic barrier in the Solovay-Kitaev algorithm</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Greg Kuperberg (UC Davis)</p><p>We improve the Solovay-Kitaev theorem and algorithm for a general finite,
inverse-closed generating set acting on a qudit. Prior versions of the
algorithm can efficiently find a word of length $O((\log
1/\epsilon)^{3+\delta})$ to approximate an arbitrary target gate to within
$\epsilon$. Using two new ideas, each of which reduces the exponent separately,
our new bound on the world length is $O((\log
1/\epsilon)^{1.44042\ldots+\delta})$. Our result holds more generally for any
finite set that densely generates any connected, semisimple real Lie group,
with an extra length term in the non-compact case to reach group elements far
away from the identity.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/quant-ph/1/au:+Kuperberg_G/0/1/0/all/0/1">Greg Kuperberg</a> (UC Davis)</p><p>We improve the Solovay-Kitaev theorem and algorithm for a general finite,
inverse-closed generating set acting on a qudit. Prior versions of the
algorithm can efficiently find a word of length $O((\log
1/\epsilon)^{3+\delta})$ to approximate an arbitrary target gate to within
$\epsilon$. Using two new ideas, each of which reduces the exponent separately,
our new bound on the world length is $O((\log
1/\epsilon)^{1.44042\ldots+\delta})$. Our result holds more generally for any
finite set that densely generates any connected, semisimple real Lie group,
with an extra length term in the non-compact case to reach group elements far
away from the identity.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-26T00:30:00Z">Monday, June 26 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.13258'>A Fast Maximum $k$-Plex Algorithm Parameterized by the Degeneracy Gap</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Zhengren Wang, Yi Zhou, Chunyu Luo, Mingyu Xiao</p><p>Given a graph, the $k$-plex is a vertex set in which each vertex is not
adjacent to at most $k-1$ other vertices in the set. The maximum $k$-plex
problem, which asks for the largest $k$-plex from a given graph, is an
important but computationally challenging problem in applications like graph
search and community detection. So far, there is a number of empirical
algorithms without sufficient theoretical explanations on the efficiency. We
try to bridge this gap by defining a novel parameter of the input instance,
$g_k(G)$, the gap between the degeneracy bound and the size of maximum $k$-plex
in the given graph, and presenting an exact algorithm parameterized by
$g_k(G)$. In other words, we design an algorithm with running time polynomial
in the size of input graph and exponential in $g_k(G)$ where $k$ is a constant.
Usually, $g_k(G)$ is small and bounded by $O(\log{(|V|)})$ in real-world
graphs, indicating that the algorithm runs in polynomial time. We also carry
out massive experiments and show that the algorithm is competitive with the
state-of-the-art solvers. Additionally, for large $k$ values such as $15$ and
$20$, our algorithm has superior performance over existing algorithms.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Wang_Z/0/1/0/all/0/1">Zhengren Wang</a>, <a href="http://arxiv.org/find/cs/1/au:+Zhou_Y/0/1/0/all/0/1">Yi Zhou</a>, <a href="http://arxiv.org/find/cs/1/au:+Luo_C/0/1/0/all/0/1">Chunyu Luo</a>, <a href="http://arxiv.org/find/cs/1/au:+Xiao_M/0/1/0/all/0/1">Mingyu Xiao</a></p><p>Given a graph, the $k$-plex is a vertex set in which each vertex is not
adjacent to at most $k-1$ other vertices in the set. The maximum $k$-plex
problem, which asks for the largest $k$-plex from a given graph, is an
important but computationally challenging problem in applications like graph
search and community detection. So far, there is a number of empirical
algorithms without sufficient theoretical explanations on the efficiency. We
try to bridge this gap by defining a novel parameter of the input instance,
$g_k(G)$, the gap between the degeneracy bound and the size of maximum $k$-plex
in the given graph, and presenting an exact algorithm parameterized by
$g_k(G)$. In other words, we design an algorithm with running time polynomial
in the size of input graph and exponential in $g_k(G)$ where $k$ is a constant.
Usually, $g_k(G)$ is small and bounded by $O(\log{(|V|)})$ in real-world
graphs, indicating that the algorithm runs in polynomial time. We also carry
out massive experiments and show that the algorithm is competitive with the
state-of-the-art solvers. Additionally, for large $k$ values such as $15$ and
$20$, our algorithm has superior performance over existing algorithms.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-26T00:30:00Z">Monday, June 26 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.13306'>On minimum $t$-claw deletion in split graphs</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Sounaka Mishra</p><p>For $t\geq 3$, $K_{1, t}$ is called $t$-claw. In minimum $t$-claw deletion
problem (\texttt{Min-$t$-Claw-Del}), given a graph $G=(V, E)$, it is required
to find a vertex set $S$ of minimum size such that $G[V\setminus S]$ is
$t$-claw free. In a split graph, the vertex set is partitioned into two sets
such that one forms a clique and the other forms an independent set. Every
$t$-claw in a split graph has a center vertex in the clique partition. This
observation motivates us to consider the minimum one-sided bipartite $t$-claw
deletion problem (\texttt{Min-$t$-OSBCD}). Given a bipartite graph $G=(A \cup
B, E)$, in \texttt{Min-$t$-OSBCD} it is asked to find a vertex set $S$ of
minimum size such that $G[V \setminus S]$ has no $t$-claw with the center
vertex in $A$. A primal-dual algorithm approximates \texttt{Min-$t$-OSBCD}
within a factor of $t$. We prove that it is $\UGC$-hard to approximate with a
factor better than $t$. We also prove it is approximable within a factor of 2
for dense bipartite graphs. By using these results on \texttt{Min-$t$-OSBCD},
we prove that \texttt{Min-$t$-Claw-Del} is $\UGC$-hard to approximate within a
factor better than $t$, for split graphs. We also consider their complementary
maximization problems and prove that they are $\APX$-complete.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Mishra_S/0/1/0/all/0/1">Sounaka Mishra</a></p><p>For $t\geq 3$, $K_{1, t}$ is called $t$-claw. In minimum $t$-claw deletion
problem (\texttt{Min-$t$-Claw-Del}), given a graph $G=(V, E)$, it is required
to find a vertex set $S$ of minimum size such that $G[V\setminus S]$ is
$t$-claw free. In a split graph, the vertex set is partitioned into two sets
such that one forms a clique and the other forms an independent set. Every
$t$-claw in a split graph has a center vertex in the clique partition. This
observation motivates us to consider the minimum one-sided bipartite $t$-claw
deletion problem (\texttt{Min-$t$-OSBCD}). Given a bipartite graph $G=(A \cup
B, E)$, in \texttt{Min-$t$-OSBCD} it is asked to find a vertex set $S$ of
minimum size such that $G[V \setminus S]$ has no $t$-claw with the center
vertex in $A$. A primal-dual algorithm approximates \texttt{Min-$t$-OSBCD}
within a factor of $t$. We prove that it is $\UGC$-hard to approximate with a
factor better than $t$. We also prove it is approximable within a factor of 2
for dense bipartite graphs. By using these results on \texttt{Min-$t$-OSBCD},
we prove that \texttt{Min-$t$-Claw-Del} is $\UGC$-hard to approximate within a
factor better than $t$, for split graphs. We also consider their complementary
maximization problems and prove that they are $\APX$-complete.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-26T00:30:00Z">Monday, June 26 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.13383'>Fair integer programming under dichotomous preferences</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Tom Demeulemeester, Dries Goossens, Ben Hermans, Roel Leus</p><p>One cannot make truly fair decisions using integer linear programs unless one
controls the selection probabilities of the (possibly many) optimal solutions.
For this purpose, we propose a unified framework when binary decision variables
represent agents with dichotomous preferences, who only care about whether they
are selected in the final solution. We develop several general-purpose
algorithms to fairly select optimal solutions, for example, by maximizing the
Nash product or the minimum selection probability, or by using a random
ordering of the agents as a selection criterion (Random Serial Dictatorship).
As such, we embed the black-box procedure of solving an integer linear program
into a framework that is explainable from start to finish. Moreover, we study
the axiomatic properties of the proposed methods by embedding our framework
into the rich literature of cooperative bargaining and probabilistic social
choice. Lastly, we evaluate the proposed methods on a specific application,
namely kidney exchange. We find that while the methods maximizing the Nash
product or the minimum selection probability outperform the other methods on
the evaluated welfare criteria, methods such as Random Serial Dictatorship
perform reasonably well in computation times that are similar to those of
finding a single optimal solution.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Demeulemeester_T/0/1/0/all/0/1">Tom Demeulemeester</a>, <a href="http://arxiv.org/find/cs/1/au:+Goossens_D/0/1/0/all/0/1">Dries Goossens</a>, <a href="http://arxiv.org/find/cs/1/au:+Hermans_B/0/1/0/all/0/1">Ben Hermans</a>, <a href="http://arxiv.org/find/cs/1/au:+Leus_R/0/1/0/all/0/1">Roel Leus</a></p><p>One cannot make truly fair decisions using integer linear programs unless one
controls the selection probabilities of the (possibly many) optimal solutions.
For this purpose, we propose a unified framework when binary decision variables
represent agents with dichotomous preferences, who only care about whether they
are selected in the final solution. We develop several general-purpose
algorithms to fairly select optimal solutions, for example, by maximizing the
Nash product or the minimum selection probability, or by using a random
ordering of the agents as a selection criterion (Random Serial Dictatorship).
As such, we embed the black-box procedure of solving an integer linear program
into a framework that is explainable from start to finish. Moreover, we study
the axiomatic properties of the proposed methods by embedding our framework
into the rich literature of cooperative bargaining and probabilistic social
choice. Lastly, we evaluate the proposed methods on a specific application,
namely kidney exchange. We find that while the methods maximizing the Nash
product or the minimum selection probability outperform the other methods on
the evaluated welfare criteria, methods such as Random Serial Dictatorship
perform reasonably well in computation times that are similar to those of
finding a single optimal solution.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-26T00:30:00Z">Monday, June 26 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.13387'>Improved Competitive Ratios for Online Bipartite Matching on Degree Bounded Graphs</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Yilong Feng, Xiaowei Wu, Shengwei Zhou</p><p>We consider the online bipartite matching problem on $(k,d)$-bounded graphs,
where each online vertex has at most $d$ neighbors, each offline vertex has at
least $k$ neighbors, and $k\geq d\geq 2$. The model of $(k,d)$-bounded graphs
is proposed by Naor and Wajc (EC 2015 and TEAC 2018) to model the online
advertising applications in which offline advertisers are interested in a large
number of ad slots, while each online ad slot is interesting to a small number
of advertisers. They proposed deterministic and randomized algorithms with a
competitive ratio of $1 - (1-1/d)^k$ for the problem, and show that the
competitive ratio is optimal for deterministic algorithms. They also raised the
open questions of whether strictly better competitive ratios can be achieved
using randomized algorithms, for both the adversarial and stochastic arrival
models. In this paper we answer both of their open problems affirmatively. For
the adversarial arrival model, we propose a randomized algorithm with
competitive ratio $1 - (1-1/d)^k + \Omega(d^{-4}\cdot e^{-\frac{k}{d}})$ for
all $k\geq d\geq 2$. We also consider the stochastic model and show that even
better competitive ratios can be achieved. We show that for all $k\geq d\geq
2$, the competitive ratio is always at least $0.8237$. We further consider the
$b$-matching problem when each offline vertex can be matched at most $b$ times,
and provide several competitive ratio lower bounds for the adversarial and
stochastic model.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Feng_Y/0/1/0/all/0/1">Yilong Feng</a>, <a href="http://arxiv.org/find/cs/1/au:+Wu_X/0/1/0/all/0/1">Xiaowei Wu</a>, <a href="http://arxiv.org/find/cs/1/au:+Zhou_S/0/1/0/all/0/1">Shengwei Zhou</a></p><p>We consider the online bipartite matching problem on $(k,d)$-bounded graphs,
where each online vertex has at most $d$ neighbors, each offline vertex has at
least $k$ neighbors, and $k\geq d\geq 2$. The model of $(k,d)$-bounded graphs
is proposed by Naor and Wajc (EC 2015 and TEAC 2018) to model the online
advertising applications in which offline advertisers are interested in a large
number of ad slots, while each online ad slot is interesting to a small number
of advertisers. They proposed deterministic and randomized algorithms with a
competitive ratio of $1 - (1-1/d)^k$ for the problem, and show that the
competitive ratio is optimal for deterministic algorithms. They also raised the
open questions of whether strictly better competitive ratios can be achieved
using randomized algorithms, for both the adversarial and stochastic arrival
models. In this paper we answer both of their open problems affirmatively. For
the adversarial arrival model, we propose a randomized algorithm with
competitive ratio $1 - (1-1/d)^k + \Omega(d^{-4}\cdot e^{-\frac{k}{d}})$ for
all $k\geq d\geq 2$. We also consider the stochastic model and show that even
better competitive ratios can be achieved. We show that for all $k\geq d\geq
2$, the competitive ratio is always at least $0.8237$. We further consider the
$b$-matching problem when each offline vertex can be matched at most $b$ times,
and provide several competitive ratio lower bounds for the adversarial and
stochastic model.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-26T00:30:00Z">Monday, June 26 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    
    <h2 class='tr-new-date'>
      <i class='fa-regular fa-calendar'></i> Sunday, June 25
    </h2>
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='https://eccc.weizmann.ac.il/report/2023/091'>TR23-091 |  Succinct Computational Secret Sharing | 

	Benny Applebaum, 

	Amos Beimel, 

	Yuval Ishai, 

	Eyal Kushilevitz, 

	Tianren Liu, 

	Vinod Vaikuntanathan</a></h3>
        <p class='tr-article-feed'>from <a href='https://eccc.weizmann.ac.il/'>ECCC Papers</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          A secret-sharing scheme enables a dealer to share a secret $s$ among $n$ parties such that only authorized subsets of parties, specified by a monotone access structure $f:\{0,1\}^n\to\{0,1\}$, can reconstruct $s$ from their shares. Other subsets of parties learn nothing about $s$.

The question of minimizing the (largest) share size for a given $f$ has been the subject of a large body of work. However, in most existing constructions for general access structures $f$, the share size is not much smaller than the size of some natural computational representation of $f$, a fact that has often been referred to as the ``representation size barrier&#39;&#39; in secret sharing.

In this work, we initiate a systematic study of succinct computational  secret sharing (SCSS), where the secrecy requirement is computational and the goal is to substantially beat the representation size barrier. We obtain the following main results.

(1) SCSS via Projective PRGs. We introduce the notion of a *projective PRG*, a pseudorandom generator for which any subset of the output bits can be revealed while keeping the other output bits hidden, using a *short* projective seed. We construct projective PRGs with different levels of succinctness under a variety of computational assumptions, and apply them towards constructing SCSS for graph access structures, monotone CNF formulas, and (less succinctly) useful subclasses of monotone circuits and branching programs. Most notably, under the sub-exponential RSA assumption, we obtain a SCSS scheme that, given an arbitrary access structure $f$, represented by a truth table of size $N=2^n$, produces shares of size $\polylog(N)=\poly(n)$ in time $\tilde O(N)$. For comparison, the share size of the best known information-theoretic schemes is $O(N^{0.58})$.

(2) SCSS via One-way Functions. Under the (minimal) assumption that one-way functions exist, we obtain a near-quadratic separation between the total share size of computational and information-theoretic secret sharing. This is the strongest separation one can hope for, given the state of the art in secret sharing lower bounds.
We also construct SCSS schemes from one-way functions for useful classes of access structures, including forbidden graphs and monotone DNF formulas.  This leads to constructions of fully-decomposable conditional disclosure of secrets (also known as privacy-free garbled circuits) for general functions, represented by a truth table of size $N=2^n$, with share size $\polylog(N)$ and computation time $\tilde O(N)$, assuming sub-exponentially secure one-way functions.
        
        </div>

        <div class='tr-article-summary'>
        
          
          A secret-sharing scheme enables a dealer to share a secret $s$ among $n$ parties such that only authorized subsets of parties, specified by a monotone access structure $f:\{0,1\}^n\to\{0,1\}$, can reconstruct $s$ from their shares. Other subsets of parties learn nothing about $s$.

The question of minimizing the (largest) share size for a given $f$ has been the subject of a large body of work. However, in most existing constructions for general access structures $f$, the share size is not much smaller than the size of some natural computational representation of $f$, a fact that has often been referred to as the ``representation size barrier&#39;&#39; in secret sharing.

In this work, we initiate a systematic study of succinct computational  secret sharing (SCSS), where the secrecy requirement is computational and the goal is to substantially beat the representation size barrier. We obtain the following main results.

(1) SCSS via Projective PRGs. We introduce the notion of a *projective PRG*, a pseudorandom generator for which any subset of the output bits can be revealed while keeping the other output bits hidden, using a *short* projective seed. We construct projective PRGs with different levels of succinctness under a variety of computational assumptions, and apply them towards constructing SCSS for graph access structures, monotone CNF formulas, and (less succinctly) useful subclasses of monotone circuits and branching programs. Most notably, under the sub-exponential RSA assumption, we obtain a SCSS scheme that, given an arbitrary access structure $f$, represented by a truth table of size $N=2^n$, produces shares of size $\polylog(N)=\poly(n)$ in time $\tilde O(N)$. For comparison, the share size of the best known information-theoretic schemes is $O(N^{0.58})$.

(2) SCSS via One-way Functions. Under the (minimal) assumption that one-way functions exist, we obtain a near-quadratic separation between the total share size of computational and information-theoretic secret sharing. This is the strongest separation one can hope for, given the state of the art in secret sharing lower bounds.
We also construct SCSS schemes from one-way functions for useful classes of access structures, including forbidden graphs and monotone DNF formulas.  This leads to constructions of fully-decomposable conditional disclosure of secrets (also known as privacy-free garbled circuits) for general functions, represented by a truth table of size $N=2^n$, with share size $\polylog(N)$ and computation time $\tilde O(N)$, assuming sub-exponentially secure one-way functions.
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-25T01:21:48Z">Sunday, June 25 2023, 01:21</time>
        </div>
      </div>
    </details>
  
    
    <h2 class='tr-new-date'>
      <i class='fa-regular fa-calendar'></i> Saturday, June 24
    </h2>
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='https://rjlipton.wpcomstaging.com/2023/06/24/a-hidden-heroine/'>A Hidden Heroine</a></h3>
        <p class='tr-article-feed'>from <a href='https://rjlipton.wpcomstaging.com'>Richard Lipton</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          William Friedman was famous as one who broke codes during both world wars. I knew about him from articles such as this. But wait His wife Elizebeth Smith Friedman is the star of a PBS TV special. Together they were the first great cryptographers of modern times. They quickly shifted gear from working on the [&#8230;]
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p>William Friedman was famous as one who broke codes during both world wars. I knew about him from articles such as <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5419462/pdf/1.pdf">this</a>. </p>
<p>
<a href="https://rjlipton.wpcomstaging.com/2023/06/24/a-hidden-heroine/wf/" rel="attachment wp-att-21808"><img data-attachment-id="21808" data-permalink="https://rjlipton.wpcomstaging.com/2023/06/24/a-hidden-heroine/wf/" data-orig-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/wf.jpeg?fit=299%2C168&amp;ssl=1" data-orig-size="299,168" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="wf" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/wf.jpeg?fit=299%2C168&amp;ssl=1" data-large-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/wf.jpeg?fit=299%2C168&amp;ssl=1" decoding="async" loading="lazy" src="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/wf.jpeg?resize=299%2C168&#038;ssl=1" alt="" width="299" height="168" class="aligncenter size-full wp-image-21808" data-recalc-dims="1" /></a></p>
<p>
But wait <img decoding="async" src="https://s0.wp.com/latex.php?latex=%7B%5Cdots%7D&#038;bg=ffffff&#038;fg=000000&#038;s=0&#038;c=20201002" alt="{&#92;dots}" class="latex" /> His wife Elizebeth Smith Friedman is the star of a PBS TV <a href="https://www.imdb.com/title/tt12599258/">special</a>. Together they were the first great cryptographers of modern times. They quickly shifted gear from working on the hypothesis of embedded cryptograms in William Shakespeare&#8217;s plays in 1915&#8211;16 to helping the US WW I effort from 1917 on. </p>
<p>
<a href="https://rjlipton.wpcomstaging.com/2023/06/24/a-hidden-heroine/ef/" rel="attachment wp-att-21809"><img data-attachment-id="21809" data-permalink="https://rjlipton.wpcomstaging.com/2023/06/24/a-hidden-heroine/ef/" data-orig-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/ef.jpeg?fit=271%2C186&amp;ssl=1" data-orig-size="271,186" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="ef" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/ef.jpeg?fit=271%2C186&amp;ssl=1" data-large-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/ef.jpeg?fit=271%2C186&amp;ssl=1" decoding="async" loading="lazy" src="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/ef.jpeg?resize=271%2C186&#038;ssl=1" alt="" width="271" height="186" class="aligncenter size-full wp-image-21809" data-recalc-dims="1" /></a></p>
<p>
What is so interesting is that I was unaware of her great contributions. I thought I knew the history of code breaking. But I was totally wrong. Elizebeth Friedman&#8217;s work on decrypting coded radio messages helped tip the balances of WWI and WWII. She saved thousands of lives, but her work was hidden by the US government for 62 years. Her superiors&#8212;all men&#8212;took credit for her work. She initially got <em>none</em>. Nothing at all. </p>
<p>
This is&#8212;at least it was&#8212;one of the terrible injustices in the history of code breaking. </p>
<p>
<span id="more-21806"></span></p>
<p><H2> Century-Later Recognition </H2></p>
<p><p>
Her role was hidden until documents concerning it were declassified in 2008. She had taken an oath during her WW II work with the US Navy to keep that secret until her death, which came in 1980 with no fanfare. </p>
<p>
Still, it took a decade more for true public awareness of her importance. Three recent biographies are: </p>
<ul>
<li>
Gregg Stuart Smith, <em>A Life in Code: Pioneer Cryptanalyst Elizebeth Smith Friedman</em>, <a href="https://www.amazon.com/stores/G.-Stuart-Smith/author/B0077D2M0O?ref=ap_rdr&#038;store_ref=ap_rdr&#038;isDramIntegrated=true&#038;shoppingPortalEnabled=true">2017</a>. </p>
<li>
Jason Fagone, <em>The Woman Who Smashed Codes: A True Story of Love, Spies, and the Unlikely Heroine Who Outwitted America&#8217;s Enemies</em>, <a href="https://www.amazon.com/Woman-Who-Smashed-Codes-Outwitted/dp/0062430513/ref=pd_lpo_sccl_2/146-5971751-8425411">2018</a>. </p>
<li>
Amy Butler Greenfield, <em>The Woman All Spies Fear: Code Breaker Elizebeth Smith Friedman and Her Hidden Life</em>, <a href="https://www.goodreads.com/en/book/show/56364344-the-woman-all-spies-fear">2021</a>.
</ul>
<p>
Although the last one is written for a young-adult audience, with large print and short chapters, it still has wonderful detail on her life and work. </p>
<p>
<a href="https://rjlipton.wpcomstaging.com/2023/06/24/a-hidden-heroine/greenfieldbook/" rel="attachment wp-att-21811"><img data-attachment-id="21811" data-permalink="https://rjlipton.wpcomstaging.com/2023/06/24/a-hidden-heroine/greenfieldbook/" data-orig-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/GreenfieldBook.jpg?fit=600%2C894&amp;ssl=1" data-orig-size="600,894" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="GreenfieldBook" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/GreenfieldBook.jpg?fit=201%2C300&amp;ssl=1" data-large-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/GreenfieldBook.jpg?fit=600%2C894&amp;ssl=1" decoding="async" loading="lazy" src="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/GreenfieldBook.jpg?resize=200%2C300&#038;ssl=1" alt="" width="200" height="300" class="aligncenter wp-image-21811" srcset="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/GreenfieldBook.jpg?resize=201%2C300&amp;ssl=1 201w, https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/GreenfieldBook.jpg?zoom=2&amp;resize=200%2C300&amp;ssl=1 400w, https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/GreenfieldBook.jpg?zoom=3&amp;resize=200%2C300&amp;ssl=1 600w" sizes="(max-width: 200px) 100vw, 200px" data-recalc-dims="1" /></a></p>
<p>
In the meantime, the NSA&#8217;s own tribute, dated <a href="https://media.defense.gov/2021/Jul/13/2002761955/-1/-1/0/FRIEDMAN-LEGACY-TRANSCRIPT.PDF">2006</a>, gives details on Elizebeth but is headlined only for William. Most of its 226 pages reprints six lectures by William that were originally circulated within the agency in 1963. It reprints a 1980 memorial to her at the end.</p>
<p>
<p><H2> How She Started </H2></p>
<p><p>
Her origin story is amazing as well. She was one of only two in her Midwest farming family of nine to attend college and obtained a degree in English after transferring to a school closer to home. Her first job opportunity, a brief stint as substitute principal at a public high school in Indiana, did not lead to other teaching positions, so she moved back with her family. She journeyed to Chicago to look for work, using the <a href="https://en.wikipedia.org/wiki/Newberry_Library">Newberry Library</a> as a hub.</p>
<p>
In one of her last days there, a librarian tipped her that a visiting millionaire, George Fabyan, was looking for help on a project involving Shakespeare. She connected with him and the scholarly director of the project, Elizabeth Gallup, and became employed at Fabyan&#8217;s private Riverbank Research Laboratory.</p>
<p>
<a href="https://rjlipton.wpcomstaging.com/2023/06/24/a-hidden-heroine/gf/" rel="attachment wp-att-21812"><img data-attachment-id="21812" data-permalink="https://rjlipton.wpcomstaging.com/2023/06/24/a-hidden-heroine/gf/" data-orig-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/gf.jpeg?fit=203%2C249&amp;ssl=1" data-orig-size="203,249" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="gf" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/gf.jpeg?fit=203%2C249&amp;ssl=1" data-large-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/gf.jpeg?fit=203%2C249&amp;ssl=1" decoding="async" loading="lazy" src="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/gf.jpeg?resize=203%2C249&#038;ssl=1" alt="" width="203" height="249" class="aligncenter size-full wp-image-21812" data-recalc-dims="1" /></a></p>
<p>
Riverbank had standard scientific projects as well. William Friedman was employed out of Cornell to work on plant genetics. One of several factors drawing him to the Shakespeare project was that his skill photographing plants was handy for images of original manuscripts kept in England. A second was developing techniques for statistical analysis. A third was Elizebeth. </p>
<p>
By the time they married in 1917, they had worked out that the statistical randomness of defective type metal re-used by Elizabethan printers and bias in how the alleged codes in Shakespeare were identified effaced the claimed footprints of Francis Bacon&#8217;s <a href="https://en.wikipedia.org/wiki/Bacon's_cipher">two-face cipher</a>. Before they could even ascertain how to publish their eight draft papers of study, however, America&#8217;s entry into World War I pressed them into other applications. Fabyan himself volunteered the services of his lab for top-secret work. </p>
<p>
Their work on Shakespeare <a href="https://www.amazon.com/Shakespearean-Ciphers-Examined-cryptographic-Shakespeare/dp/0521141397">was published</a> in 1957. It wasn&#8217;t top secret and it bore both their names, as did its 1955 <a href="https://books.google.com/books/about/The_Cryptologist_Looks_at_Shakespeare.html?id=BBdiuAAACAAJ&#038;hl=en&#038;output=html_text">manuscript</a> which won the Folger Library Shakespeare Prize. </p>
<p>
<p><H2> Open Problems </H2></p>
<p><p>
In 1999, the year of its creation, she was inducted to the NSA Hall of Honor&#8212;see <a href="https://www.pbs.org/wgbh/americanexperience/features/codebreaker-elizebeth-friedman-fought-nazi-spies/">this</a>.</p>
<p>
<a href="https://rjlipton.wpcomstaging.com/2023/06/24/a-hidden-heroine/code-2/" rel="attachment wp-att-21813"><img data-attachment-id="21813" data-permalink="https://rjlipton.wpcomstaging.com/2023/06/24/a-hidden-heroine/code-2/" data-orig-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/code.jpeg?fit=320%2C208&amp;ssl=1" data-orig-size="320,208" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="code" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/code.jpeg?fit=300%2C195&amp;ssl=1" data-large-file="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/code.jpeg?fit=320%2C208&amp;ssl=1" decoding="async" loading="lazy" src="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/code.jpeg?resize=320%2C208&#038;ssl=1" alt="" width="320" height="208" class="aligncenter size-full wp-image-21813" srcset="https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/code.jpeg?w=320&amp;ssl=1 320w, https://i0.wp.com/rjlipton.wpcomstaging.com/wp-content/uploads/2023/06/code.jpeg?resize=300%2C195&amp;ssl=1 300w" sizes="(max-width: 320px) 100vw, 320px" data-recalc-dims="1" /></a></p>
<p>
I hope that in the future credit will be given equally to women as well as to men. This of course presupposes that the women had the opportunity to begin with. Let&#8217;s hope so.</p>
<p>
<p class="authors">By RJLipton+KWRegan</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-24T21:53:47Z">Saturday, June 24 2023, 21:53</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='https://11011110.github.io/blog/2023/06/24/geometric-flip-width.html'>Geometric flip-width revisited</a></h3>
        <p class='tr-article-feed'>from <a href='https://11011110.github.io/blog/'>David Eppstein</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          I recently posted here about the flip-width of geometric graphs, and to readers of that post, my new preprint “Geometric Graphs with Unbounded Flip-Width” (arXiv:2306.12611, with Rose McCarty, to appear in CCCG 2023) will look very familiar. It even has the same title! However, the process of turning it into a paper led to some improvements. Let me summarize them briefly here.
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p>I recently posted here about the <a href="/blog/2023/02/20/geometric-graphs-unbounded.html">flip-width of geometric graphs</a>, and to readers of that post, my new preprint “Geometric Graphs with Unbounded Flip-Width” (<a href="http://arxiv.org/abs/2306.12611">arXiv:2306.12611</a>, with Rose McCarty, to appear in CCCG 2023) will look very familiar. It even has the same title! However, the process of turning it into a paper led to some improvements. Let me summarize them briefly here.</p>

<p>First, a reminder of the main concept, flip-width. This is defined using a pursuit–evasion game in which a robber tries to escape cops by following paths in a graph. At each turn, the cops have made a fixed number of “flips” to the graph. Each flip applies to a subset of vertices (possibly overlapping with other flips), removes edges from its adjacent vertices, and adds edges connecting its non-adjacent vertices. A turn consists of three steps: the cops announce what they will flip next, the robber moves along a path of length at most \(s\), and then the cops undo their current flips and perform the new flips that they announced. The goal of the cops is to leave the robber stuck on an isolated vertex, while the goal of the robber is to escape forever. If a class of graphs has a function \(f(s)\) such that \(f(s)\) cops can win against a robber of speed \(s\), then it has bounded flip-width. If there is a speed \(s\) for which arbitrarily many cops may be needed to catch a speed-\(s\) robber, then the class has unbounded flip-width.</p>

<p>Beyond a more careful attention to detail and rigor, new developments are:</p>

<ul>
  <li>
    <p>Three-dimensional Delaunay triangulations have unbounded flip-width. This uses a construction from another recent blog post on <a href="/blog/2023/02/25/isohedral-delaunay-complexes.html">isohedral Delaunay complexes</a>.</p>
  </li>
  <li>
    <p><a href="https://en.wikipedia.org/wiki/Beta_skeleton">Beta-skeletons</a> have unbounded flip-width. There are actually two different kinds of beta-skeleton but the interesting case is for parameter values \(\beta&lt;1\), for which the two definitions agree.</p>
  </li>
  <li>
    <p>Another type of geometric graph for which we can prove unbounded flip-width, not mentioned in the previous post, is the rectangle of influence graphs. These connect pairs of points in their plane when their axis-aligned bounding box is empty of other points. We find a recursive construction for rectangle of influence graphs containing hypercube induced subgraphs of arbitrarily large dimension, which in turn have unbounded flip-width. As with the beta-skeletons, definitions for rectangle of influence graphs disagree (about what to do with points on the boundary of the bounding box) but our hypercube construction doesn’t need that ambiguity.</p>

    <p style="text-align:center"><img src="/blog/assets/2023/empty-rectangle.svg" alt="Hypercube in a rectangle of influence graph" /></p>
  </li>
  <li>
    <p>For most of the families of geometric graphs that we study, the robber can escape by stepping across only one edge per turn (\(s=1\)). This is a big improvement over the \(s=4\) from the blog post, and a much more natural speed limitation. The exception is for three-dimensional Delaunay triangulations; for these \(s=2\) works but we don’t know about \(s=1\). An \(s=2\) escape strategy for all of these graphs is very simple: move to a “lane” (one of two special types of vertex in the “interchange” graphs constructed in the previous blog post) that has two-edge paths to many other lanes. The \(s=1\) strategy is different, and for some of the geometric graphs is based on hypercube subgraphs rather than interchanges.</p>
  </li>
  <li>
    <p>An appendix extends the results on all of these graph classes (even 3d Delaunay triangulations) from unbounded flip-width to monadic independence, meaning that it is possible to use <em>transductions</em>, a certain kind of translation system defined using logical formulas, to get arbitrary graphs from graphs in these classes. The main ideas (from Szymon Toruńczyk) are to use Ramsey theory to simplify the interchange subgraphs into two cases, “sparse” and “dense”, to use the structure of these graphs to find a logical translation from the dense case to the sparse case, and to find a subdivision of any given graph as an induced subgraph of a sparse interchange.</p>
  </li>
</ul>

<p>(<a href="https://mathstodon.xyz/@11011110/110602049050780927">Discuss on Mastodon</a>)</p><p class="authors">By David Eppstein</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-24T18:07:00Z">Saturday, June 24 2023, 18:07</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='https://blog.computationalcomplexity.org/2023/06/can-you-put-n-pennies-on-n-x-n.html'>Can you put n pennies on an n x n chessboard so that all of the distances are distinct/how to look that up?</a></h3>
        <p class='tr-article-feed'>from <a href='http://blog.computationalcomplexity.org/'>Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>&nbsp;In Jan 2023 I went to the Joint Math Meeting of the AMS and the MAA and took notes on things to look up later. In one of the talks they discussed a problem and indicated that the answer was known, but did not give a reference or a proof. I emailed the authors and got no response. I tried to search the web but could not find it. SO I use this blog post to see if someone either knows the reference or can solve it outright, and either leave the answer in the comments, point to a paper that has the answer in the comments, or email me personally.&nbsp;</p><p>--------------------------------------------------------------------</p><p>A chessboard has squares that are 1 by 1.&nbsp;</p><p>Pennies have diameter 1.</p><p>QUESTION:&nbsp;</p><p>For which n is there a way to place n pennies on squares of the n x n chessboard so that all of the distances between centers of the pennies are DIFFERENT?</p><p>-----------------------------------------------------------</p><p>I have figured out that you CAN do this for n=3,4,5. I THINK the talk said&nbsp; it cannot be done for n=6. If&nbsp; you know or find a proof or disproof then please tell me. I am looking for human-readable proofs, not computer proofs.&nbsp; Similar for higher n.</p><p>I have a writeup of the n=3,4,5 cases&nbsp;here&nbsp;(ADDED LATER- I will edit this later in light of the very interesting comments made on this blog entry.)&nbsp;</p><p>----------------------------------------------------------------------</p><p>With technology and search engines it SHOULD be easier to find out answers to questions then it was in a prior era. And I think it is. But there are times when you are still better off asking&nbsp; someone, or in my case blog about it, to find the answer. Here is hoping it works!</p><p>ADDED LATER: Within 30 minutes of posting this one of my readers wrote a program and found tha tyou CAN do it for n=6 and gives the answer. Another commenter pointed to a website with the related quetion of putting as many pawns as you can on an 8x8 board.</p><p>ADDED LATER: There are now comments on the blog pointing to the FULL SOLUTION to the problem, which one can find&nbsp;here. In summary:&nbsp;</p><p>for n=3,...,7&nbsp; there IS a way to put n pennies on a chessboard such that all distances are distinct.</p><p>for n=8,...,14 a computer search shows that there is no such way.</p><p>for n=15 there is an INTERESTING PROOF that there is no such way (good thing - the computer program had not halted yet. I do not know if it every did.)&nbsp;</p><p>for n\ge 16 there is a NICE proof that there IS such way.&nbsp;</p><p>I am ECSTATIC!- I wanted to know the answer and now I do and its easy to understand!</p><p><br></p><p>By gasarch</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p>&nbsp;In Jan 2023 I went to the Joint Math Meeting of the AMS and the MAA and took notes on things to look up later. In one of the talks they discussed a problem and indicated that the answer was known, but did not give a reference or a proof. I emailed the authors and got no response. I tried to search the web but could not find it. SO I use this blog post to see if someone either knows the reference or can solve it outright, and either leave the answer in the comments, point to a paper that has the answer in the comments, or email me personally.&nbsp;</p><p>--------------------------------------------------------------------</p><p>A chessboard has squares that are 1 by 1.&nbsp;</p><p>Pennies have diameter 1.</p><p>QUESTION:&nbsp;</p><p>For which n is there a way to place n pennies on squares of the n x n chessboard so that all of the distances between centers of the pennies are DIFFERENT?</p><p>-----------------------------------------------------------</p><p>I have figured out that you CAN do this for n=3,4,5. I THINK the talk said&nbsp; it cannot be done for n=6. If&nbsp; you know or find a proof or disproof then please tell me. I am looking for human-readable proofs, not computer proofs.&nbsp; Similar for higher n.</p><p>I have a writeup of the n=3,4,5 cases&nbsp;<a href="https://www.cs.umd.edu/~gasarch/BLOGPAPERS/pennychess.pdf">here</a>&nbsp;(ADDED LATER- I will edit this later in light of the very interesting comments made on this blog entry.)&nbsp;</p><p>----------------------------------------------------------------------</p><p>With technology and search engines it SHOULD be easier to find out answers to questions then it was in a prior era. And I think it is. But there are times when you are still better off asking&nbsp; someone, or in my case blog about it, to find the answer. Here is hoping it works!</p><p>ADDED LATER: Within 30 minutes of posting this one of my readers wrote a program and found tha tyou CAN do it for n=6 and gives the answer. Another commenter pointed to a website with the related quetion of putting as many pawns as you can on an 8x8 board.</p><p>ADDED LATER: There are now comments on the blog pointing to the FULL SOLUTION to the problem, which one can find&nbsp;<a href="https://oscarcunningham.com/670/unique-distancing-problem/">here</a>. In summary:&nbsp;</p><p>for n=3,...,7&nbsp; there IS a way to put n pennies on a chessboard such that all distances are distinct.</p><p>for n=8,...,14 a computer search shows that there is no such way.</p><p>for n=15 there is an INTERESTING PROOF that there is no such way (good thing - the computer program had not halted yet. I do not know if it every did.)&nbsp;</p><p>for n\ge 16 there is a NICE proof that there IS such way.&nbsp;</p><p>I am ECSTATIC!- I wanted to know the answer and now I do and its easy to understand!</p><p><br /></p><p class="authors">By gasarch</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-24T14:35:00Z">Saturday, June 24 2023, 14:35</time>
        </div>
      </div>
    </details>
  
    
    <h2 class='tr-new-date'>
      <i class='fa-regular fa-calendar'></i> Friday, June 23
    </h2>
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.12440'>Sleptsov Nets are Turing-complete</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Bernard Berthomieu, Dmitry A. Zaitsev</p><p>The present paper proves that a Sleptsov net (SN) is Turing-complete, that
considerably improves, with a brief construct, the previous result that a
strong SN is Turing-complete. Remind that, unlike Petri nets, an SN always
fires enabled transitions at their maximal firing multiplicity, as a single
step, leaving for a nondeterministic choice of which fireable transitions to
fire. A strong SN restricts nondeterministic choice to firing only the
transitions having the highest firing multiplicity.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Berthomieu_B/0/1/0/all/0/1">Bernard Berthomieu</a>, <a href="http://arxiv.org/find/cs/1/au:+Zaitsev_D/0/1/0/all/0/1">Dmitry A. Zaitsev</a></p><p>The present paper proves that a Sleptsov net (SN) is Turing-complete, that
considerably improves, with a brief construct, the previous result that a
strong SN is Turing-complete. Remind that, unlike Petri nets, an SN always
fires enabled transitions at their maximal firing multiplicity, as a single
step, leaving for a nondeterministic choice of which fireable transitions to
fire. A strong SN restricts nondeterministic choice to firing only the
transitions having the highest firing multiplicity.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-23T00:30:00Z">Friday, June 23 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.13073'>Unitary Complexity and the Uhlmann Transformation Problem</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: John Bostanci, Yuval Efron, Tony Metger, Alexander Poremba, Luowen Qian, Henry Yuen</p><p>State transformation problems such as compressing quantum information or
breaking quantum commitments are fundamental quantum tasks. However, their
computational difficulty cannot easily be characterized using traditional
complexity theory, which focuses on tasks with classical inputs and outputs.
</p>
<p>To study the complexity of such state transformation tasks, we introduce a
framework for unitary synthesis problems, including notions of reductions and
unitary complexity classes. We use this framework to study the complexity of
transforming one entangled state into another via local operations. We
formalize this as the Uhlmann Transformation Problem, an algorithmic version of
Uhlmann's theorem. Then, we prove structural results relating the complexity of
the Uhlmann Transformation Problem, polynomial space quantum computation, and
zero knowledge protocols.
</p>
<p>The Uhlmann Transformation Problem allows us to characterize the complexity
of a variety of tasks in quantum information processing, including decoding
noisy quantum channels, breaking falsifiable quantum cryptographic assumptions,
implementing optimal prover strategies in quantum interactive proofs, and
decoding the Hawking radiation of black holes. Our framework for unitary
complexity thus provides new avenues for studying the computational complexity
of many natural quantum information processing tasks.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/quant-ph/1/au:+Bostanci_J/0/1/0/all/0/1">John Bostanci</a>, <a href="http://arxiv.org/find/quant-ph/1/au:+Efron_Y/0/1/0/all/0/1">Yuval Efron</a>, <a href="http://arxiv.org/find/quant-ph/1/au:+Metger_T/0/1/0/all/0/1">Tony Metger</a>, <a href="http://arxiv.org/find/quant-ph/1/au:+Poremba_A/0/1/0/all/0/1">Alexander Poremba</a>, <a href="http://arxiv.org/find/quant-ph/1/au:+Qian_L/0/1/0/all/0/1">Luowen Qian</a>, <a href="http://arxiv.org/find/quant-ph/1/au:+Yuen_H/0/1/0/all/0/1">Henry Yuen</a></p><p>State transformation problems such as compressing quantum information or
breaking quantum commitments are fundamental quantum tasks. However, their
computational difficulty cannot easily be characterized using traditional
complexity theory, which focuses on tasks with classical inputs and outputs.
</p>
<p>To study the complexity of such state transformation tasks, we introduce a
framework for unitary synthesis problems, including notions of reductions and
unitary complexity classes. We use this framework to study the complexity of
transforming one entangled state into another via local operations. We
formalize this as the Uhlmann Transformation Problem, an algorithmic version of
Uhlmann's theorem. Then, we prove structural results relating the complexity of
the Uhlmann Transformation Problem, polynomial space quantum computation, and
zero knowledge protocols.
</p>
<p>The Uhlmann Transformation Problem allows us to characterize the complexity
of a variety of tasks in quantum information processing, including decoding
noisy quantum channels, breaking falsifiable quantum cryptographic assumptions,
implementing optimal prover strategies in quantum interactive proofs, and
decoding the Hawking radiation of black holes. Our framework for unitary
complexity thus provides new avenues for studying the computational complexity
of many natural quantum information processing tasks.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-23T00:30:00Z">Friday, June 23 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.12611'>Geometric Graphs with Unbounded Flip-Width</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.CG/recent'>arXiv: Computational Geometry</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: David Eppstein, Rose McCarty</p><p>We consider the flip-width of geometric graphs, a notion of graph width
recently introduced by Toru\'nczyk. We prove that many different types of
geometric graphs have unbounded flip-width. These include interval graphs,
permutation graphs, circle graphs, intersection graphs of axis-aligned line
segments or axis-aligned unit squares, unit distance graphs, unit disk graphs,
visibility graphs of simple polygons, $\beta$-skeletons, 4-polytopes, rectangle
of influence graphs, and 3d Delaunay triangulations.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Eppstein_D/0/1/0/all/0/1">David Eppstein</a>, <a href="http://arxiv.org/find/cs/1/au:+McCarty_R/0/1/0/all/0/1">Rose McCarty</a></p><p>We consider the flip-width of geometric graphs, a notion of graph width
recently introduced by Toru\'nczyk. We prove that many different types of
geometric graphs have unbounded flip-width. These include interval graphs,
permutation graphs, circle graphs, intersection graphs of axis-aligned line
segments or axis-aligned unit squares, unit distance graphs, unit disk graphs,
visibility graphs of simple polygons, $\beta$-skeletons, 4-polytopes, rectangle
of influence graphs, and 3d Delaunay triangulations.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-23T00:30:00Z">Friday, June 23 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.12508'>Polynomial Logical Zonotopes: A Set Representation for Reachability Analysis of Logical Systems</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Amr Alanwar, Frank J. Jiang, Karl H. Johansson</p><p>In this paper, we introduce a set representation called polynomial logical
zonotopes for performing exact and computationally efficient reachability
analysis on logical systems. Polynomial logical zonotopes are a generalization
of logical zonotopes, which are able to represent up to 2^n binary vectors
using only n generators. Due to their construction, logical zonotopes are only
able to support exact computations of some logical operations (XOR, NOT, XNOR),
while other operations (AND, NAND, OR, NOR) result in over-approximations. In
order to perform all fundamental logical operations exactly, we formulate a
generalization of logical zonotopes that is constructed by additional dependent
generators and exponent matrices. We prove that through this polynomial-like
construction, we are able to perform all of the fundamental logical operations
(XOR, NOT, XNOR, AND, NAND, OR, NOR) exactly. While we are able to perform all
of the logical operations exactly, this comes with a slight increase in
computational complexity compared to logical zonotopes. We show that we can use
polynomial logical zonotopes to perform exact reachability analysis while
retaining a low computational complexity. To illustrate and showcase the
computational benefits of polynomial logical zonotopes, we present the results
of performing reachability analysis on two use cases: (1) safety verification
of an intersection crossing protocol, (2) and reachability analysis on a
high-dimensional Boolean function. Moreover, to highlight the extensibility of
logical zonotopes, we include an additional use case where we perform a
computationally tractable exhaustive search for the key of a linear-feedback
shift register.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Alanwar_A/0/1/0/all/0/1">Amr Alanwar</a>, <a href="http://arxiv.org/find/cs/1/au:+Jiang_F/0/1/0/all/0/1">Frank J. Jiang</a>, <a href="http://arxiv.org/find/cs/1/au:+Johansson_K/0/1/0/all/0/1">Karl H. Johansson</a></p><p>In this paper, we introduce a set representation called polynomial logical
zonotopes for performing exact and computationally efficient reachability
analysis on logical systems. Polynomial logical zonotopes are a generalization
of logical zonotopes, which are able to represent up to 2^n binary vectors
using only n generators. Due to their construction, logical zonotopes are only
able to support exact computations of some logical operations (XOR, NOT, XNOR),
while other operations (AND, NAND, OR, NOR) result in over-approximations. In
order to perform all fundamental logical operations exactly, we formulate a
generalization of logical zonotopes that is constructed by additional dependent
generators and exponent matrices. We prove that through this polynomial-like
construction, we are able to perform all of the fundamental logical operations
(XOR, NOT, XNOR, AND, NAND, OR, NOR) exactly. While we are able to perform all
of the logical operations exactly, this comes with a slight increase in
computational complexity compared to logical zonotopes. We show that we can use
polynomial logical zonotopes to perform exact reachability analysis while
retaining a low computational complexity. To illustrate and showcase the
computational benefits of polynomial logical zonotopes, we present the results
of performing reachability analysis on two use cases: (1) safety verification
of an intersection crossing protocol, (2) and reachability analysis on a
high-dimensional Boolean function. Moreover, to highlight the extensibility of
logical zonotopes, we include an additional use case where we perform a
computationally tractable exhaustive search for the key of a linear-feedback
shift register.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-23T00:30:00Z">Friday, June 23 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.12655'>Preprocessing Complexity for Some Graph Problems Parameterized by Structural Parameters</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Manuel Lafond, Weidong Luo</p><p>Structural graph parameters play an important role in parameterized
complexity, including in kernelization. Notably, vertex cover, neighborhood
diversity, twin-cover, and modular-width have been studied extensively in the
last few years. However, there are many fundamental problems whose
preprocessing complexity is not fully understood under these parameters.
Indeed, the existence of polynomial kernels or polynomial Turing kernels for
famous problems such as Clique, Chromatic Number, and Steiner Tree has only
been established for a subset of structural parameters. In this work, we use
several techniques to obtain a complete preprocessing complexity landscape for
over a dozen of fundamental algorithmic problems.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Lafond_M/0/1/0/all/0/1">Manuel Lafond</a>, <a href="http://arxiv.org/find/cs/1/au:+Luo_W/0/1/0/all/0/1">Weidong Luo</a></p><p>Structural graph parameters play an important role in parameterized
complexity, including in kernelization. Notably, vertex cover, neighborhood
diversity, twin-cover, and modular-width have been studied extensively in the
last few years. However, there are many fundamental problems whose
preprocessing complexity is not fully understood under these parameters.
Indeed, the existence of polynomial kernels or polynomial Turing kernels for
famous problems such as Clique, Chromatic Number, and Steiner Tree has only
been established for a subset of structural parameters. In this work, we use
several techniques to obtain a complete preprocessing complexity landscape for
over a dozen of fundamental algorithmic problems.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-23T00:30:00Z">Friday, June 23 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.12534'>Memory-Query Tradeoffs for Randomized Convex Optimization</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Xi Chen, Binghui Peng</p><p>We show that any randomized first-order algorithm which minimizes a
$d$-dimensional, $1$-Lipschitz convex function over the unit ball must either
use $\Omega(d^{2-\delta})$ bits of memory or make $\Omega(d^{1+\delta/6-o(1)})$
queries, for any constant $\delta\in (0,1)$ and when the precision $\epsilon$
is quasipolynomially small in $d$. Our result implies that cutting plane
methods, which use $\tilde{O}(d^2)$ bits of memory and $\tilde{O}(d)$ queries,
are Pareto-optimal among randomized first-order algorithms, and quadratic
memory is required to achieve optimal query complexity for convex optimization.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Chen_X/0/1/0/all/0/1">Xi Chen</a>, <a href="http://arxiv.org/find/cs/1/au:+Peng_B/0/1/0/all/0/1">Binghui Peng</a></p><p>We show that any randomized first-order algorithm which minimizes a
$d$-dimensional, $1$-Lipschitz convex function over the unit ball must either
use $\Omega(d^{2-\delta})$ bits of memory or make $\Omega(d^{1+\delta/6-o(1)})$
queries, for any constant $\delta\in (0,1)$ and when the precision $\epsilon$
is quasipolynomially small in $d$. Our result implies that cutting plane
methods, which use $\tilde{O}(d^2)$ bits of memory and $\tilde{O}(d)$ queries,
are Pareto-optimal among randomized first-order algorithms, and quadratic
memory is required to achieve optimal query complexity for convex optimization.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-23T00:30:00Z">Friday, June 23 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.12549'>On Differentially Private Sampling from Gaussian and Product Distributions</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Badih Ghazi, Xiao Hu, Ravi Kumar, Pasin Manurangsi</p><p>Given a dataset of $n$ i.i.d. samples from an unknown distribution $P$, we
consider the problem of generating a sample from a distribution that is close
to $P$ in total variation distance, under the constraint of differential
privacy (DP). We study the problem when $P$ is a multi-dimensional Gaussian
distribution, under different assumptions on the information available to the
DP mechanism: known covariance, unknown bounded covariance, and unknown
unbounded covariance. We present new DP sampling algorithms, and show that they
achieve near-optimal sample complexity in the first two settings. Moreover,
when $P$ is a product distribution on the binary hypercube, we obtain a pure-DP
algorithm whereas only an approximate-DP algorithm (with slightly worse sample
complexity) was previously known.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Ghazi_B/0/1/0/all/0/1">Badih Ghazi</a>, <a href="http://arxiv.org/find/cs/1/au:+Hu_X/0/1/0/all/0/1">Xiao Hu</a>, <a href="http://arxiv.org/find/cs/1/au:+Kumar_R/0/1/0/all/0/1">Ravi Kumar</a>, <a href="http://arxiv.org/find/cs/1/au:+Manurangsi_P/0/1/0/all/0/1">Pasin Manurangsi</a></p><p>Given a dataset of $n$ i.i.d. samples from an unknown distribution $P$, we
consider the problem of generating a sample from a distribution that is close
to $P$ in total variation distance, under the constraint of differential
privacy (DP). We study the problem when $P$ is a multi-dimensional Gaussian
distribution, under different assumptions on the information available to the
DP mechanism: known covariance, unknown bounded covariance, and unknown
unbounded covariance. We present new DP sampling algorithms, and show that they
achieve near-optimal sample complexity in the first two settings. Moreover,
when $P$ is a product distribution on the binary hypercube, we obtain a pure-DP
algorithm whereas only an approximate-DP algorithm (with slightly worse sample
complexity) was previously known.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-23T00:30:00Z">Friday, June 23 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.12667'>The Power of Menus in Contract Design</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Guru Guruganesh, Jon Schneider, Joshua Wang, Junyao Zhao</p><p>We study the power of menus of contracts in principal-agent problems with
adverse selection (agents can be one of several types) and moral hazard (we
cannot observe agent actions directly). For principal-agent problems with $T$
types and $n$ actions, we show that the best menu of contracts can obtain a
factor $\Omega(\max(n, \log T))$ more utility for the principal than the best
individual contract, partially resolving an open question of Guruganesh et al.
(2021). We then turn our attention to randomized menus of linear contracts,
where we likewise show that randomized linear menus can be $\Omega(T)$ better
than the best single linear contract. As a corollary, we show this implies an
analogous gap between deterministic menus of (general) contracts and randomized
menus of contracts (as introduced by Castiglioni et al. (2022)).
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Guruganesh_G/0/1/0/all/0/1">Guru Guruganesh</a>, <a href="http://arxiv.org/find/cs/1/au:+Schneider_J/0/1/0/all/0/1">Jon Schneider</a>, <a href="http://arxiv.org/find/cs/1/au:+Wang_J/0/1/0/all/0/1">Joshua Wang</a>, <a href="http://arxiv.org/find/cs/1/au:+Zhao_J/0/1/0/all/0/1">Junyao Zhao</a></p><p>We study the power of menus of contracts in principal-agent problems with
adverse selection (agents can be one of several types) and moral hazard (we
cannot observe agent actions directly). For principal-agent problems with $T$
types and $n$ actions, we show that the best menu of contracts can obtain a
factor $\Omega(\max(n, \log T))$ more utility for the principal than the best
individual contract, partially resolving an open question of Guruganesh et al.
(2021). We then turn our attention to randomized menus of linear contracts,
where we likewise show that randomized linear menus can be $\Omega(T)$ better
than the best single linear contract. As a corollary, we show this implies an
analogous gap between deterministic menus of (general) contracts and randomized
menus of contracts (as introduced by Castiglioni et al. (2022)).
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-23T00:30:00Z">Friday, June 23 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.12682'>Counting occurrences of patterns in permutations</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Andrew R Conway, Anthony J Guttmann</p><p>We develop a new, powerful method for counting elements in a {\em multiset.}
As a first application, we use this algorithm to study the number of
occurrences of patterns in a permutation. For patterns of length 3 there are
two Wilf classes, and the general behaviour of these is reasonably well-known.
We slightly extend some of the known results in that case, and exhaustively
study the case of patterns of length 4, about which there is little previous
knowledge. For such patterns, there are seven Wilf classes, and based on
extensive enumerations and careful series analysis, we have conjectured the
asymptotic behaviour for all classes.
</p>
<p>Finally, we investigate a proposal of Blitvi\'c and Steingr\'imsson as to the
range of a parameter for which a particular generating function formed from the
occurrence sequences is itself a Stieltjes moment sequence.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/math/1/au:+Conway_A/0/1/0/all/0/1">Andrew R Conway</a>, <a href="http://arxiv.org/find/math/1/au:+Guttmann_A/0/1/0/all/0/1">Anthony J Guttmann</a></p><p>We develop a new, powerful method for counting elements in a {\em multiset.}
As a first application, we use this algorithm to study the number of
occurrences of patterns in a permutation. For patterns of length 3 there are
two Wilf classes, and the general behaviour of these is reasonably well-known.
We slightly extend some of the known results in that case, and exhaustively
study the case of patterns of length 4, about which there is little previous
knowledge. For such patterns, there are seven Wilf classes, and based on
extensive enumerations and careful series analysis, we have conjectured the
asymptotic behaviour for all classes.
</p>
<p>Finally, we investigate a proposal of Blitvi\'c and Steingr\'imsson as to the
range of a parameter for which a particular generating function formed from the
occurrence sequences is itself a Stieltjes moment sequence.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-23T00:30:00Z">Friday, June 23 2023, 00:30</time>
        </div>
      </div>
    </details>
  
    

    <details class='tr-article' open>
      <summary class='tr-article-header'>
        <h3 class='tr-article-title'><a href='http://arxiv.org/abs/2306.12771'>Faster Compression of Deterministic Finite Automata</a></h3>
        <p class='tr-article-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        <i class="fa-solid fa-fw fa-chevron-down tr-chevron"></i>
      </summary>

      <i class="fa-solid fa-fw fa-chevron-up tr-chevron"></i>

      <div class='tr-article-body'>
        <div class='tr-article-snippet'>
        
          <p>Authors: Philip Bille, Inge Li G&#xf8;rtz, Max Rish&#xf8;j Pedersen</p><p>Deterministic finite automata (DFA) are a classic tool for high throughput
matching of regular expressions, both in theory and practice.
</p>
<p>Due to their high space consumption, extensive research has been devoted to
compressed representations of DFAs that still support efficient pattern
matching queries.
</p>
<p>Kumar~et~al.~[SIGCOMM 2006] introduced the \emph{delayed deterministic finite
automaton} (\ddfa{}) which exploits the large redundancy between inter-state
transitions in the automaton.
</p>
<p>They showed it to obtain up to two orders of magnitude compression of
real-world DFAs, and their work formed the basis of numerous subsequent
results.
</p>
<p>Their algorithm, as well as later algorithms based on their idea, have an
inherent quadratic-time bottleneck, as they consider every pair of states to
compute the optimal compression.
</p>
<p>In this work we present a simple, general framework based on
locality-sensitive hashing for speeding up these algorithms to achieve
sub-quadratic construction times for \ddfa{}s.
</p>
<p>We apply the framework to speed up several algorithms to near-linear time,
and experimentally evaluate their performance on real-world regular expression
sets extracted from modern intrusion detection systems.
</p>
<p>We find an order of magnitude improvement in compression times, with either
little or no loss of compression, or even significantly better compression in
some cases.
</p>
        
        </div>

        <div class='tr-article-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Bille_P/0/1/0/all/0/1">Philip Bille</a>, <a href="http://arxiv.org/find/cs/1/au:+Gortz_I/0/1/0/all/0/1">Inge Li G&#xf8;rtz</a>, <a href="http://arxiv.org/find/cs/1/au:+Pedersen_M/0/1/0/all/0/1">Max Rish&#xf8;j Pedersen</a></p><p>Deterministic finite automata (DFA) are a classic tool for high throughput
matching of regular expressions, both in theory and practice.
</p>
<p>Due to their high space consumption, extensive research has been devoted to
compressed representations of DFAs that still support efficient pattern
matching queries.
</p>
<p>Kumar~et~al.~[SIGCOMM 2006] introduced the \emph{delayed deterministic finite
automaton} (\ddfa{}) which exploits the large redundancy between inter-state
transitions in the automaton.
</p>
<p>They showed it to obtain up to two orders of magnitude compression of
real-world DFAs, and their work formed the basis of numerous subsequent
results.
</p>
<p>Their algorithm, as well as later algorithms based on their idea, have an
inherent quadratic-time bottleneck, as they consider every pair of states to
compute the optimal compression.
</p>
<p>In this work we present a simple, general framework based on
locality-sensitive hashing for speeding up these algorithms to achieve
sub-quadratic construction times for \ddfa{}s.
</p>
<p>We apply the framework to speed up several algorithms to near-linear time,
and experimentally evaluate their performance on real-world regular expression
sets extracted from modern intrusion detection systems.
</p>
<p>We find an order of magnitude improvement in compression times, with either
little or no loss of compression, or even significantly better compression in
some cases.
</p>
        
        </div>

        <div class='tr-article-footer'>
          <time class='timeago' datetime="2023-06-23T00:30:00Z">Friday, June 23 2023, 00:30</time>
        </div>
      </div>
    </details>
  
  </div>

  <script src='https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.1/jquery.min.js' type="text/javascript"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-timeago/1.6.7/jquery.timeago.min.js" type="text/javascript"></script>
  <script src='js/theory.js'></script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>
