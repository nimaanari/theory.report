<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-0RQ5M78VX5"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-0RQ5M78VX5');
  </script>
  <meta charset='utf-8'>
  <meta name='generator' content='Pluto 1.6.2 on Ruby 3.0.4 (2022-04-12) [x86_64-linux]'>

  <title>Theory of Computing Report</title>

  <link rel="alternate" type="application/rss+xml" title="Posts (RSS)" href="rss20.xml" />
  <link rel="alternate" type="application/atom+xml" title="Posts (Atom)" href="atom.xml" />
  
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">

  <link rel='stylesheet' type='text/css' href='css/font-awesome.css'>
  <link rel='stylesheet' type='text/css' href='css/blank.css'>
</head>
<body>
  <div id='navwrap'>
    <div id='nav'>
      <p>
        Last Update
      </p>
      <p class='small'>
        
          <time class='timeago' datetime="2022-10-06T05:57:15Z">Thursday, October 06 2022, 05:57</time>
        
      </p>

      <p>Feeds</p>
      <ul class='subscriptions small' >
      
        <li>
          <a href='http://arxiv.org/rss/cs.CC'><img src='i/feed.png'></a>
          <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a>
          
        </li>
      
        <li>
          <a href='http://arxiv.org/rss/cs.CG'><img src='i/feed.png'></a>
          <a href='https://arxiv.org/list/cs.CG/recent'>arXiv: Computational Geometry</a>
          
        </li>
      
        <li>
          <a href='http://arxiv.org/rss/cs.DS'><img src='i/feed.png'></a>
          <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a>
          
        </li>
      
        <li>
          <a href='http://aaronsadventures.blogspot.com/feeds/posts/default'><img src='i/feed.png'></a>
          <a href='http://aaronsadventures.blogspot.com/'>Aaron Roth</a>
          
        </li>
      
        <li>
          <a href='https://adamsheffer.wordpress.com/feed/'><img src='i/feed.png'></a>
          <a href='https://adamsheffer.wordpress.com'>Adam Sheffer</a>
          
        </li>
      
        <li>
          <a href='https://adamdsmith.wordpress.com/feed/'><img src='i/feed.png'></a>
          <a href='https://adamdsmith.wordpress.com'>Adam Smith</a>
          
        </li>
      
        <li>
          <a href='https://polylogblog.wordpress.com/feed/'><img src='i/feed.png'></a>
          <a href='https://polylogblog.wordpress.com'>Andrew McGregor</a>
          
        </li>
      
        <li>
          <a href='https://corner.mimuw.edu.pl/?feed=rss2'><img src='i/feed.png'></a>
          <a href='https://corner.mimuw.edu.pl'>Banach's Algorithmic Corner</a>
          
        </li>
      
        <li>
          <a href='http://www.argmin.net/feed.xml'><img src='i/feed.png'></a>
          <a href='http://benjamin-recht.github.io/'>Ben Recht</a>
          
        </li>
      
        <li>
          <a href='http://bit-player.org/feed/atom/'><img src='i/feed.png'></a>
          <a href='http://bit-player.org'>bit-player</a>
          
        </li>
      
        <li>
          <a href='https://cstheory-jobs.org/feed/'><img src='i/feed.png'></a>
          <a href='https://cstheory-jobs.org'>CCI: jobs</a>
          
        </li>
      
        <li>
          <a href='https://cstheory-events.org/feed/'><img src='i/feed.png'></a>
          <a href='https://cstheory-events.org'>CS Theory Events</a>
          
        </li>
      
        <li>
          <a href='http://blog.computationalcomplexity.org/feeds/posts/default'><img src='i/feed.png'></a>
          <a href='http://blog.computationalcomplexity.org/'>Computational Complexity</a>
          
        </li>
      
        <li>
          <a href='https://11011110.github.io/blog/feed.xml'><img src='i/feed.png'></a>
          <a href='https://11011110.github.io/blog/'>David Eppstein</a>
          
        </li>
      
        <li>
          <a href='https://daveagp.wordpress.com/category/toc/feed/'><img src='i/feed.png'></a>
          <a href='https://daveagp.wordpress.com'>David Pritchard</a>
          
        </li>
      
        <li>
          <a href='https://decentdescent.org/feed.xml'><img src='i/feed.png'></a>
          <a href='https://decentdescent.org/'>Decent Descent</a>
          
        </li>
      
        <li>
          <a href='https://decentralizedthoughts.github.io/feed'><img src='i/feed.png'></a>
          <a href='https://decentralizedthoughts.github.io'>Decentralized Thoughts</a>
          
        </li>
      
        <li>
          <a href='https://differentialprivacy.org/feed.xml'><img src='i/feed.png'></a>
          <a href='https://differentialprivacy.org'>DifferentialPrivacy.org</a>
          
        </li>
      
        <li>
          <a href='https://eccc.weizmann.ac.il//feeds/reports/'><img src='i/feed.png'></a>
          <a href='https://eccc.weizmann.ac.il/'>ECCC Papers</a>
          
        </li>
      
        <li>
          <a href='https://emanueleviola.wordpress.com/feed/'><img src='i/feed.png'></a>
          <a href='https://emanueleviola.wordpress.com'>Emanuele Viola</a>
          
        </li>
      
        <li>
          <a href='https://3dpancakes.typepad.com/ernie/atom.xml'><img src='i/feed.png'></a>
          <a href='https://3dpancakes.typepad.com/ernie/'>Ernie's 3D Pancakes</a>
          
        </li>
      
        <li>
          <a href='https://dstheory.wordpress.com/feed/'><img src='i/feed.png'></a>
          <a href='https://dstheory.wordpress.com'>Foundation of Data Science - Virtual Talk Series</a>
          
        </li>
      
        <li>
          <a href='https://francisbach.com/feed/'><img src='i/feed.png'></a>
          <a href='https://francisbach.com'>Francis Bach</a>
          
        </li>
      
        <li>
          <a href='https://gilkalai.wordpress.com/feed/'><img src='i/feed.png'></a>
          <a href='https://gilkalai.wordpress.com'>Gil Kalai</a>
          
        </li>
      
        <li>
          <a href='https://blogs.oregonstate.edu:443/glencora/tag/tcs/feed/'><img src='i/feed.png'></a>
          <a href='https://blogs.oregonstate.edu/glencora'>Glencora Borradaile</a>
          
        </li>
      
        <li>
          <a href='https://research.googleblog.com/feeds/posts/default/-/Algorithms'><img src='i/feed.png'></a>
          <a href='https://research.googleblog.com/search/label/Algorithms'>Google Research Blog: Algorithms</a>
          
        </li>
      
        <li>
          <a href='https://gradientscience.org/feed.xml'><img src='i/feed.png'></a>
          <a href='https://gradientscience.org/'>Gradient Science</a>
          
        </li>
      
        <li>
          <a href='http://grigory.us/blog/feed.xml'><img src='i/feed.png'></a>
          <a href='http://grigory.github.io/blog'>Grigory Yaroslavtsev</a>
          
        </li>
      
        <li>
          <a href='https://tcsmath.wordpress.com/feed/'><img src='i/feed.png'></a>
          <a href='https://tcsmath.wordpress.com'>James R. Lee</a>
          
        </li>
      
        <li>
          <a href='https://kamathematics.wordpress.com/feed/'><img src='i/feed.png'></a>
          <a href='https://kamathematics.wordpress.com'>Kamathematics</a>
          
        </li>
      
        <li>
          <a href='http://processalgebra.blogspot.com/feeds/posts/default'><img src='i/feed.png'></a>
          <a href='http://processalgebra.blogspot.com/'>Luca Aceto</a>
          
        </li>
      
        <li>
          <a href='https://lucatrevisan.wordpress.com/feed/'><img src='i/feed.png'></a>
          <a href='https://lucatrevisan.wordpress.com'>Luca Trevisan</a>
          
        </li>
      
        <li>
          <a href='https://mittheory.wordpress.com/feed/'><img src='i/feed.png'></a>
          <a href='https://mittheory.wordpress.com'>MIT CSAIL Student Blog</a>
          
        </li>
      
        <li>
          <a href='http://mybiasedcoin.blogspot.com/feeds/posts/default'><img src='i/feed.png'></a>
          <a href='http://mybiasedcoin.blogspot.com/'>Michael Mitzenmacher</a>
          
        </li>
      
        <li>
          <a href='http://blog.mrtz.org/feed.xml'><img src='i/feed.png'></a>
          <a href='http://blog.mrtz.org/'>Moritz Hardt</a>
          
        </li>
      
        <li>
          <a href='http://mysliceofpizza.blogspot.com/feeds/posts/default/-/aggregator'><img src='i/feed.png'></a>
          <a href='http://mysliceofpizza.blogspot.com/search/label/aggregator'>Muthu Muthukrishnan</a>
          
        </li>
      
        <li>
          <a href='https://nisheethvishnoi.wordpress.com/feed/'><img src='i/feed.png'></a>
          <a href='https://nisheethvishnoi.wordpress.com'>Nisheeth Vishnoi</a>
          
        </li>
      
        <li>
          <a href='http://www.solipsistslog.com/feed/'><img src='i/feed.png'></a>
          <a href='http://www.solipsistslog.com'>Noah Stephens-Davidowitz</a>
          
        </li>
      
        <li>
          <a href='http://www.offconvex.org/feed.xml'><img src='i/feed.png'></a>
          <a href='http://offconvex.github.io/'>Off the Convex Path</a>
          
        </li>
      
        <li>
          <a href='http://paulwgoldberg.blogspot.com/feeds/posts/default/-/aggregator'><img src='i/feed.png'></a>
          <a href='http://paulwgoldberg.blogspot.com/search/label/aggregator'>Paul Goldberg</a>
          
        </li>
      
        <li>
          <a href='https://ptreview.sublinear.info/?feed=rss2'><img src='i/feed.png'></a>
          <a href='https://ptreview.sublinear.info'>Property Testing Review</a>
          
        </li>
      
        <li>
          <a href='https://rjlipton.wpcomstaging.com/feed/'><img src='i/feed.png'></a>
          <a href='https://rjlipton.wpcomstaging.com'>Richard Lipton</a>
          
        </li>
      
        <li>
          <a href='https://blogs.princeton.edu/imabandit/feed/'><img src='i/feed.png'></a>
          <a href='https://blogs.princeton.edu/imabandit'>SÃ©bastien Bubeck</a>
          
        </li>
      
        <li>
          <a href='https://scottaaronson.blog/?feed=atom'><img src='i/feed.png'></a>
          <a href='https://scottaaronson.blog'>Scott Aaronson</a>
          
        </li>
      
        <li>
          <a href='https://blog.simons.berkeley.edu/feed/'><img src='i/feed.png'></a>
          <a href='https://blog.simons.berkeley.edu'>Simons Institute Blog</a>
          
        </li>
      
        <li>
          <a href='https://tcsplus.wordpress.com/feed/'><img src='i/feed.png'></a>
          <a href='https://tcsplus.wordpress.com'>TCS+ Seminar Series</a>
          
        </li>
      
        <li>
          <a href='https://toc4fairness.org/feed/'><img src='i/feed.png'></a>
          <a href='https://toc4fairness.org'>TOC for Fairness</a>
          
        </li>
      
        <li>
          <a href='http://www.blogger.com/feeds/6555947/posts/default?alt=atom'><img src='i/feed.png'></a>
          <a href='http://blog.geomblog.org/'>The Geomblog</a>
          
        </li>
      
        <li>
          <a href='https://www.let-all.com/blog/feed/'><img src='i/feed.png'></a>
          <a href='https://www.let-all.com/blog'>The Learning Theory Alliance Blog</a>
          
        </li>
      
        <li>
          <a href='https://theorydish.blog/feed/'><img src='i/feed.png'></a>
          <a href='https://theorydish.blog'>Theory Dish: Stanford Blog</a>
          
        </li>
      
        <li>
          <a href='https://thmatters.wordpress.com/feed/'><img src='i/feed.png'></a>
          <a href='https://thmatters.wordpress.com'>Theory Matters</a>
          
        </li>
      
        <li>
          <a href='https://mycqstate.wordpress.com/feed/'><img src='i/feed.png'></a>
          <a href='https://mycqstate.wordpress.com'>Thomas Vidick</a>
          
        </li>
      
        <li>
          <a href='https://agtb.wordpress.com/feed/'><img src='i/feed.png'></a>
          <a href='https://agtb.wordpress.com'>Turing's Invisible Hand</a>
          
        </li>
      
        <li>
          <a href='https://windowsontheory.org/feed/'><img src='i/feed.png'></a>
          <a href='https://windowsontheory.org'>Windows on Theory</a>
          
        </li>
      
      </ul>

      <p class='small'><a href="opml.xml">OPML feed</a> of all feeds.</p>
      <p class='small'>Subscribe to the <a href="atom.xml">Atom feed</a> or <a href="rss20.xml">RSS feed</a> to stay up to date.</p>
      <p class='small'>Source on <a href="https://github.com/nimaanari/theory.report">GitHub</a>.</p>
      <p class='small'>Maintained by Nima Anari, Arnab Bhattacharyya, Gautam Kamath.</p>
      <p class='small'>Powered by <a href='https://github.com/feedreader'>Pluto</a>.</p>
    </div>
  </div>

  <div id='opts'>
    <div style='width: 100%; text-align: right;'>
    <img src='i/view-headlines.png' id='show-headlines' title='Show Headlines Only' width='24' height='24'>
    <img src='i/view-snippets.png' id='show-snippets' title='Show Snippets' width='24' height='24'>
    <img src='i/view-standard.png' id='show-fulltext' title='Show Full Text' width='24' height='24'>
    </div>
  </div>

  <h1>
    Theory of Computing Report
  </h1>

  <div id="articles">
    
    
    <h2 class='new-date'>
      <i class='icon-calendar-empty'></i> Thursday, October 06
    </h2>
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.02035'>A Counterexample to a Directed KKL Inequality</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Quentin Dubroff, Shivam Nadimpalli, Bhargav Narayanan</p><p>We show that the natural directed analogues of the KKL theorem [KKL88] and
the Eldan--Gross inequality [EG20] from the analysis of Boolean functions fail
to hold. This is in contrast to several other isoperimetric inequalities on the
Boolean hypercube (such as the Poincare inequality, Margulis's inequality
[Mar74] and Talagrand's inequality [Tal93]) for which directed strengthenings
have recently been established.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/math/1/au:+Dubroff_Q/0/1/0/all/0/1">Quentin Dubroff</a>, <a href="http://arxiv.org/find/math/1/au:+Nadimpalli_S/0/1/0/all/0/1">Shivam Nadimpalli</a>, <a href="http://arxiv.org/find/math/1/au:+Narayanan_B/0/1/0/all/0/1">Bhargav Narayanan</a></p><p>We show that the natural directed analogues of the KKL theorem [KKL88] and
the Eldan--Gross inequality [EG20] from the analysis of Boolean functions fail
to hold. This is in contrast to several other isoperimetric inequalities on the
Boolean hypercube (such as the Poincare inequality, Margulis's inequality
[Mar74] and Talagrand's inequality [Tal93]) for which directed strengthenings
have recently been established.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-06T00:30:00Z">Thursday, October 06 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.02288'>On Convexity in Split graphs: Complexity of Steiner tree and Domination</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: A Mohanapriya, P Renjith, N Sadagopan</p><p>Given a graph $G$ with a terminal set $R \subseteq V(G)$, the Steiner tree
problem (STREE) asks for a set $S\subseteq V(G) \setminus R$ such that the
graph induced on $S\cup R$ is connected. A split graph is a graph which can be
partitioned into a clique and an independent set. It is known that STREE is
NP-complete on split graphs \cite{white1985steiner}. To strengthen this result,
we introduce convex ordering on one of the partitions (clique or independent
set), and prove that STREE is polynomial-time solvable for tree-convex split
graphs with convexity on clique ($K$), whereas STREE is NP-complete on
tree-convex split graphs with convexity on independent set ($I$). We further
strengthen our NP-complete result by establishing a dichotomy which says that
for unary-tree-convex split graphs (path-convex split graphs), STREE is
polynomial-time solvable, and NP-complete for binary-tree-convex split graphs
(comb-convex split graphs). We also show that STREE is polynomial-time solvable
for triad-convex split graphs with convexity on $I$, and circular-convex split
graphs. Further, we show that STREE can be used as a framework for the
dominating set problem (DS) on split graphs, and hence the classical complexity
(P vs NPC) of STREE and DS is the same for all these subclasses of split
graphs. Furthermore, it is important to highlight that in
\cite{CHLEBIK20081264}, it is incorrectly claimed that the problem of finding a
minimum dominating set on split graphs cannot be approximated within
$(1-\epsilon)\ln |V(G)|$ in polynomial-time for any $\epsilon &gt;0$ unless NP
$\subseteq$ DTIME $n^{O(\log \log n)}$. When the input is restricted to split
graphs, we show that the minimum dominating set problem has
$2-\frac{1}{|I|}$-approximation algorithm that runs in polynomial time.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Mohanapriya_A/0/1/0/all/0/1">A Mohanapriya</a>, <a href="http://arxiv.org/find/cs/1/au:+Renjith_P/0/1/0/all/0/1">P Renjith</a>, <a href="http://arxiv.org/find/cs/1/au:+Sadagopan_N/0/1/0/all/0/1">N Sadagopan</a></p><p>Given a graph $G$ with a terminal set $R \subseteq V(G)$, the Steiner tree
problem (STREE) asks for a set $S\subseteq V(G) \setminus R$ such that the
graph induced on $S\cup R$ is connected. A split graph is a graph which can be
partitioned into a clique and an independent set. It is known that STREE is
NP-complete on split graphs \cite{white1985steiner}. To strengthen this result,
we introduce convex ordering on one of the partitions (clique or independent
set), and prove that STREE is polynomial-time solvable for tree-convex split
graphs with convexity on clique ($K$), whereas STREE is NP-complete on
tree-convex split graphs with convexity on independent set ($I$). We further
strengthen our NP-complete result by establishing a dichotomy which says that
for unary-tree-convex split graphs (path-convex split graphs), STREE is
polynomial-time solvable, and NP-complete for binary-tree-convex split graphs
(comb-convex split graphs). We also show that STREE is polynomial-time solvable
for triad-convex split graphs with convexity on $I$, and circular-convex split
graphs. Further, we show that STREE can be used as a framework for the
dominating set problem (DS) on split graphs, and hence the classical complexity
(P vs NPC) of STREE and DS is the same for all these subclasses of split
graphs. Furthermore, it is important to highlight that in
\cite{CHLEBIK20081264}, it is incorrectly claimed that the problem of finding a
minimum dominating set on split graphs cannot be approximated within
$(1-\epsilon)\ln |V(G)|$ in polynomial-time for any $\epsilon &gt;0$ unless NP
$\subseteq$ DTIME $n^{O(\log \log n)}$. When the input is restricted to split
graphs, we show that the minimum dominating set problem has
$2-\frac{1}{|I|}$-approximation algorithm that runs in polynomial time.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-06T00:30:00Z">Thursday, October 06 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.02167'>Faster parameterized algorithms for modification problems to minor-closed classes</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Laure Morelle, Ignasi Sau, Giannos Stamoulis, Dimitrios M. Thilikos</p><p>Let ${\cal G}$ be a minor-closed graph class and let $G$ be an $n$-vertex
graph. We say that $G$ is a $k$-apex of ${\cal G}$ if $G$ contains a set $S$ of
at most $k$ vertices such that $G\setminus S$ belongs to ${\cal G}$. Our first
result is an algorithm that decides whether $G$ is a $k$-apex of ${\cal G}$ in
time $2^{{\sf poly}(k)}\cdot n^2$, where ${\sf poly}$ is a polynomial function
depending on ${\cal G}$. This algorithm improves the previous one, given by
Sau, Stamoulis, and Thilikos [ICALP 2020], whose running time was $2^{{\sf
poly}(k)}\cdot n^3$. The elimination distance of $G$ to ${\cal G}$, denoted by
${\sf ed}_{\cal G}(G)$, is the minimum number of rounds required to reduce each
connected component of $G$ to a graph in ${\cal G}$ by removing one vertex from
each connected component in each round. Bulian and Dawar [Algorithmica 2017]
provided an FPT-algorithm, with parameter $k$, to decide whether ${\sf
ed}_{\cal G}(G)\leq k$. However, its dependence on $k$ is not explicit. We
extend the techniques used in the first algorithm to decide whether ${\sf
ed}_{\cal G}(G)\leq k$ in time $2^{2^{2^{{\sf poly}(k)}}}\cdot n^2$. This is
the first algorithm for this problem with an explicit parametric dependence in
$k$. In the special case where ${\cal G}$ excludes some apex-graph as a minor,
we give two alternative algorithms, running in time $2^{2^{{\cal O}(k^2\log
k)}}\cdot n^2$ and $2^{{\sf poly}(k)}\cdot n^3$ respectively, where $c$ and
${\sf poly}$ depend on ${\cal G}$. As a stepping stone for these algorithms, we
provide an algorithm that decides whether ${\sf ed}_{\cal G}(G)\leq k$ in time
$2^{{\cal O}({\sf tw}\cdot k+{\sf tw}\log{\sf tw})}\cdot n$, where ${\sf tw}$
is the treewidth of $G$. Finally, we provide explicit upper bounds on the size
of the graphs in the minor-obstruction set of the class of graphs ${\cal
E}_k({\cal G})=\{G\mid{\sf ed}_{\cal G}(G)\leq k\}$.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Morelle_L/0/1/0/all/0/1">Laure Morelle</a>, <a href="http://arxiv.org/find/cs/1/au:+Sau_I/0/1/0/all/0/1">Ignasi Sau</a>, <a href="http://arxiv.org/find/cs/1/au:+Stamoulis_G/0/1/0/all/0/1">Giannos Stamoulis</a>, <a href="http://arxiv.org/find/cs/1/au:+Thilikos_D/0/1/0/all/0/1">Dimitrios M. Thilikos</a></p><p>Let ${\cal G}$ be a minor-closed graph class and let $G$ be an $n$-vertex
graph. We say that $G$ is a $k$-apex of ${\cal G}$ if $G$ contains a set $S$ of
at most $k$ vertices such that $G\setminus S$ belongs to ${\cal G}$. Our first
result is an algorithm that decides whether $G$ is a $k$-apex of ${\cal G}$ in
time $2^{{\sf poly}(k)}\cdot n^2$, where ${\sf poly}$ is a polynomial function
depending on ${\cal G}$. This algorithm improves the previous one, given by
Sau, Stamoulis, and Thilikos [ICALP 2020], whose running time was $2^{{\sf
poly}(k)}\cdot n^3$. The elimination distance of $G$ to ${\cal G}$, denoted by
${\sf ed}_{\cal G}(G)$, is the minimum number of rounds required to reduce each
connected component of $G$ to a graph in ${\cal G}$ by removing one vertex from
each connected component in each round. Bulian and Dawar [Algorithmica 2017]
provided an FPT-algorithm, with parameter $k$, to decide whether ${\sf
ed}_{\cal G}(G)\leq k$. However, its dependence on $k$ is not explicit. We
extend the techniques used in the first algorithm to decide whether ${\sf
ed}_{\cal G}(G)\leq k$ in time $2^{2^{2^{{\sf poly}(k)}}}\cdot n^2$. This is
the first algorithm for this problem with an explicit parametric dependence in
$k$. In the special case where ${\cal G}$ excludes some apex-graph as a minor,
we give two alternative algorithms, running in time $2^{2^{{\cal O}(k^2\log
k)}}\cdot n^2$ and $2^{{\sf poly}(k)}\cdot n^3$ respectively, where $c$ and
${\sf poly}$ depend on ${\cal G}$. As a stepping stone for these algorithms, we
provide an algorithm that decides whether ${\sf ed}_{\cal G}(G)\leq k$ in time
$2^{{\cal O}({\sf tw}\cdot k+{\sf tw}\log{\sf tw})}\cdot n$, where ${\sf tw}$
is the treewidth of $G$. Finally, we provide explicit upper bounds on the size
of the graphs in the minor-obstruction set of the class of graphs ${\cal
E}_k({\cal G})=\{G\mid{\sf ed}_{\cal G}(G)\leq k\}$.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-06T00:30:00Z">Thursday, October 06 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.01849'>Link Partitioning on Simplicial Complexes Using Higher-Order Laplacians</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Xinyi Wu, Arnab Sarker, Ali Jadbabaie</p><p>Link partitioning is a popular approach in network science used for
discovering overlapping communities by identifying clusters of strongly
connected links. Current link partitioning methods are specifically designed
for networks modelled by graphs representing pairwise relationships. Therefore,
these methods are incapable of utilizing higher-order information about group
interactions in network data which is increasingly available. Simplicial
complexes extend the dyadic model of graphs and can model polyadic
relationships which are ubiquitous and crucial in many complex social and
technological systems. In this paper, we introduce a link partitioning method
that leverages higher-order (i.e. triadic and higher) information in simplicial
complexes for better community detection. Our method utilizes a novel random
walk on links of simplicial complexes defined by the higher-order Laplacian--a
generalization of the graph Laplacian that incorporates polyadic relationships
of the network. We transform this random walk into a graph-based random walk on
a lifted line graph--a dual graph in which links are nodes while nodes and
higher-order connections are links--and optimize for the standard notion of
modularity. We show that our method is guaranteed to provide interpretable link
partitioning results under mild assumptions. We also offer new theoretical
results on the spectral properties of simplicial complexes by studying the
spectrum of the link random walk. Experiment results on real-world community
detection tasks show that our higher-order approach significantly outperforms
existing graph-based link partitioning methods.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Wu_X/0/1/0/all/0/1">Xinyi Wu</a>, <a href="http://arxiv.org/find/cs/1/au:+Sarker_A/0/1/0/all/0/1">Arnab Sarker</a>, <a href="http://arxiv.org/find/cs/1/au:+Jadbabaie_A/0/1/0/all/0/1">Ali Jadbabaie</a></p><p>Link partitioning is a popular approach in network science used for
discovering overlapping communities by identifying clusters of strongly
connected links. Current link partitioning methods are specifically designed
for networks modelled by graphs representing pairwise relationships. Therefore,
these methods are incapable of utilizing higher-order information about group
interactions in network data which is increasingly available. Simplicial
complexes extend the dyadic model of graphs and can model polyadic
relationships which are ubiquitous and crucial in many complex social and
technological systems. In this paper, we introduce a link partitioning method
that leverages higher-order (i.e. triadic and higher) information in simplicial
complexes for better community detection. Our method utilizes a novel random
walk on links of simplicial complexes defined by the higher-order Laplacian--a
generalization of the graph Laplacian that incorporates polyadic relationships
of the network. We transform this random walk into a graph-based random walk on
a lifted line graph--a dual graph in which links are nodes while nodes and
higher-order connections are links--and optimize for the standard notion of
modularity. We show that our method is guaranteed to provide interpretable link
partitioning results under mild assumptions. We also offer new theoretical
results on the spectral properties of simplicial complexes by studying the
spectrum of the link random walk. Experiment results on real-world community
detection tasks show that our higher-order approach significantly outperforms
existing graph-based link partitioning methods.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-06T00:30:00Z">Thursday, October 06 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.01888'>Bicriteria Approximation Algorithms for Priority Matroid Median</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Tanvi Bajpai, Chandra Chekuri</p><p>Fairness considerations have motivated new clustering problems and algorithms
in recent years. In this paper we consider the Priority Matroid Median problem
which generalizes the Priority $k$-Median problem that has recently been
studied. The input consists of a set of facilities $\mathcal{F}$ and a set of
clients $\mathcal{C}$ that lie in a metric space $(\mathcal{F} \cup
\mathcal{C},d)$, and a matroid $\mathcal{M}=(\mathcal{F},\mathcal{I})$ over the
facilities. In addition each client $j$ has a specified radius $r_j \ge 0$ and
each facility $i \in \mathcal{F}$ has an opening cost $f_i$. The goal is to
choose a subset $S \subseteq \mathcal{F}$ of facilities to minimize the
$\sum_{i \in \mathcal{F}} f_i + \sum_{j \in \mathcal{C}} d(j,S)$ subject to two
constraints: (i) $S$ is an independent set in $\mathcal{M}$ (that is $S \in
\mathcal{I}$) and (ii) for each client $j$, its distance to an open facility is
at most $r_j$ (that is, $d(j,S) \le r_j$). For this problem we describe the
first bicriteria $(c_1,c_2)$ approximations for fixed constants $c_1,c_2$: the
radius constraints of the clients are violated by at most a factor of $c_1$ and
the objective cost is at most $c_2$ times the optimum cost. We also improve the
previously known bicriteria approximation for the uniform radius setting ($r_j
:= L$ $\forall j \in \mathcal{C}$).
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Bajpai_T/0/1/0/all/0/1">Tanvi Bajpai</a>, <a href="http://arxiv.org/find/cs/1/au:+Chekuri_C/0/1/0/all/0/1">Chandra Chekuri</a></p><p>Fairness considerations have motivated new clustering problems and algorithms
in recent years. In this paper we consider the Priority Matroid Median problem
which generalizes the Priority $k$-Median problem that has recently been
studied. The input consists of a set of facilities $\mathcal{F}$ and a set of
clients $\mathcal{C}$ that lie in a metric space $(\mathcal{F} \cup
\mathcal{C},d)$, and a matroid $\mathcal{M}=(\mathcal{F},\mathcal{I})$ over the
facilities. In addition each client $j$ has a specified radius $r_j \ge 0$ and
each facility $i \in \mathcal{F}$ has an opening cost $f_i$. The goal is to
choose a subset $S \subseteq \mathcal{F}$ of facilities to minimize the
$\sum_{i \in \mathcal{F}} f_i + \sum_{j \in \mathcal{C}} d(j,S)$ subject to two
constraints: (i) $S$ is an independent set in $\mathcal{M}$ (that is $S \in
\mathcal{I}$) and (ii) for each client $j$, its distance to an open facility is
at most $r_j$ (that is, $d(j,S) \le r_j$). For this problem we describe the
first bicriteria $(c_1,c_2)$ approximations for fixed constants $c_1,c_2$: the
radius constraints of the clients are violated by at most a factor of $c_1$ and
the objective cost is at most $c_2$ times the optimum cost. We also improve the
previously known bicriteria approximation for the uniform radius setting ($r_j
:= L$ $\forall j \in \mathcal{C}$).
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-06T00:30:00Z">Thursday, October 06 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.01897'>The DAG Visit approach for Pebbling and I/O Lower Bounds</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Gianfranco Bilardi, Lorenzo De Stefani</p><p>We introduce the notion of an $r$-visit of a Directed Acyclic Graph DAG
$G=(V,E)$, a sequence of the vertices of the DAG complying with a given rule
$r$. A rule $r$ specifies for each vertex $v\in V$ a family of $r$-enabling
sets of (immediate) predecessors: before visiting $v$, at least one of its
enabling sets must have been visited. Special cases are the $r^{(top)}$-rule
(or, topological rule), for which the only enabling set is the set of all
predecessors and the $r^{(sin)}$-rule (or, singleton rule), for which the
enabling sets are the singletons containing exactly one predecessor. The
$r$-boundary complexity of a DAG $G$, $b_{r}\left(G\right)$, is the minimum
integer $b$ such that there is an $r$-visit where, at each stage, for at most
$b$ of the vertices yet to be visited an enabling set has already been visited.
By a reformulation of known results, it is shown that the boundary complexity
of a DAG $G$ is a lower bound to the pebbling number of the reverse DAG, $G^R$.
Several known pebbling lower bounds can be cast in terms of the
$r^{(sin)}$-boundary complexity.
</p>
<p>A visit partition technique for I/O lower bounds, which generalizes the
$S$-partition I/O technique introduced by Hong and Kung in their classic paper
"I/O complexity: The Red-Blue pebble game". The visit partition approach yields
tight I/O bounds for some DAGs for which the $S$-partition technique can only
yield an $\Omega(1)$ lower bound.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Bilardi_G/0/1/0/all/0/1">Gianfranco Bilardi</a>, <a href="http://arxiv.org/find/cs/1/au:+Stefani_L/0/1/0/all/0/1">Lorenzo De Stefani</a></p><p>We introduce the notion of an $r$-visit of a Directed Acyclic Graph DAG
$G=(V,E)$, a sequence of the vertices of the DAG complying with a given rule
$r$. A rule $r$ specifies for each vertex $v\in V$ a family of $r$-enabling
sets of (immediate) predecessors: before visiting $v$, at least one of its
enabling sets must have been visited. Special cases are the $r^{(top)}$-rule
(or, topological rule), for which the only enabling set is the set of all
predecessors and the $r^{(sin)}$-rule (or, singleton rule), for which the
enabling sets are the singletons containing exactly one predecessor. The
$r$-boundary complexity of a DAG $G$, $b_{r}\left(G\right)$, is the minimum
integer $b$ such that there is an $r$-visit where, at each stage, for at most
$b$ of the vertices yet to be visited an enabling set has already been visited.
By a reformulation of known results, it is shown that the boundary complexity
of a DAG $G$ is a lower bound to the pebbling number of the reverse DAG, $G^R$.
Several known pebbling lower bounds can be cast in terms of the
$r^{(sin)}$-boundary complexity.
</p>
<p>A visit partition technique for I/O lower bounds, which generalizes the
$S$-partition I/O technique introduced by Hong and Kung in their classic paper
"I/O complexity: The Red-Blue pebble game". The visit partition approach yields
tight I/O bounds for some DAGs for which the $S$-partition technique can only
yield an $\Omega(1)$ lower bound.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-06T00:30:00Z">Thursday, October 06 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.01954'>Rectangular Ruler Wrapping</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Xing Lyu, Travis Gagie</p><p>In 1985 Hopcroft, Joseph and Whitesides introduced the problem of folding a
carpenter's ruler with $n$ hinged segments of lengths $\ell_1, \ldots, \ell_n$
into an interval of a given length $k$. By {\em folding} we mean that each
hinge must be either straight or folded 180 degrees, with folded hinges
alternating between being folded clockwise and counterclockwise. They showed
this problem is NP-hard in the weak sense by a reduction from {\sc Partition},
gave a pseudo-polynomial-time algorithm for it, and gave an $O (n)$-time
2-approximation algorithm. Gagie, Saeidi and Sapucaia recently considered the
related problem of wrapping the ruler into the interval instead of folding it.
By {\em wrapping} we mean that all the folded hinges must be folded 180 degrees
clockwise. They gave an $O (n)$-time algorithm for this problem, based on the
$O (n \log n)$-time algorithm for {\sc Longest Increasing Subsequence} that
Fredman analyzed and attributed to Knuth, thus answering a question posed by
O'Rourke during the open-problems session of CCCG '21.
</p>
<p>Hopcroft et al.\ and Gagie et al.\ assume the ruler's segments are lines and
its hinges are points, so a folded ruler has length but zero width. As anyone
who has ever folded something knows, however, making perfect 180-degree folds
is not always possible. In this paper we initiate the study of {\em
rectangular} ruler wrapping, for which all folded hinges are to be folded 90
degrees clockwise instead of 180 degrees and we want the wrapped ruler to fit
in a rectangle of height $h$ and width $w$. We give a quartic algorithm and
then an $O (n^2\,\mathrm{polylog} (n))$-time algorithm.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Lyu_X/0/1/0/all/0/1">Xing Lyu</a>, <a href="http://arxiv.org/find/cs/1/au:+Gagie_T/0/1/0/all/0/1">Travis Gagie</a></p><p>In 1985 Hopcroft, Joseph and Whitesides introduced the problem of folding a
carpenter's ruler with $n$ hinged segments of lengths $\ell_1, \ldots, \ell_n$
into an interval of a given length $k$. By {\em folding} we mean that each
hinge must be either straight or folded 180 degrees, with folded hinges
alternating between being folded clockwise and counterclockwise. They showed
this problem is NP-hard in the weak sense by a reduction from {\sc Partition},
gave a pseudo-polynomial-time algorithm for it, and gave an $O (n)$-time
2-approximation algorithm. Gagie, Saeidi and Sapucaia recently considered the
related problem of wrapping the ruler into the interval instead of folding it.
By {\em wrapping} we mean that all the folded hinges must be folded 180 degrees
clockwise. They gave an $O (n)$-time algorithm for this problem, based on the
$O (n \log n)$-time algorithm for {\sc Longest Increasing Subsequence} that
Fredman analyzed and attributed to Knuth, thus answering a question posed by
O'Rourke during the open-problems session of CCCG '21.
</p>
<p>Hopcroft et al.\ and Gagie et al.\ assume the ruler's segments are lines and
its hinges are points, so a folded ruler has length but zero width. As anyone
who has ever folded something knows, however, making perfect 180-degree folds
is not always possible. In this paper we initiate the study of {\em
rectangular} ruler wrapping, for which all folded hinges are to be folded 90
degrees clockwise instead of 180 degrees and we want the wrapped ruler to fit
in a rectangle of height $h$ and width $w$. We give a quartic algorithm and
then an $O (n^2\,\mathrm{polylog} (n))$-time algorithm.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-06T00:30:00Z">Thursday, October 06 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.02000'>Internal Longest Palindrome Queries in Optimal Time</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Kazuki Mitani, Takuya Mieno, Kazuhisa Seto, Takashi Horiyama</p><p>Palindromes are strings that read the same forward and backward. Problems of
computing palindromic structures in strings have been studied for many years
with a motivation of their application to biology. The longest palindrome
problem is one of the most important and classical problems regarding
palindromic structures, that is, to compute the longest palindrome appearing in
a string $T$ of length $n$. The problem can be solved in $\mathcal{O}(n)$ time
by the famous algorithm of Manacher [Journal of the ACM, 1975]. In this paper,
we consider the problem in the internal model. The internal longest palindrome
query is, given a substring $T[i..j]$ of $T$ as a query, to compute the longest
palindrome appearing in $T[i.. j]$. The best known data structure for this
problem is the one proposed by Amir et al. [Algorithmica, 2020], which can
answer any query in $\mathcal{O}(\log n)$ time. In this paper, we propose a
linear-size data structure that can answer any internal longest palindrome
query in constant time. Also, given the input string $T$, our data structure
can be constructed in $\mathcal{O}(n)$ time.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Mitani_K/0/1/0/all/0/1">Kazuki Mitani</a>, <a href="http://arxiv.org/find/cs/1/au:+Mieno_T/0/1/0/all/0/1">Takuya Mieno</a>, <a href="http://arxiv.org/find/cs/1/au:+Seto_K/0/1/0/all/0/1">Kazuhisa Seto</a>, <a href="http://arxiv.org/find/cs/1/au:+Horiyama_T/0/1/0/all/0/1">Takashi Horiyama</a></p><p>Palindromes are strings that read the same forward and backward. Problems of
computing palindromic structures in strings have been studied for many years
with a motivation of their application to biology. The longest palindrome
problem is one of the most important and classical problems regarding
palindromic structures, that is, to compute the longest palindrome appearing in
a string $T$ of length $n$. The problem can be solved in $\mathcal{O}(n)$ time
by the famous algorithm of Manacher [Journal of the ACM, 1975]. In this paper,
we consider the problem in the internal model. The internal longest palindrome
query is, given a substring $T[i..j]$ of $T$ as a query, to compute the longest
palindrome appearing in $T[i.. j]$. The best known data structure for this
problem is the one proposed by Amir et al. [Algorithmica, 2020], which can
answer any query in $\mathcal{O}(\log n)$ time. In this paper, we propose a
linear-size data structure that can answer any internal longest palindrome
query in constant time. Also, given the input string $T$, our data structure
can be constructed in $\mathcal{O}(n)$ time.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-06T00:30:00Z">Thursday, October 06 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.02067'>Computing maximal generalized palindromes</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Mitsuru Funakoshi, Takuya Mieno, Yuto Nakashima, Shunsuke Inenaga, Hideo Bannai, Masayuki Takeda</p><p>Palindromes are popular and important objects in textual data processing,
bioinformatics, and combinatorics on words. Let $S = XaY$ be a string, where
$X$ and $Y$ are of the same length and $a$ is either a single character or the
empty string. Then, there exist two alternative definitions for palindromes:
$S$ is said to be a palindrome if: Reversal-based definition: $S$ is equal to
its reversal $S^R$; Symmetry-based definition: its left-arm $X$ is equal to the
reversal of its right-arm $Y^R$. It is clear that if the "equality" ($\approx$)
used in both definitions is exact character matching ($=$), then the two
definitions are the same. However, if we apply other string-equality criteria
$\approx$, including the complementary model for biological sequences, the
parameterized model [Baker, JCSS 1996], the order-preserving model [Kim et al.,
TCS 2014], the Cartesian-tree model [Park et al., TCS 2020], and the
palindromic-structure model [I et al., TCS 2013], then are the reversal-based
palindromes and the symmetry-based palindromes the same? To the best of our
knowledge, no previous work has considered or answered this natural question.
In this paper, we first provide answers to this question, and then present
efficient algorithms for computing all maximal generalized palindromes that
occur in a given string. After confirming that Gusfield's offline suffix-tree
based algorithm for computing maximal symmetry-based palindromes can be readily
extended to the aforementioned matching models, we show how to extend
Manacher's online algorithm for computing maximal reversal-based palindromes in
linear time for all the aforementioned matching models.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Funakoshi_M/0/1/0/all/0/1">Mitsuru Funakoshi</a>, <a href="http://arxiv.org/find/cs/1/au:+Mieno_T/0/1/0/all/0/1">Takuya Mieno</a>, <a href="http://arxiv.org/find/cs/1/au:+Nakashima_Y/0/1/0/all/0/1">Yuto Nakashima</a>, <a href="http://arxiv.org/find/cs/1/au:+Inenaga_S/0/1/0/all/0/1">Shunsuke Inenaga</a>, <a href="http://arxiv.org/find/cs/1/au:+Bannai_H/0/1/0/all/0/1">Hideo Bannai</a>, <a href="http://arxiv.org/find/cs/1/au:+Takeda_M/0/1/0/all/0/1">Masayuki Takeda</a></p><p>Palindromes are popular and important objects in textual data processing,
bioinformatics, and combinatorics on words. Let $S = XaY$ be a string, where
$X$ and $Y$ are of the same length and $a$ is either a single character or the
empty string. Then, there exist two alternative definitions for palindromes:
$S$ is said to be a palindrome if: Reversal-based definition: $S$ is equal to
its reversal $S^R$; Symmetry-based definition: its left-arm $X$ is equal to the
reversal of its right-arm $Y^R$. It is clear that if the "equality" ($\approx$)
used in both definitions is exact character matching ($=$), then the two
definitions are the same. However, if we apply other string-equality criteria
$\approx$, including the complementary model for biological sequences, the
parameterized model [Baker, JCSS 1996], the order-preserving model [Kim et al.,
TCS 2014], the Cartesian-tree model [Park et al., TCS 2020], and the
palindromic-structure model [I et al., TCS 2013], then are the reversal-based
palindromes and the symmetry-based palindromes the same? To the best of our
knowledge, no previous work has considered or answered this natural question.
In this paper, we first provide answers to this question, and then present
efficient algorithms for computing all maximal generalized palindromes that
occur in a given string. After confirming that Gusfield's offline suffix-tree
based algorithm for computing maximal symmetry-based palindromes can be readily
extended to the aforementioned matching models, we show how to extend
Manacher's online algorithm for computing maximal reversal-based palindromes in
linear time for all the aforementioned matching models.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-06T00:30:00Z">Thursday, October 06 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.02117'>Tight Lower Bounds for Problems Parameterized by Rank-width</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Benjamin Bergougnoux, Tuukka Korhonen, Jesper Nederlof</p><p>We show that there is no $2^{o(k^2)} n^{O(1)}$ time algorithm for Independent
Set on $n$-vertex graphs with rank-width $k$, unless the Exponential Time
Hypothesis (ETH) fails. Our lower bound matches the $2^{O(k^2)} n^{O(1)}$ time
algorithm given by Bui-Xuan, Telle, and Vatshelle [Discret.~Appl.~Math., 2010]
and it answers the open question of Bergougnoux and Kant\'{e} [SIAM J. Discret.
Math.,~2021]. We also show that the known $2^{O(k^2)} n^{O(1)}$ time algorithms
for Weighted Dominating Set, Maximum Induced Matching and Feedback Vertex Set
parameterized by rank-width $k$ are optimal assuming ETH. Our results are the
first tight ETH lower bounds parameterized by rank-width that do not follow
directly from lower bounds for $n$-vertex graphs.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Bergougnoux_B/0/1/0/all/0/1">Benjamin Bergougnoux</a>, <a href="http://arxiv.org/find/cs/1/au:+Korhonen_T/0/1/0/all/0/1">Tuukka Korhonen</a>, <a href="http://arxiv.org/find/cs/1/au:+Nederlof_J/0/1/0/all/0/1">Jesper Nederlof</a></p><p>We show that there is no $2^{o(k^2)} n^{O(1)}$ time algorithm for Independent
Set on $n$-vertex graphs with rank-width $k$, unless the Exponential Time
Hypothesis (ETH) fails. Our lower bound matches the $2^{O(k^2)} n^{O(1)}$ time
algorithm given by Bui-Xuan, Telle, and Vatshelle [Discret.~Appl.~Math., 2010]
and it answers the open question of Bergougnoux and Kant\'{e} [SIAM J. Discret.
Math.,~2021]. We also show that the known $2^{O(k^2)} n^{O(1)}$ time algorithms
for Weighted Dominating Set, Maximum Induced Matching and Feedback Vertex Set
parameterized by rank-width $k$ are optimal assuming ETH. Our results are the
first tight ETH lower bounds parameterized by rank-width that do not follow
directly from lower bounds for $n$-vertex graphs.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-06T00:30:00Z">Thursday, October 06 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.02292'>Double-Ended Palindromic Trees: A Linear-Time Data Structure and Its Applications</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Qisheng Wang, Ming Yang, Xinrui Zhu</p><p>The palindromic tree (a.k.a. eertree) is a linear-size data structure that
provides access to all palindromic substrings of a string. In this paper, we
propose a generalized version of eertree, called double-ended eertree, which
supports linear-time online double-ended queue operations on the stored string.
At the heart of our construction, is a class of substrings, called surfaces, of
independent interest. Namely, surfaces are neither prefixes nor suffixes of any
other palindromic substrings and characterize the link structure of all
palindromic substrings in the eertree.
</p>
<p>As an application, we develop a framework for range queries involving
palindromes on strings, including counting distinct palindromic substrings, and
finding the longest palindromic substring, shortest unique palindromic
substring and shortest absent palindrome of any substring. In particular,
offline queries only use linear space. Apart from range queries, we enumerate
palindromic rich strings with a given word in linear time on the length of the
given word.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Wang_Q/0/1/0/all/0/1">Qisheng Wang</a>, <a href="http://arxiv.org/find/cs/1/au:+Yang_M/0/1/0/all/0/1">Ming Yang</a>, <a href="http://arxiv.org/find/cs/1/au:+Zhu_X/0/1/0/all/0/1">Xinrui Zhu</a></p><p>The palindromic tree (a.k.a. eertree) is a linear-size data structure that
provides access to all palindromic substrings of a string. In this paper, we
propose a generalized version of eertree, called double-ended eertree, which
supports linear-time online double-ended queue operations on the stored string.
At the heart of our construction, is a class of substrings, called surfaces, of
independent interest. Namely, surfaces are neither prefixes nor suffixes of any
other palindromic substrings and characterize the link structure of all
palindromic substrings in the eertree.
</p>
<p>As an application, we develop a framework for range queries involving
palindromes on strings, including counting distinct palindromic substrings, and
finding the longest palindromic substring, shortest unique palindromic
substring and shortest absent palindrome of any substring. In particular,
offline queries only use linear space. Apart from range queries, we enumerate
palindromic rich strings with a given word in linear time on the length of the
given word.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-06T00:30:00Z">Thursday, October 06 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.02361'>The Power of Duality: Response Time Analysis meets Integer Programming</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Max A. Deppert, Klaus Jansen</p><p>We study a mutually enriching connection between response time analysis in
real-time systems and the mixing set problem. Thereby generalizing over known
results we present a new approach to the computation of response times in
fixed-priority uniprocessor real-time scheduling. We even allow that the tasks
are delayed by some period-constrained release jitter. By studying a dual
problem formulation of the decision problem as an integer linear program we
show that worst-case response times can be computed by algorithmically
exploiting a conditional reduction to an instance of the mixing set problem. In
the important case of harmonic periods our new technique admits a
near-quadratic algorithm to the exact computation of worst-case response times.
We show that generally, a smaller utilization leads to more efficient
algorithms even in fixed-priority scheduling. Our technique can be reversed to
solve the mixing set problem by computing worst-case response times to
associated real-time scheduling task systems. Finally, we also apply our
optimization technique to solve 4-block integer programs with simple objective
functions.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Deppert_M/0/1/0/all/0/1">Max A. Deppert</a>, <a href="http://arxiv.org/find/cs/1/au:+Jansen_K/0/1/0/all/0/1">Klaus Jansen</a></p><p>We study a mutually enriching connection between response time analysis in
real-time systems and the mixing set problem. Thereby generalizing over known
results we present a new approach to the computation of response times in
fixed-priority uniprocessor real-time scheduling. We even allow that the tasks
are delayed by some period-constrained release jitter. By studying a dual
problem formulation of the decision problem as an integer linear program we
show that worst-case response times can be computed by algorithmically
exploiting a conditional reduction to an instance of the mixing set problem. In
the important case of harmonic periods our new technique admits a
near-quadratic algorithm to the exact computation of worst-case response times.
We show that generally, a smaller utilization leads to more efficient
algorithms even in fixed-priority scheduling. Our technique can be reversed to
solve the mixing set problem by computing worst-case response times to
associated real-time scheduling task systems. Finally, we also apply our
optimization technique to solve 4-block integer programs with simple objective
functions.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-06T00:30:00Z">Thursday, October 06 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.02415'>A Fourier Approach to Mixture Learning</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Mingda Qiao, Guru Guruganesh, Ankit Singh Rawat, Kumar Avinava Dubey, Manzil Zaheer</p><p>We revisit the problem of learning mixtures of spherical Gaussians. Given
samples from mixture $\frac{1}{k}\sum_{j=1}^{k}\mathcal{N}(\mu_j, I_d)$, the
goal is to estimate the means $\mu_1, \mu_2, \ldots, \mu_k \in \mathbb{R}^d$ up
to a small error. The hardness of this learning problem can be measured by the
separation $\Delta$ defined as the minimum distance between all pairs of means.
Regev and Vijayaraghavan (2017) showed that with $\Delta = \Omega(\sqrt{\log
k})$ separation, the means can be learned using $\mathrm{poly}(k, d)$ samples,
whereas super-polynomially many samples are required if $\Delta = o(\sqrt{\log
k})$ and $d = \Omega(\log k)$. This leaves open the low-dimensional regime
where $d = o(\log k)$.
</p>
<p>In this work, we give an algorithm that efficiently learns the means in $d =
O(\log k/\log\log k)$ dimensions under separation $d/\sqrt{\log k}$ (modulo
doubly logarithmic factors). This separation is strictly smaller than
$\sqrt{\log k}$, and is also shown to be necessary. Along with the results of
Regev and Vijayaraghavan (2017), our work almost pins down the critical
separation threshold at which efficient parameter learning becomes possible for
spherical Gaussian mixtures. More generally, our algorithm runs in time
$\mathrm{poly}(k)\cdot f(d, \Delta, \epsilon)$, and is thus fixed-parameter
tractable in parameters $d$, $\Delta$ and $\epsilon$.
</p>
<p>Our approach is based on estimating the Fourier transform of the mixture at
carefully chosen frequencies, and both the algorithm and its analysis are
simple and elementary. Our positive results can be easily extended to learning
mixtures of non-Gaussian distributions, under a mild condition on the Fourier
spectrum of the distribution.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Qiao_M/0/1/0/all/0/1">Mingda Qiao</a>, <a href="http://arxiv.org/find/cs/1/au:+Guruganesh_G/0/1/0/all/0/1">Guru Guruganesh</a>, <a href="http://arxiv.org/find/cs/1/au:+Rawat_A/0/1/0/all/0/1">Ankit Singh Rawat</a>, <a href="http://arxiv.org/find/cs/1/au:+Dubey_K/0/1/0/all/0/1">Kumar Avinava Dubey</a>, <a href="http://arxiv.org/find/cs/1/au:+Zaheer_M/0/1/0/all/0/1">Manzil Zaheer</a></p><p>We revisit the problem of learning mixtures of spherical Gaussians. Given
samples from mixture $\frac{1}{k}\sum_{j=1}^{k}\mathcal{N}(\mu_j, I_d)$, the
goal is to estimate the means $\mu_1, \mu_2, \ldots, \mu_k \in \mathbb{R}^d$ up
to a small error. The hardness of this learning problem can be measured by the
separation $\Delta$ defined as the minimum distance between all pairs of means.
Regev and Vijayaraghavan (2017) showed that with $\Delta = \Omega(\sqrt{\log
k})$ separation, the means can be learned using $\mathrm{poly}(k, d)$ samples,
whereas super-polynomially many samples are required if $\Delta = o(\sqrt{\log
k})$ and $d = \Omega(\log k)$. This leaves open the low-dimensional regime
where $d = o(\log k)$.
</p>
<p>In this work, we give an algorithm that efficiently learns the means in $d =
O(\log k/\log\log k)$ dimensions under separation $d/\sqrt{\log k}$ (modulo
doubly logarithmic factors). This separation is strictly smaller than
$\sqrt{\log k}$, and is also shown to be necessary. Along with the results of
Regev and Vijayaraghavan (2017), our work almost pins down the critical
separation threshold at which efficient parameter learning becomes possible for
spherical Gaussian mixtures. More generally, our algorithm runs in time
$\mathrm{poly}(k)\cdot f(d, \Delta, \epsilon)$, and is thus fixed-parameter
tractable in parameters $d$, $\Delta$ and $\epsilon$.
</p>
<p>Our approach is based on estimating the Fourier transform of the mixture at
carefully chosen frequencies, and both the algorithm and its analysis are
simple and elementary. Our positive results can be easily extended to learning
mixtures of non-Gaussian distributions, under a mild condition on the Fourier
spectrum of the distribution.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-06T00:30:00Z">Thursday, October 06 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    
    <h2 class='new-date'>
      <i class='icon-calendar-empty'></i> Wednesday, October 05
    </h2>
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='https://cstheory-jobs.org/2022/10/05/assistant-teaching-professor-at-cse-at-uc-san-diego-apply-by-october-15-2022/'>Assistant Teaching Professor at CSE at UC San Diego (apply by October 15, 2022)</a></h3>
          <p class='item-feed'>from <a href='https://cstheory-jobs.org'>CCI: jobs</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          The University of California San Diego Computer Science and Engineering Department seeks applications for an Assistant Teaching Professor. We seek candidates who have demonstrated that they are promising CSE educators&#38; who are interested in a teaching-focused career. Applicants must have an expectation of completing a Ph.D. in computer science and/or CS education or a related [&#8230;]
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p>The University of California San Diego Computer Science and Engineering Department seeks applications for an Assistant Teaching Professor. We seek candidates who have demonstrated that they are promising CSE educators&amp; who are interested in a teaching-focused career. Applicants must have an expectation of completing a Ph.D. in computer science and/or CS education or a related area by July 1, 2023.</p>
<p>Website: <a href="https://apol-recruit.ucsd.edu/JPF03253">https://apol-recruit.ucsd.edu/JPF03253</a><br />
Email: nherrera@eng.ucsd.edu</p>
<p class="authors">By shacharlovett</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-05T22:46:11Z">Wednesday, October 05 2022, 22:46</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='https://eccc.weizmann.ac.il/report/2022/138'>TR22-138 |  Robustness for Space-Bounded Statistical Zero Knowledge | 

	Eric Allender, 

	Jacob Gray, 

	Saachi Mutreja, 

	Harsha Tirumala, 

	Pengxiang Wang</a></h3>
          <p class='item-feed'>from <a href='https://eccc.weizmann.ac.il/'>ECCC Papers</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          We show that the space-bounded Statistical Zero Knowledge classes SZK_L and NISZK_L are surprisingly robust, in that the power of the verifier and simulator can be strengthened or weakened without affecting the resulting class.  Coupled with other recent characterizations of these classes, this can be viewed as lending support to the conjecture that these classes may coincide with the non-space-bounded classes SZK and NISZK, respectively.
        
        </div>

        <div class='item-content item-summary'>
        
          
          We show that the space-bounded Statistical Zero Knowledge classes SZK_L and NISZK_L are surprisingly robust, in that the power of the verifier and simulator can be strengthened or weakened without affecting the resulting class.  Coupled with other recent characterizations of these classes, this can be viewed as lending support to the conjecture that these classes may coincide with the non-space-bounded classes SZK and NISZK, respectively.
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-05T18:48:31Z">Wednesday, October 05 2022, 18:48</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='https://tcsplus.wordpress.com/2022/10/05/tcs-talk-wednesday-october-12-venkatesan-guruswami-uc-berkeley/'>TCS+ talk: Wednesday, October 12 â Venkatesan Guruswami, UC Berkeley</a></h3>
          <p class='item-feed'>from <a href='https://tcsplus.wordpress.com'>TCS+ Seminar Series</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          The next TCS+ talk will take place this coming Wednesday, October 12th at 1:00 PM Eastern Time (10:00 AM Pacific Time, 19:00 Central European Time, 17:00 UTC). Venkatesan Guruswami from UC Berkeley will speak about &#8220;A near-cubic lower bound for 3-query locally decodable codes&#8221; (abstract below). You can reserve a spot as an individual or [&#8230;]
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p>The next TCS+ talk will take place this coming Wednesday, October 12th at 1:00 PM Eastern Time (10:00 AM Pacific Time, 19:00 Central European Time, 17:00 UTC). <strong>Venkatesan Guruswami</strong> from UC Berkeley will speak about &#8220;<em>A near-cubic lower bound for 3-query locally decodable codes</em>&#8221; (abstract below). </p>



<p>You can reserve a spot as an individual or a group to join us live by signing up on <a href="https://sites.google.com/view/tcsplus/welcome/next-tcs-talk">the online form</a>. Registration is <em>not</em> required to attend the interactive talk, and the link will be posted on the website the day prior to the talk; however, by registering in the form, you will receive a reminder, along with the link. (The recorded talk will also be posted <a href="https://sites.google.com/view/tcsplus/welcome/past-talks">on our website</a> afterwards) As usual, for more information about the TCS+ online seminar series and the upcoming talks, or to <a href="https://sites.google.com/view/tcsplus/welcome/suggest-a-talk">suggest</a> a possible topic or speaker, please see <a href="https://sites.google.com/view/tcsplus/">the website</a>.</p>



<blockquote class="wp-block-quote">
<p>Abstract: Locally decodable codes (LDCs) allow for ultra-efficient recovery of any single message symbol by querying very few symbols of the associated codeword, even in the presence of a constant fraction of errors. In addition to their appeal for storage and cryptographic applications, locality as a concept drives many connections between coding theory and computational complexity.</p>



<p>An outstanding challenge concerning LDCs is their optimal encoding length for a desired number q of queries. For q=2, it is known that exponential blow-up in encoding length is necessary (and the simple Hadamard code achieves this). For q &gt; 2, however, there are significant gaps in our understanding. For instance, for 3-query LDCs, the best known constructions have sub-exponential encoding length, whereas the best known lower bound, that has stood for two decades, was only quadratic.</p>



<p>In this talk, we will describe a near-cubic lower bound on the encoding length of 3-query LDCs. The approach is inspired by and borrows from recent advances in refuting semi-random instances of constraint satisfaction problems.</p>



<p>Joint work with Omar Alrabiah, Pravesh Kothari, and Peter Manohar.</p>
</blockquote>
<p class="authors">By plustcs</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-05T11:43:33Z">Wednesday, October 05 2022, 11:43</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='https://cstheory-jobs.org/2022/10/05/postdoc-at-iit-bombay-apply-by-november-1-2022/'>Postdoc  at IIT Bombay (apply by November 1, 2022)</a></h3>
          <p class='item-feed'>from <a href='https://cstheory-jobs.org'>CCI: jobs</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          We have two postdoc positions in the broad area of Algorithms, Complexity, and Cryptography. More about our research group can be found at www.cse.iitb.ac.in/~theory/. The positions can be for up to two years. Besides a competitive salary, it comes with a travel support for international and national conferences. To apply one needs to submit a [&#8230;]
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p>We have two postdoc positions in the broad area of Algorithms, Complexity, and Cryptography. More about our research group can be found at <a href="https://www.cse.iitb.ac.in/~theory/">https://www.cse.iitb.ac.in/~theory/</a>. The positions can be for up to two years. Besides a competitive salary, it comes with a travel support for international and national conferences. To apply one needs to submit a CV, a research statement and two references.</p>
<p>Website: <a href="https://www.iitb.ac.in/en/careers/institute-post-doctoral-fellows-recruitment">https://www.iitb.ac.in/en/careers/institute-post-doctoral-fellows-recruitment</a><br />
Email: rgurjar@cse.iitb.ac.in</p>
<p class="authors">By shacharlovett</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-05T07:11:42Z">Wednesday, October 05 2022, 07:11</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.01183'>Notions of Tensor Rank</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Mandar Juvekar, Arian Nadjimzadah</p><p>Tensors, or multi-linear forms, are important objects in a variety of areas
from analytics, to combinatorics, to computational complexity theory. Notions
of tensor rank aim to quantify the "complexity" of these forms, and are thus
also important. While there is one single definition of rank that completely
captures the complexity of matrices (and thus linear transformations), there is
no definitive analog for tensors. Rather, many notions of tensor rank have been
defined over the years, each with their own set of uses. In this paper we
survey the popular notions of tensor rank. We give a brief history of their
introduction, motivating their existence, and discuss some of their
applications in computer science. We also give proof sketches of recent results
by Lovett, and Cohen and Moshkovitz, which prove asymptotic equivalence between
three key notions of tensor rank over finite fields with at least three
elements.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Juvekar_M/0/1/0/all/0/1">Mandar Juvekar</a>, <a href="http://arxiv.org/find/cs/1/au:+Nadjimzadah_A/0/1/0/all/0/1">Arian Nadjimzadah</a></p><p>Tensors, or multi-linear forms, are important objects in a variety of areas
from analytics, to combinatorics, to computational complexity theory. Notions
of tensor rank aim to quantify the "complexity" of these forms, and are thus
also important. While there is one single definition of rank that completely
captures the complexity of matrices (and thus linear transformations), there is
no definitive analog for tensors. Rather, many notions of tensor rank have been
defined over the years, each with their own set of uses. In this paper we
survey the popular notions of tensor rank. We give a brief history of their
introduction, motivating their existence, and discuss some of their
applications in computer science. We also give proof sketches of recent results
by Lovett, and Cohen and Moshkovitz, which prove asymptotic equivalence between
three key notions of tensor rank over finite fields with at least three
elements.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-05T00:30:00Z">Wednesday, October 05 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.01598'>On the hull and interval numbers of oriented graphs</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: J. Araujo, A. K. Maia, P. P. Medeiros, L. Penso</p><p>In this work, for a given oriented graph $D$, we study its interval and hull
numbers, denoted by ${in}(D)$ and ${hn}(D)$, respectively, in the geodetic,
${P_3}$ and ${P_3^*}$ convexities. This last one, we believe to be formally
defined and first studied in this paper, although its undirected version is
well-known in the literature. Concerning bounds, for a strongly oriented graph
$D$, we prove that ${hn_g}(D)\leq m(D)-n(D)+2$ and that there is a strongly
oriented graph such that ${hn_g}(D) = m(D)-n(D)$. We also determine exact
values for the hull numbers in these three convexities for tournaments, which
imply polynomial-time algorithms to compute them. These results allows us to
deduce polynomial-time algorithms to compute ${hn_{P_3}}(D)$ when the
underlying graph of $D$ is split or cobipartite. Moreover, we provide a
meta-theorem by proving that if deciding whether ${in_g}(D)\leq k$ or
${hn_g}(D)\leq k$ is NP-hard or W[i]-hard parameterized by $k$, for some
$i\in\mathbb{Z_+^*}$, then the same holds even if the underlying graph of $D$
is bipartite. Next, we prove that deciding whether ${hn_{P_3}}(D)\leq k$ or
${hn_{P_3^*}}(D)\leq k$ is W[2]-hard parameterized by $k$, even if the
underlying graph of $D$ is bipartite; that deciding whether ${in_{P_3}}(D)\leq
k$ or ${in_{P_3^*}}(D)\leq k$ is NP-complete, even if $D$ has no directed
cycles and the underlying graph of $D$ is a chordal bipartite graph; and that
deciding whether ${in_{P_3}}(D)\leq k$ or ${in_{P_3^*}}(D)\leq k$ is W[2]-hard
parameterized by $k$, even if the underlying graph of $D$ is split. We also
argue that the interval and hull numbers in the oriented $P_3$ and $P_3^*$
convexities can be computed in polynomial time for graphs of bounded tree-width
by using Courcelle's theorem.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/math/1/au:+Araujo_J/0/1/0/all/0/1">J. Araujo</a>, <a href="http://arxiv.org/find/math/1/au:+Maia_A/0/1/0/all/0/1">A. K. Maia</a>, <a href="http://arxiv.org/find/math/1/au:+Medeiros_P/0/1/0/all/0/1">P. P. Medeiros</a>, <a href="http://arxiv.org/find/math/1/au:+Penso_L/0/1/0/all/0/1">L. Penso</a></p><p>In this work, for a given oriented graph $D$, we study its interval and hull
numbers, denoted by ${in}(D)$ and ${hn}(D)$, respectively, in the geodetic,
${P_3}$ and ${P_3^*}$ convexities. This last one, we believe to be formally
defined and first studied in this paper, although its undirected version is
well-known in the literature. Concerning bounds, for a strongly oriented graph
$D$, we prove that ${hn_g}(D)\leq m(D)-n(D)+2$ and that there is a strongly
oriented graph such that ${hn_g}(D) = m(D)-n(D)$. We also determine exact
values for the hull numbers in these three convexities for tournaments, which
imply polynomial-time algorithms to compute them. These results allows us to
deduce polynomial-time algorithms to compute ${hn_{P_3}}(D)$ when the
underlying graph of $D$ is split or cobipartite. Moreover, we provide a
meta-theorem by proving that if deciding whether ${in_g}(D)\leq k$ or
${hn_g}(D)\leq k$ is NP-hard or W[i]-hard parameterized by $k$, for some
$i\in\mathbb{Z_+^*}$, then the same holds even if the underlying graph of $D$
is bipartite. Next, we prove that deciding whether ${hn_{P_3}}(D)\leq k$ or
${hn_{P_3^*}}(D)\leq k$ is W[2]-hard parameterized by $k$, even if the
underlying graph of $D$ is bipartite; that deciding whether ${in_{P_3}}(D)\leq
k$ or ${in_{P_3^*}}(D)\leq k$ is NP-complete, even if $D$ has no directed
cycles and the underlying graph of $D$ is a chordal bipartite graph; and that
deciding whether ${in_{P_3}}(D)\leq k$ or ${in_{P_3^*}}(D)\leq k$ is W[2]-hard
parameterized by $k$, even if the underlying graph of $D$ is split. We also
argue that the interval and hull numbers in the oriented $P_3$ and $P_3^*$
convexities can be computed in polynomial time for graphs of bounded tree-width
by using Courcelle's theorem.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-05T00:30:00Z">Wednesday, October 05 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.01601'>Quantum communication complexity of linear regression</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Ashley Montanaro, Changpeng Shao</p><p>Dequantized algorithms show that quantum computers do not have exponential
speedups for many linear algebra problems in terms of time and query
complexity. In this work, we show that quantum computers can have exponential
speedups in terms of communication complexity for some fundamental linear
algebra problems. We mainly focus on solving linear regression and Hamiltonian
simulation. In the quantum case, the task is to prepare the quantum state of
the result. To allow for a fair comparison, in the classical case the task is
to sample from the result. We investigate these two problems in two-party and
multiparty models, propose near-optimal quantum protocols and prove
quantum/classical lower bounds. In this process, we propose an efficient
quantum protocol for quantum singular value transformation, which is a powerful
technique for designing quantum algorithms. As a result, for many linear
algebra problems where quantum computers lose exponential speedups in terms of
time and query complexity, it is possible to have exponential speedups in terms
of communication complexity.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/quant-ph/1/au:+Montanaro_A/0/1/0/all/0/1">Ashley Montanaro</a>, <a href="http://arxiv.org/find/quant-ph/1/au:+Shao_C/0/1/0/all/0/1">Changpeng Shao</a></p><p>Dequantized algorithms show that quantum computers do not have exponential
speedups for many linear algebra problems in terms of time and query
complexity. In this work, we show that quantum computers can have exponential
speedups in terms of communication complexity for some fundamental linear
algebra problems. We mainly focus on solving linear regression and Hamiltonian
simulation. In the quantum case, the task is to prepare the quantum state of
the result. To allow for a fair comparison, in the classical case the task is
to sample from the result. We investigate these two problems in two-party and
multiparty models, propose near-optimal quantum protocols and prove
quantum/classical lower bounds. In this process, we propose an efficient
quantum protocol for quantum singular value transformation, which is a powerful
technique for designing quantum algorithms. As a result, for many linear
algebra problems where quantum computers lose exponential speedups in terms of
time and query complexity, it is possible to have exponential speedups in terms
of communication complexity.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-05T00:30:00Z">Wednesday, October 05 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.01694'>The Complexity of Online Graph Games</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Janosch Fuchs, Christoph Gr&#xfc;ne, Tom Jan&#xdf;en</p><p>Online computation is a concept to model uncertainty where not all
information on a problem instance is known in advance. An online algorithm
receives requests which reveal the instance piecewise and has to respond with
irrevocable decisions. Often, an adversary is assumed that constructs the
instance knowing the deterministic behavior of the algorithm. From a game
theoretical point of view, the adversary and the online algorithm are players
in a two-player game. By applying this view on combinatorial graph problems,
especially on problems where the solution is a subset of the vertices, we
analyze their complexity. For this, we introduce a framework based on gadget
reductions from 3-Satisfiability and extend it to an online setting where the
graph is a priori known by a map. This is done by identifying a set of rules
for the reductions and providing schemes for gadgets. The extension of the
framework to the online setting enable reductions from TQBF. We provide example
reductions to the well-known problems Vertex Cover, Independent Set and
Dominating Set and prove that they are PSPACE-complete. Thus, this paper
establishes that the online version with a map of NP-complete graph problems
form a large class of PSPACE-complete problems.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Fuchs_J/0/1/0/all/0/1">Janosch Fuchs</a>, <a href="http://arxiv.org/find/cs/1/au:+Grune_C/0/1/0/all/0/1">Christoph Gr&#xfc;ne</a>, <a href="http://arxiv.org/find/cs/1/au:+Janssen_T/0/1/0/all/0/1">Tom Jan&#xdf;en</a></p><p>Online computation is a concept to model uncertainty where not all
information on a problem instance is known in advance. An online algorithm
receives requests which reveal the instance piecewise and has to respond with
irrevocable decisions. Often, an adversary is assumed that constructs the
instance knowing the deterministic behavior of the algorithm. From a game
theoretical point of view, the adversary and the online algorithm are players
in a two-player game. By applying this view on combinatorial graph problems,
especially on problems where the solution is a subset of the vertices, we
analyze their complexity. For this, we introduce a framework based on gadget
reductions from 3-Satisfiability and extend it to an online setting where the
graph is a priori known by a map. This is done by identifying a set of rules
for the reductions and providing schemes for gadgets. The extension of the
framework to the online setting enable reductions from TQBF. We provide example
reductions to the well-known problems Vertex Cover, Independent Set and
Dominating Set and prove that they are PSPACE-complete. Thus, this paper
establishes that the online version with a map of NP-complete graph problems
form a large class of PSPACE-complete problems.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-05T00:30:00Z">Wednesday, October 05 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.01173'>An Almost Singularly Optimal Asynchronous Distributed MST Algorithm</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Fabien Dufoulon, Shay Kutten, William K. Moses Jr., Gopal Pandurangan, David Peleg</p><p>A singularly (near) optimal distributed algorithm is one that is (near)
optimal in \emph{two} criteria, namely, its time and message complexities. For
\emph{synchronous} CONGEST networks, such algorithms are known for fundamental
distributed computing problems such as leader election [Kutten et al., JACM
2015] and Minimum Spanning Tree (MST) construction [Pandurangan et al., STOC
2017, Elkin, PODC 2017]. However, it is open whether a singularly (near)
optimal bound can be obtained for the MST construction problem in general
\emph{asynchronous} CONGEST networks.
</p>
<p>We present a randomized distributed MST algorithm that, with high
probability, computes an MST in \emph{asynchronous} CONGEST networks and takes
$\tilde{O}(D^{1+\epsilon} + \sqrt{n})$ time and $\tilde{O}(m)$ messages, where
$n$ is the number of nodes, $m$ the number of edges, $D$ is the diameter of the
network, and $\epsilon &gt;0$ is an arbitrarily small constant (both time and
message bounds hold with high probability). Our algorithm is message optimal
(up to a polylog$(n)$ factor) and almost time optimal (except for a
$D^{\epsilon}$ factor). Our result answers an open question raised in Mashregi
and King [DISC 2019] by giving the first known asynchronous MST algorithm that
has sublinear time (for all $D = O(n^{1-\epsilon})$) and uses $\tilde{O}(m)$
messages. Using a result of Mashregi and King [DISC 2019], this also yields the
first asynchronous MST algorithm that is sublinear in both time and messages in
the $KT_1$ CONGEST model.
</p>
<p>A key tool in our algorithm is the construction of a low diameter rooted
spanning tree in asynchronous CONGEST that has depth
$\tilde{O}(D^{1+\epsilon})$ (for an arbitrarily small constant $\epsilon &gt; 0$)
in $\tilde{O}(D^{1+\epsilon})$ time and $\tilde{O}(m)$ messages. To the best of
our knowledge, this is the first such construction that is almost singularly
optimal in the asynchronous setting.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Dufoulon_F/0/1/0/all/0/1">Fabien Dufoulon</a>, <a href="http://arxiv.org/find/cs/1/au:+Kutten_S/0/1/0/all/0/1">Shay Kutten</a>, <a href="http://arxiv.org/find/cs/1/au:+Moses_W/0/1/0/all/0/1">William K. Moses Jr.</a>, <a href="http://arxiv.org/find/cs/1/au:+Pandurangan_G/0/1/0/all/0/1">Gopal Pandurangan</a>, <a href="http://arxiv.org/find/cs/1/au:+Peleg_D/0/1/0/all/0/1">David Peleg</a></p><p>A singularly (near) optimal distributed algorithm is one that is (near)
optimal in \emph{two} criteria, namely, its time and message complexities. For
\emph{synchronous} CONGEST networks, such algorithms are known for fundamental
distributed computing problems such as leader election [Kutten et al., JACM
2015] and Minimum Spanning Tree (MST) construction [Pandurangan et al., STOC
2017, Elkin, PODC 2017]. However, it is open whether a singularly (near)
optimal bound can be obtained for the MST construction problem in general
\emph{asynchronous} CONGEST networks.
</p>
<p>We present a randomized distributed MST algorithm that, with high
probability, computes an MST in \emph{asynchronous} CONGEST networks and takes
$\tilde{O}(D^{1+\epsilon} + \sqrt{n})$ time and $\tilde{O}(m)$ messages, where
$n$ is the number of nodes, $m$ the number of edges, $D$ is the diameter of the
network, and $\epsilon &gt;0$ is an arbitrarily small constant (both time and
message bounds hold with high probability). Our algorithm is message optimal
(up to a polylog$(n)$ factor) and almost time optimal (except for a
$D^{\epsilon}$ factor). Our result answers an open question raised in Mashregi
and King [DISC 2019] by giving the first known asynchronous MST algorithm that
has sublinear time (for all $D = O(n^{1-\epsilon})$) and uses $\tilde{O}(m)$
messages. Using a result of Mashregi and King [DISC 2019], this also yields the
first asynchronous MST algorithm that is sublinear in both time and messages in
the $KT_1$ CONGEST model.
</p>
<p>A key tool in our algorithm is the construction of a low diameter rooted
spanning tree in asynchronous CONGEST that has depth
$\tilde{O}(D^{1+\epsilon})$ (for an arbitrarily small constant $\epsilon &gt; 0$)
in $\tilde{O}(D^{1+\epsilon})$ time and $\tilde{O}(m)$ messages. To the best of
our knowledge, this is the first such construction that is almost singularly
optimal in the asynchronous setting.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-05T00:30:00Z">Wednesday, October 05 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.01475'>Designing a parallel suffix sort</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Kunal Chowdhury</p><p>Suffix sort plays a critical role in various computational algorithms
including genomics as well as in frequently used day to day software
applications. The sorting algorithm becomes tricky when we have lot of repeated
characters in the string for a given radix. Various innovative implementations
are available in this area e.g., Manber Myers. We present here an analysis that
uses a concept around generalized polynomial factorization to sort these
suffixes. The initial generation of these substring specific polynomial can be
efficiently done using parallel threads and shared memory. The set of distinct
factors and their order are known beforehand, and this helps us to sort the
polynomials (equivalent of strings) accordingly.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Chowdhury_K/0/1/0/all/0/1">Kunal Chowdhury</a></p><p>Suffix sort plays a critical role in various computational algorithms
including genomics as well as in frequently used day to day software
applications. The sorting algorithm becomes tricky when we have lot of repeated
characters in the string for a given radix. Various innovative implementations
are available in this area e.g., Manber Myers. We present here an analysis that
uses a concept around generalized polynomial factorization to sort these
suffixes. The initial generation of these substring specific polynomial can be
efficiently done using parallel threads and shared memory. The set of distinct
factors and their order are known beforehand, and this helps us to sort the
polynomials (equivalent of strings) accordingly.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-05T00:30:00Z">Wednesday, October 05 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.01523'>Scheduling with Many Shared Resources</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Max A. Deppert, Klaus Jansen, Marten Maack, Simon Pukrop, Malin Rau</p><p>Consider the many shared resource scheduling problem where jobs have to be
scheduled on identical parallel machines with the goal of minimizing the
makespan. However, each job needs exactly one additional shared resource in
order to be executed and hence prevents the execution of jobs that need the
same resource while being processed. Previously a $(2m/(m+1))$-approximation
was the best known result for this problem. Furthermore, a $6/5$-approximation
for the case with only two machines was known as well as a PTAS for the case
with a constant number of machines. We present a simple and fast
5/3-approximation and a much more involved but still reasonable
1.5-approximation. Furthermore, we provide a PTAS for the case with only a
constant number of machines, which is arguably simpler and faster than the
previously known one, as well as a PTAS with resource augmentation for the
general case. The approximation schemes make use of the N-fold integer
programming machinery, which has found more and more applications in the field
of scheduling recently. It is plausible that the latter results can be improved
and extended to more general cases. Lastly, we give a $5/4 - \varepsilon$
inapproximability result for the natural problem extension where each job may
need up to a constant number (in particular $3$) of different resources.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Deppert_M/0/1/0/all/0/1">Max A. Deppert</a>, <a href="http://arxiv.org/find/cs/1/au:+Jansen_K/0/1/0/all/0/1">Klaus Jansen</a>, <a href="http://arxiv.org/find/cs/1/au:+Maack_M/0/1/0/all/0/1">Marten Maack</a>, <a href="http://arxiv.org/find/cs/1/au:+Pukrop_S/0/1/0/all/0/1">Simon Pukrop</a>, <a href="http://arxiv.org/find/cs/1/au:+Rau_M/0/1/0/all/0/1">Malin Rau</a></p><p>Consider the many shared resource scheduling problem where jobs have to be
scheduled on identical parallel machines with the goal of minimizing the
makespan. However, each job needs exactly one additional shared resource in
order to be executed and hence prevents the execution of jobs that need the
same resource while being processed. Previously a $(2m/(m+1))$-approximation
was the best known result for this problem. Furthermore, a $6/5$-approximation
for the case with only two machines was known as well as a PTAS for the case
with a constant number of machines. We present a simple and fast
5/3-approximation and a much more involved but still reasonable
1.5-approximation. Furthermore, we provide a PTAS for the case with only a
constant number of machines, which is arguably simpler and faster than the
previously known one, as well as a PTAS with resource augmentation for the
general case. The approximation schemes make use of the N-fold integer
programming machinery, which has found more and more applications in the field
of scheduling recently. It is plausible that the latter results can be improved
and extended to more general cases. Lastly, we give a $5/4 - \varepsilon$
inapproximability result for the natural problem extension where each job may
need up to a constant number (in particular $3$) of different resources.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-05T00:30:00Z">Wednesday, October 05 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.01560'>SicHash -- Small Irregular Cuckoo Tables for Perfect Hashing</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Hans-Peter Lehmann, Peter Sanders, Stefan Walzer</p><p>A Perfect Hash Function (PHF) is a hash function that has no collisions on a
given input set. PHFs can be used for space efficient storage of data in an
array, or for determining a compact representative of each object in the set.
In this paper, we present the PHF construction algorithm SicHash - Small
Irregular Cuckoo Tables for Perfect Hashing. At its core, SicHash uses a known
technique: It places objects in a cuckoo hash table and then stores the final
hash function choice of each object in a retrieval data structure. We combine
the idea with irregular cuckoo hashing, where each object has a different
number of hash functions. Additionally, we use many small tables that we
overload beyond their asymptotic maximum load factor. The most space efficient
competitors often use brute force methods to determine the PHFs. SicHash
provides a more direct construction algorithm that only rarely needs to
recompute parts. Our implementation improves the state of the art in terms of
space usage versus construction time for a wide range of configurations. At the
same time, it provides very fast queries.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Lehmann_H/0/1/0/all/0/1">Hans-Peter Lehmann</a>, <a href="http://arxiv.org/find/cs/1/au:+Sanders_P/0/1/0/all/0/1">Peter Sanders</a>, <a href="http://arxiv.org/find/cs/1/au:+Walzer_S/0/1/0/all/0/1">Stefan Walzer</a></p><p>A Perfect Hash Function (PHF) is a hash function that has no collisions on a
given input set. PHFs can be used for space efficient storage of data in an
array, or for determining a compact representative of each object in the set.
In this paper, we present the PHF construction algorithm SicHash - Small
Irregular Cuckoo Tables for Perfect Hashing. At its core, SicHash uses a known
technique: It places objects in a cuckoo hash table and then stores the final
hash function choice of each object in a retrieval data structure. We combine
the idea with irregular cuckoo hashing, where each object has a different
number of hash functions. Additionally, we use many small tables that we
overload beyond their asymptotic maximum load factor. The most space efficient
competitors often use brute force methods to determine the PHFs. SicHash
provides a more direct construction algorithm that only rarely needs to
recompute parts. Our implementation improves the state of the art in terms of
space usage versus construction time for a wide range of configurations. At the
same time, it provides very fast queries.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-05T00:30:00Z">Wednesday, October 05 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    
    <h2 class='new-date'>
      <i class='icon-calendar-empty'></i> Tuesday, October 04
    </h2>
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='https://scottaaronson.blog/?p=6739'>Two more shorties</a></h3>
          <p class='item-feed'>from <a href='https://scottaaronson.blog'>Scott Aaronson</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          For anyone living under a rock with no access to nerd social media, Alain Aspect, John Clauser, and Anton Zeilinger have finally won the Nobel Prize in Physics, for their celebrated experiments that rubbed everyone&#8217;s faces in the reality of quantum entanglement (including Bell inequality violation and quantum teleportation). I don&#8217;t personally know Aspect or [&#8230;]
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p>For anyone living under a rock with no access to nerd social media, Alain Aspect, John Clauser, and Anton Zeilinger have <a href="https://www.nobelprize.org/prizes/physics/2022/press-release/">finally won the Nobel Prize in Physics</a>, for their celebrated experiments that rubbed everyone&#8217;s faces in the reality of quantum entanglement (including Bell inequality violation and quantum teleportation).  I don&#8217;t personally know Aspect or Clauser, but Zeilinger <em>extremely</em> graciously hosted me and my wife Dana when we visited Vienna in 2012, even bringing us to the symphony (he knows the director and has front-row seats), and somehow making me feel more cultured rather than less.</p>



<p>As usual, the recipe for winning the Nobel Prize in Physics is this:</p>



<p>(1) Do something where anyone who knows about it is like, âwhy havenât they given the Nobel Prize in Physics for that yet?â</p>



<p>(2) Live long enough.</p>



<p>Huge congratulations to Aspect, Clauser, and Zeilinger!</p>



<hr class="wp-block-separator has-alpha-channel-opacity"/>



<p><a href="https://www.google.com/search?q=elham+kashefi">Elham Kashefi</a>, my quantum complexity theory colleague and treasured friend for more than 20 years, brought to my attention a <a href="https://docs.google.com/forms/d/e/1FAIpQLScAHNMbbvT9rWujs0Q_lQqiYz0jnx__tSVa7CQZyu3b4t8DXg/viewform">Statement of Solidarity with Students in Iran from the International Academic Community</a>.  Of course I was happy to sign the statement, just like I was <a href="https://scottaaronson.blog/?p=409">back in 2009</a> when brave Iranian students similarly risked their lives and freedom for women&#8217;s rights and other Enlightenment values against the theocracy.  I urge you to sign the statement as well.  If enough <em>Shtetl-Optimized</em> readers disapprove of their brutal repression, surely the mullahs will reconsider!  More seriously though: if any readers can recommend a charity that&#8217;s <em>actually making a difference</em> in helping Iranians participate in the modern world, I&#8217;d be happy to do another of my matching donation drives.</p>
<p class="authors">By Scott</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-04T16:36:13Z">Tuesday, October 04 2022, 16:36</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='https://cstheory-jobs.org/2022/10/04/phd-position-at-university-of-edinburgh-apply-by-october-31-2022/'>PhD Position at University of Edinburgh (apply by October 31, 2022)</a></h3>
          <p class='item-feed'>from <a href='https://cstheory-jobs.org'>CCI: jobs</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          Applications are invited for a PhD position in Economics and Computation at the School of Informatics of the University of Edinburgh, to work with Aris Filos-Ratsikas on topics related to game theory, fair division, social choice theory and computational complexity. Please use the supplied URL to apply. Feel free to contact Dr. Filos-Ratsikas directly for [&#8230;]
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p>Applications are invited for a PhD position in Economics and Computation at the School of Informatics of the University of Edinburgh, to work with Aris Filos-Ratsikas on topics related to game theory, fair division, social choice theory and computational complexity.</p>
<p>Please use the supplied URL to apply. Feel free to contact Dr. Filos-Ratsikas directly for additional information.</p>
<p>Website: <a href="https://www.findaphd.com/phds/project/phd-studentship-in-economics-and-computation/?p147391">https://www.findaphd.com/phds/project/phd-studentship-in-economics-and-computation/?p147391</a><br />
Email: Aris.Filos-Ratsikas@ed.ac.uk</p>
<p class="authors">By shacharlovett</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-04T14:08:37Z">Tuesday, October 04 2022, 14:08</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://blog.computationalcomplexity.org/2022/10/is-it-okay-for-paper-or-book-to-say-for.html'>Is it okay for a paper or book to say `for more on this topic see Wikipedia Entry BLAH.</a></h3>
          <p class='item-feed'>from <a href='http://blog.computationalcomplexity.org/'>Computational Complexity</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>&nbsp;One of the proofreaders for Computational Intractability: A Guide to Algorithmic Lower Bounds</p><p>(available&nbsp;here)</p><p>made the following objection, which raises some questions.</p><p>I object to telling readers to see a Wikipedia Entry.&nbsp; Wikipedia is marvelous, but it is unstable. I have been led astray by short-lived editorial changes made by trolls.&nbsp;</p><p>The proofreader is surely correct that&nbsp; `See Wikipedia entry X' should be minimized. And indeed, I have gone through all of the cases we had of such things and tried to minimize them. But there are times when there seems to be no way around it. Or maybe there is but I can't see it.&nbsp;</p><p>a) I want to refer to the set of problems that are (exists R)-complete. The ONLY list I know of is on Wikipedia&nbsp;here.</p><p>b) I want to discuss the complexity of the video game braid. There is a nice Wikipedia page about the game braid&nbsp;&nbsp;here. There are some sites that have videos about the game, but not reallyan&nbsp; explanations of it. I DID find a site that looks pretty good,&nbsp;here, but is that site more stable than the Wikipedia entry? There did not seem to be an official site. (I had the same issue with the 15-puzzle and some other puzzles that do not seem to have a natural official site).&nbsp;</p><p>c) I want to refer the reader to a list of algorithms for discrete log. Wikipedia has a great site on this&nbsp;here.&nbsp;Is there a good article that does the same? Is it behind paywalls?</p><p><br></p><p>I tend to thing that the&nbsp; Wikipedia sites above are stable and accurate. It helps that they are not on controversial topics.&nbsp; They should be fine. Articles that are behind paywalls are much worse. As for articles on authors websites- are they more or less stable than Wikipedia?</p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p>By gasarch</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p>&nbsp;One of the proofreaders for <i>Computational Intractability: A Guide to Algorithmic Lower Bounds</i></p><p>(available&nbsp;<a href="https://hardness.mit.edu/">here</a>)</p><p>made the following objection, which raises some questions.</p><p><i>I object to telling readers to see a Wikipedia Entry.&nbsp; Wikipedia is marvelous, but it is unstable. I have been led astray by short-lived editorial changes made by trolls.&nbsp;</i></p><p>The proofreader is surely correct that&nbsp; `See Wikipedia entry X' should be minimized. And indeed, I have gone through all of the cases we had of such things and tried to minimize them. But there are times when there seems to be no way around it. Or maybe there is but I can't see it.&nbsp;</p><p>a) I want to refer to the set of problems that are (exists R)-complete. The ONLY list I know of is on Wikipedia&nbsp;<a href="https://en.wikipedia.org/wiki/Existential_theory_of_the_reals">here</a>.</p><p>b) I want to discuss the complexity of the video game braid. There is a nice Wikipedia page about the game braid&nbsp;&nbsp;<a href="https://en.wikipedia.org/wiki/Braid_(video_game)">here</a>. There are some sites that have videos about the game, but not reallyan&nbsp; explanations of it. I DID find a site that looks pretty good,&nbsp;<a href="https://strategywiki.org/wiki/Braid">here</a>, but is that site more stable than the Wikipedia entry? There did not seem to be an official site. (I had the same issue with<a href="https://en.wikipedia.org/wiki/15_puzzle"> the 15-puzzle</a> and some other puzzles that do not seem to have a natural official site).&nbsp;</p><p>c) I want to refer the reader to a list of algorithms for discrete log. Wikipedia has a great site on this&nbsp;<a href="https://en.wikipedia.org/wiki/Discrete_logarithm">here</a>.&nbsp;Is there a good article that does the same? Is it behind paywalls?</p><p><br /></p><p>I tend to thing that the&nbsp; Wikipedia sites above are stable and accurate. It helps that they are not on controversial topics.&nbsp; They should be fine. Articles that are behind paywalls are much worse. As for articles on authors websites- are they more or less stable than Wikipedia?</p><p><br /></p><p><br /></p><p><i><br /></i></p><p><br /></p><p><span face="Arial, Helvetica, sans-serif" style="background-color: white; color: #222222; font-size: small;"><br /></span></p><p><br /></p><p class="authors">By gasarch</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-04T14:05:00Z">Tuesday, October 04 2022, 14:05</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='https://cstheory-jobs.org/2022/10/04/three-open-rank-tenure-track-faculty-positions-at-university-of-delaware-apply-by-november-15-2022/'>Three Open Rank Tenure-Track Faculty Positions at University of Delaware (apply by November 15, 2022)</a></h3>
          <p class='item-feed'>from <a href='https://cstheory-jobs.org'>CCI: jobs</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          The Department of Computer and Information Sciences at University of Delaware invites applications for an open rank tenure-track positions. Although there is a particular interest in computational biology/bioinformatics/comp materials, candidates in theory will be considered. Candidates in theory/algorithms with possible applications in these areas are especially encouraged to apply. Website: careers.udel.edu/en-us/filter/?search-keyword=&#38;brand=college%20of%20engineering&#38;category=computer%20%26%20information%20sciences&#38;job-mail-subscribe-privacy=agree Email: isafro@udel.edu
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p>The Department of Computer and Information Sciences at University of Delaware invites applications for an open rank tenure-track positions. Although there is a particular interest in computational biology/bioinformatics/comp materials, candidates in theory will be considered. Candidates in theory/algorithms with possible applications in these areas are especially encouraged to apply.</p>
<p>Website: <a href="https://careers.udel.edu/en-us/filter/?search-keyword=&amp;brand=college%20of%20engineering&amp;category=computer%20%26%20information%20sciences&amp;job-mail-subscribe-privacy=agree">https://careers.udel.edu/en-us/filter/?search-keyword=&amp;brand=college%20of%20engineering&amp;category=computer%20%26%20information%20sciences&amp;job-mail-subscribe-privacy=agree</a><br />
Email: isafro@udel.edu</p>
<p class="authors">By shacharlovett</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-04T04:00:21Z">Tuesday, October 04 2022, 04:00</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='https://cstheory-jobs.org/2022/10/04/faculty-at-university-of-iowa-apply-by-january-1-2023/'>Faculty at University of Iowa (apply by January 1, 2023)</a></h3>
          <p class='item-feed'>from <a href='https://cstheory-jobs.org'>CCI: jobs</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          The University of Iowa Computer Science Department invites applications for multiple tenure- and instructional-track positions effective August 2023. Algorithmic foundations is one of the priority areas in this search. Website: cs.uiowa.edu/jobs Email: sriram-pemmaraju@uiowa.edu
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p>The University of Iowa Computer Science Department invites applications for multiple tenure- and instructional-track positions effective August 2023. Algorithmic foundations is one of the priority areas in this search.</p>
<p>Website: <a href="https://cs.uiowa.edu/jobs">https://cs.uiowa.edu/jobs</a><br />
Email: sriram-pemmaraju@uiowa.edu</p>
<p class="authors">By shacharlovett</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-04T02:37:31Z">Tuesday, October 04 2022, 02:37</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.00123'>Multi-Robot Motion Planning for Unit Discs with Revolving Areas</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.CG/recent'>arXiv: Computational Geometry</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Pankaj K. Agarwal, Tzvika Geft, Dan Halperin, Erin Taylor</p><p>We study the problem of motion planning for a collection of $n$ labeled unit
disc robots in a polygonal environment. We assume that the robots have
\emph{revolving areas} around their start and final positions: that each start
and each final is contained in a radius $2$ disc lying in the free space, not
necessarily concentric with the start or final position, which is free from
other start or final positions. This assumption allows a \emph{weakly-monotone}
motion plan, in which robots move according to an ordering as follows: during
the turn of a robot $R$ in the ordering, it moves fully from its start to final
position, while other robots do not leave their revolving areas. As $R$ passes
through a revolving area, a robot $R'$ that is inside this area may move within
the revolving area to avoid a collision. Notwithstanding the existence of a
motion plan, we show that minimizing the total traveled distance in this
setting, specifically even when the motion plan is restricted to be
weakly-monotone, is APX-hard, ruling out any polynomial-time
$(1+\epsilon)$-approximation algorithm.
</p>
<p>On the positive side, we present the first constant-factor approximation
algorithm for computing a feasible weakly-monotone motion plan. The total
distance traveled by the robots is within an $O(1)$ factor of that of the
optimal motion plan, which need not be weakly monotone. Our algorithm extends
to an online setting in which the polygonal environment is fixed but the
initial and final positions of robots are specified in an online manner.
Finally, we observe that the overhead in the overall cost that we add while
editing the paths to avoid robot-robot collision can vary significantly
depending on the ordering we chose. Finding the best ordering in this respect
is known to be NP-hard, and we provide a polynomial time $O(\log n \log \log
n)$-approximation algorithm for this problem.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Agarwal_P/0/1/0/all/0/1">Pankaj K. Agarwal</a>, <a href="http://arxiv.org/find/cs/1/au:+Geft_T/0/1/0/all/0/1">Tzvika Geft</a>, <a href="http://arxiv.org/find/cs/1/au:+Halperin_D/0/1/0/all/0/1">Dan Halperin</a>, <a href="http://arxiv.org/find/cs/1/au:+Taylor_E/0/1/0/all/0/1">Erin Taylor</a></p><p>We study the problem of motion planning for a collection of $n$ labeled unit
disc robots in a polygonal environment. We assume that the robots have
\emph{revolving areas} around their start and final positions: that each start
and each final is contained in a radius $2$ disc lying in the free space, not
necessarily concentric with the start or final position, which is free from
other start or final positions. This assumption allows a \emph{weakly-monotone}
motion plan, in which robots move according to an ordering as follows: during
the turn of a robot $R$ in the ordering, it moves fully from its start to final
position, while other robots do not leave their revolving areas. As $R$ passes
through a revolving area, a robot $R'$ that is inside this area may move within
the revolving area to avoid a collision. Notwithstanding the existence of a
motion plan, we show that minimizing the total traveled distance in this
setting, specifically even when the motion plan is restricted to be
weakly-monotone, is APX-hard, ruling out any polynomial-time
$(1+\epsilon)$-approximation algorithm.
</p>
<p>On the positive side, we present the first constant-factor approximation
algorithm for computing a feasible weakly-monotone motion plan. The total
distance traveled by the robots is within an $O(1)$ factor of that of the
optimal motion plan, which need not be weakly monotone. Our algorithm extends
to an online setting in which the polygonal environment is fixed but the
initial and final positions of robots are specified in an online manner.
Finally, we observe that the overhead in the overall cost that we add while
editing the paths to avoid robot-robot collision can vary significantly
depending on the ordering we chose. Finding the best ordering in this respect
is known to be NP-hard, and we provide a polynomial time $O(\log n \log \log
n)$-approximation algorithm for this problem.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-04T00:30:00Z">Tuesday, October 04 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.00198'>Closed cap condition under the cap construction algorithm</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.CG/recent'>arXiv: Computational Geometry</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Mercedes Sandu, Shuyi Weng, Jade Zhang</p><p>Every polygon $P$ can be companioned by a cap polygon $\hat P$ such that $P$
and $\hat P$ serve as two parts of the boundary surface of a polyhedron $V$.
Pairs of vertices on $P$ and $\hat P$ are identified successively to become
vertices of $V$. In this paper, we study the cap construction that asserts
equal angular defects at these pairings. We exhibit a linear relation that
arises from the cap construction algorithm, which in turn demonstrates an
abundance of polygons that satisfy the closed cap condition, that is, those
that can successfully undergo the cap construction process.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Sandu_M/0/1/0/all/0/1">Mercedes Sandu</a>, <a href="http://arxiv.org/find/cs/1/au:+Weng_S/0/1/0/all/0/1">Shuyi Weng</a>, <a href="http://arxiv.org/find/cs/1/au:+Zhang_J/0/1/0/all/0/1">Jade Zhang</a></p><p>Every polygon $P$ can be companioned by a cap polygon $\hat P$ such that $P$
and $\hat P$ serve as two parts of the boundary surface of a polyhedron $V$.
Pairs of vertices on $P$ and $\hat P$ are identified successively to become
vertices of $V$. In this paper, we study the cap construction that asserts
equal angular defects at these pairings. We exhibit a linear relation that
arises from the cap construction algorithm, which in turn demonstrates an
abundance of polygons that satisfy the closed cap condition, that is, those
that can successfully undergo the cap construction process.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-04T00:30:00Z">Tuesday, October 04 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.00158'>Local and global expansion in random geometric graphs</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Siqi Liu, Sidhanth Mohanty, Tselil Schramm, Elizabeth Yang</p><p>Consider a random geometric 2-dimensional simplicial complex $X$ sampled as
follows: first, sample $n$ vectors $\boldsymbol{u_1},\ldots,\boldsymbol{u_n}$
uniformly at random on $\mathbb{S}^{d-1}$; then, for each triple $i,j,k \in
[n]$, add $\{i,j,k\}$ and all of its subsets to $X$ if and only if
$\langle{\boldsymbol{u_i},\boldsymbol{u_j}}\rangle \ge \tau,
\langle{\boldsymbol{u_i},\boldsymbol{u_k}}\rangle \ge \tau$, and $\langle
\boldsymbol{u_j}, \boldsymbol{u_k}\rangle \ge \tau$. We prove that for every
$\varepsilon &gt; 0$, there exists a choice of $d = \Theta(\log n)$ and $\tau =
\tau(\varepsilon,d)$ so that with high probability, $X$ is a high-dimensional
expander of average degree $n^\varepsilon$ in which each $1$-link has spectral
gap bounded away from $\frac{1}{2}$.
</p>
<p>To our knowledge, this is the first demonstration of a natural distribution
over $2$-dimensional expanders of arbitrarily small polynomial average degree
and spectral link expansion better than $\frac{1}{2}$. All previously known
constructions are algebraic. This distribution also furnishes an example of
simplicial complexes for which the trickle-down theorem is nearly tight.
</p>
<p>En route, we prove general bounds on the spectral expansion of random induced
subgraphs of arbitrary vertex transitive graphs, which may be of independent
interest. For example, one consequence is an almost-sharp bound on the second
eigenvalue of random $n$-vertex geometric graphs on $\mathbb{S}^{d-1}$, which
was previously unknown for most $n,d$ pairs.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/math/1/au:+Liu_S/0/1/0/all/0/1">Siqi Liu</a>, <a href="http://arxiv.org/find/math/1/au:+Mohanty_S/0/1/0/all/0/1">Sidhanth Mohanty</a>, <a href="http://arxiv.org/find/math/1/au:+Schramm_T/0/1/0/all/0/1">Tselil Schramm</a>, <a href="http://arxiv.org/find/math/1/au:+Yang_E/0/1/0/all/0/1">Elizabeth Yang</a></p><p>Consider a random geometric 2-dimensional simplicial complex $X$ sampled as
follows: first, sample $n$ vectors $\boldsymbol{u_1},\ldots,\boldsymbol{u_n}$
uniformly at random on $\mathbb{S}^{d-1}$; then, for each triple $i,j,k \in
[n]$, add $\{i,j,k\}$ and all of its subsets to $X$ if and only if
$\langle{\boldsymbol{u_i},\boldsymbol{u_j}}\rangle \ge \tau,
\langle{\boldsymbol{u_i},\boldsymbol{u_k}}\rangle \ge \tau$, and $\langle
\boldsymbol{u_j}, \boldsymbol{u_k}\rangle \ge \tau$. We prove that for every
$\varepsilon &gt; 0$, there exists a choice of $d = \Theta(\log n)$ and $\tau =
\tau(\varepsilon,d)$ so that with high probability, $X$ is a high-dimensional
expander of average degree $n^\varepsilon$ in which each $1$-link has spectral
gap bounded away from $\frac{1}{2}$.
</p>
<p>To our knowledge, this is the first demonstration of a natural distribution
over $2$-dimensional expanders of arbitrarily small polynomial average degree
and spectral link expansion better than $\frac{1}{2}$. All previously known
constructions are algebraic. This distribution also furnishes an example of
simplicial complexes for which the trickle-down theorem is nearly tight.
</p>
<p>En route, we prove general bounds on the spectral expansion of random induced
subgraphs of arbitrary vertex transitive graphs, which may be of independent
interest. For example, one consequence is an almost-sharp bound on the second
eigenvalue of random $n$-vertex geometric graphs on $\mathbb{S}^{d-1}$, which
was previously unknown for most $n,d$ pairs.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-04T00:30:00Z">Tuesday, October 04 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.00243'>An experimental study of algorithms for obtaining a singly connected subgraph</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Ahmed Zahloote, Al-hasan Saleh, Ayman Ghanem, Hiba Hasan, Asem Dreibaty, Ali Abodaraa, Nermeen Suleiman, Nour Naameh, Ali Ibrahim, Zeinab mahfoud</p><p>\begin{abstract}
</p>
<p>\normalsize{\noindent A directed graph $G = (V,E)$ is singly connected if for
any two vertices $v,u \in V$, the directed graph $G$ contains at most one
simple path from $v$ to $u$. In this paper, we study different algorithms to
find a feasible but necessarily optimal solution to the following problem.
Given a directed acyclic graph $G=(V,E)$, find a subset $H \subseteq E$ of
minimum size such that the subgraph $(V,E \setminus H)$ is singly connected.
Moreover, we prove that this problem can be solved in polynomial time for a
special kind of directed graphs.}
</p>
<p>\end{abstract}
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Zahloote_A/0/1/0/all/0/1">Ahmed Zahloote</a>, <a href="http://arxiv.org/find/cs/1/au:+Saleh_A/0/1/0/all/0/1">Al-hasan Saleh</a>, <a href="http://arxiv.org/find/cs/1/au:+Ghanem_A/0/1/0/all/0/1">Ayman Ghanem</a>, <a href="http://arxiv.org/find/cs/1/au:+Hasan_H/0/1/0/all/0/1">Hiba Hasan</a>, <a href="http://arxiv.org/find/cs/1/au:+Dreibaty_A/0/1/0/all/0/1">Asem Dreibaty</a>, <a href="http://arxiv.org/find/cs/1/au:+Abodaraa_A/0/1/0/all/0/1">Ali Abodaraa</a>, <a href="http://arxiv.org/find/cs/1/au:+Suleiman_N/0/1/0/all/0/1">Nermeen Suleiman</a>, <a href="http://arxiv.org/find/cs/1/au:+Naameh_N/0/1/0/all/0/1">Nour Naameh</a>, <a href="http://arxiv.org/find/cs/1/au:+Ibrahim_A/0/1/0/all/0/1">Ali Ibrahim</a>, <a href="http://arxiv.org/find/cs/1/au:+mahfoud_Z/0/1/0/all/0/1">Zeinab mahfoud</a></p><p>\begin{abstract}
</p>
<p>\normalsize{\noindent A directed graph $G = (V,E)$ is singly connected if for
any two vertices $v,u \in V$, the directed graph $G$ contains at most one
simple path from $v$ to $u$. In this paper, we study different algorithms to
find a feasible but necessarily optimal solution to the following problem.
Given a directed acyclic graph $G=(V,E)$, find a subset $H \subseteq E$ of
minimum size such that the subgraph $(V,E \setminus H)$ is singly connected.
Moreover, we prove that this problem can be solved in polynomial time for a
special kind of directed graphs.}
</p>
<p>\end{abstract}
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-04T00:30:00Z">Tuesday, October 04 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.00244'>On The Relative Error of Random Fourier Features for Preserving Kernel Distance</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Kuan Cheng, Shaofeng H.-C. Jiang, Luojian Wei, Zhide Wei</p><p>The method of random Fourier features (RFF), proposed in a seminal paper by
Rahimi and Recht (NIPS'07), is a powerful technique to find approximate
low-dimensional representations of points in (high-dimensional) kernel space,
for shift-invariant kernels. While RFF has been analyzed under various notions
of error guarantee, the ability to preserve the kernel distance with
\emph{relative} error is less understood. We show that for a significant range
of kernels, including the well-known Laplacian kernels, RFF cannot approximate
the kernel distance with small relative error using low dimensions. We
complement this by showing as long as the shift-invariant kernel is analytic,
RFF with $\mathrm{poly}(\epsilon^{-1} \log n)$ dimensions achieves
$\epsilon$-relative error for pairwise kernel distance of $n$ points, and the
dimension bound is improved to $\mathrm{poly}(\epsilon^{-1}\log k)$ for the
specific application of kernel $k$-means. Finally, going beyond RFF, we make
the first step towards data-oblivious dimension-reduction for general
shift-invariant kernels, and we obtain a similar $\mathrm{poly}(\epsilon^{-1}
\log n)$ dimension bound for Laplacian kernels. We also validate the
dimension-error tradeoff of our methods on simulated datasets, and they
demonstrate superior performance compared with other popular methods including
random-projection and Nystr\"{o}m methods.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Cheng_K/0/1/0/all/0/1">Kuan Cheng</a>, <a href="http://arxiv.org/find/cs/1/au:+Jiang_S/0/1/0/all/0/1">Shaofeng H.-C. Jiang</a>, <a href="http://arxiv.org/find/cs/1/au:+Wei_L/0/1/0/all/0/1">Luojian Wei</a>, <a href="http://arxiv.org/find/cs/1/au:+Wei_Z/0/1/0/all/0/1">Zhide Wei</a></p><p>The method of random Fourier features (RFF), proposed in a seminal paper by
Rahimi and Recht (NIPS'07), is a powerful technique to find approximate
low-dimensional representations of points in (high-dimensional) kernel space,
for shift-invariant kernels. While RFF has been analyzed under various notions
of error guarantee, the ability to preserve the kernel distance with
\emph{relative} error is less understood. We show that for a significant range
of kernels, including the well-known Laplacian kernels, RFF cannot approximate
the kernel distance with small relative error using low dimensions. We
complement this by showing as long as the shift-invariant kernel is analytic,
RFF with $\mathrm{poly}(\epsilon^{-1} \log n)$ dimensions achieves
$\epsilon$-relative error for pairwise kernel distance of $n$ points, and the
dimension bound is improved to $\mathrm{poly}(\epsilon^{-1}\log k)$ for the
specific application of kernel $k$-means. Finally, going beyond RFF, we make
the first step towards data-oblivious dimension-reduction for general
shift-invariant kernels, and we obtain a similar $\mathrm{poly}(\epsilon^{-1}
\log n)$ dimension bound for Laplacian kernels. We also validate the
dimension-error tradeoff of our methods on simulated datasets, and they
demonstrate superior performance compared with other popular methods including
random-projection and Nystr\"{o}m methods.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-04T00:30:00Z">Tuesday, October 04 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2210.00389'>A Novel Parallel Triangle Counting Algorithm with Reduced Communication</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: David A. Bader, Fuhuan Li, Anya Ganeshan, Ahmet Gundogdu, Jason Lew, Oliver Alvarado Rodriguez, Zhihui Du</p><p>Counting and finding triangles in graphs is often used in real-world
analytics for characterizing the cohesiveness and identifying communities in
graphs. In this paper, we present novel sequential and parallel triangle
counting algorithms based on identifying horizontal-edges in a breadth-first
search (BFS) traversal of the graph. The BFS allows our algorithm to
drastically reduce the number of edges examined for set intersections. Our new
approach is the first communication-optimal parallel algorithm that
asymptotically reduces the communication on massive graphs such as from real
social networks and synthetic graphs from the Graph500 Benchmark. In our
estimate from massive-scale Graph500 graphs, our new algorithms reduces the
communication by 21x on a scale 36 and by 176x on a scale 42. Because
communication is known to be the dominant cost of parallel triangle counting,
our new parallel algorithm, to our knowledge, is now the fastest method for
counting triangles in large graphs.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Bader_D/0/1/0/all/0/1">David A. Bader</a>, <a href="http://arxiv.org/find/cs/1/au:+Li_F/0/1/0/all/0/1">Fuhuan Li</a>, <a href="http://arxiv.org/find/cs/1/au:+Ganeshan_A/0/1/0/all/0/1">Anya Ganeshan</a>, <a href="http://arxiv.org/find/cs/1/au:+Gundogdu_A/0/1/0/all/0/1">Ahmet Gundogdu</a>, <a href="http://arxiv.org/find/cs/1/au:+Lew_J/0/1/0/all/0/1">Jason Lew</a>, <a href="http://arxiv.org/find/cs/1/au:+Rodriguez_O/0/1/0/all/0/1">Oliver Alvarado Rodriguez</a>, <a href="http://arxiv.org/find/cs/1/au:+Du_Z/0/1/0/all/0/1">Zhihui Du</a></p><p>Counting and finding triangles in graphs is often used in real-world
analytics for characterizing the cohesiveness and identifying communities in
graphs. In this paper, we present novel sequential and parallel triangle
counting algorithms based on identifying horizontal-edges in a breadth-first
search (BFS) traversal of the graph. The BFS allows our algorithm to
drastically reduce the number of edges examined for set intersections. Our new
approach is the first communication-optimal parallel algorithm that
asymptotically reduces the communication on massive graphs such as from real
social networks and synthetic graphs from the Graph500 Benchmark. In our
estimate from massive-scale Graph500 graphs, our new algorithms reduces the
communication by 21x on a scale 36 and by 176x on a scale 42. Because
communication is known to be the dominant cost of parallel triangle counting,
our new parallel algorithm, to our knowledge, is now the fastest method for
counting triangles in large graphs.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-04T00:30:00Z">Tuesday, October 04 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    
    <h2 class='new-date'>
      <i class='icon-calendar-empty'></i> Monday, October 03
    </h2>
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://aaronsadventures.blogspot.com/2022/10/batch-multivalid-conformal-prediction.html'>Batch Multivalid Conformal Prediction</a></h3>
          <p class='item-feed'>from <a href='http://aaronsadventures.blogspot.com/'>Aaron Roth</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>&nbsp;</p> <p>Our new paper gives very simple algorithms that promise "multivalid" conformal prediction sets for exchangable data. This means they are valid not just marginally, but also conditionally on (intersecting!) group membership, and in a threshold calibrated manner. I'll explain!</p> â¦<br><br><p>Instead of making point predictions, we can quantify uncertainty by producing "prediction sets" --- sets of labels that contain the true label with (say) 90% probability. The problem is, in a k label prediction problem, there are $2^k$ prediction sets. The curse of dimensionality!</p><br>  â¦<br><br>  <p>One of the great ideas of conformal prediction is that if we can find a good "non-conformity score" s(x,y) telling us how unusual a label y seems for features x, we can focus on a 1-parameter family of prediction sets $P(x, t) = \{y : s(x,y) &lt; t\}$. Now the problem is just to find $t$.</p><br> <p>The usual recipe in split conformal prediction is to use a holdout set of points (x,y) to find a $t$ such that $\Pr[s(x,y) \leq t] = 0.9$. Then over the randomness of new examples (x,y), we have that $\Pr[y \in P(x,t)] = 0.9$. This is a -marginal- guarantee: the randomness is over x and y.</p><p>&nbsp;</p> <p>Suppose we have a bunch of groups (subsets of the feature space) g that we think are prediction-relevant? g could record e.g. demographic or other attributes of people. We might want to promise $\Pr[y \in P(x,t) | x \in g] = 0.9$. Vanilla split conformal doesn't promise this.&nbsp;</p><p>&nbsp;</p> â¦<br><p><br><br></p><p>If the groups g are disjoint, you could use a different threshold $t_g$ for each group --- but what if a single example can be a member of multiple groups? You can be conservative and use the largest threshold $t_g$ among all groups g that x is a member of, but this will over-cover.</p><p>&nbsp;</p> <p>The first insight here is that it no longer suffices to find a single threshold $t$ --- we need to find a function f mapping examples to thresholds, and to consider prediction sets $P(x,f(x)) =\{y : s(x,y) &lt; f(x)\}$. The problem is to use a calibration set to train the function f.&nbsp;</p><p>&nbsp;</p><p>Our first algorithm is super simple and given any set of (intersecting!) groups G, trains f such that for every $g \in G$, we have that for new examples, $\Pr[y \in P(x,f(x))|g\in G] = 0.9$. How? f just minimizes pinball loss over linear combinations of group indicator functions $g \in G$.&nbsp;</p><br>â¦<br><p><br></p> <p>Now that we are using different thresholds f(x) for different x, you might worry that the threshold f(x) itself is correlated with coverage. To make sure its not, we can also ask for threshold calibration: $\Pr[y \in P(x,f(x)) | x \in g, f(x) = t] = 0.9$ for all $g \in G$ and all t.&nbsp;</p><br><p>Our second algorithm trains f so that it has both group conditional and threshold calibrated coverage - what we call "full multivalid" coverage. It is also simple: It iteratively finds pairs $(g,t)$ on which multivalid coverage is violated empirically, and corrects the violations.&nbsp;</p><br><p></p>â¦<br><br><p></p> <p>&nbsp;</p> <p>This is the batch analogueof what we did in our NeurIPS2022 paper in the sequential setting, which I wrote about here:&nbsp;&nbsp;aaronsadventures.blogspot.com/2022/06/practical-robust-and-equitable.html&nbsp;The sequential setting is more difficult in many respects (no need to assume exchangable data!) but it requires labels at test time. Our new algorithms don't.</p><p><br>Both algorithms are very performant, taking a coupleof seconds to train on thousands of points. Our first algorithm gets nearly perfect group conditional coverage on real datasets, and our second is never off by more than 1%, both improving significantly on baselines.</p> <p>&nbsp;</p> â¦<br><p><br><br>Our second algorithm gets better threshold calibration than our first (and compared to baselines), as expected. But perhaps surprisingly, our first algorithm performs quite well on calibration tests--- significantly beatingbaselines --- despiteno formal calibration guarantees.</p> <p>&nbsp;</p>â¦<br><p></p> <p><br>Our techniques come from the algorithmic fairness literature --- we train f to satisfy quantile analogues of multicalibration and multi-accuracy. If you haven'tbeen paying attention to algorithmic fairness, maybeyou should start--- there is interesting stuffgoing on there! Check out e.g. the Simons Collaboration on Algorithmic Fairness</p>  <br> <p>This is joint work with the excellent&nbsp;Chris Jung, Georgy Noarov, and Ramya Ramalingam.</p>â¦<br><p><br></p><p>Our paper is here: arxiv.org/abs/2209.15145&nbsp;and our code is here:&nbsp;github.com/ProgBelarus/BatchMultivalidConformal</p><p></p> <br> <p>&nbsp;</p><p>By Aaron</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p>&nbsp;</p><div class="WordSection1"> <p class="MsoTitle">Our new paper gives very simple algorithms that promise "multivalid" conformal prediction sets for exchangable data. This means they are valid not just marginally, but also conditionally on (intersecting!) group membership, and in a threshold calibrated manner. I'll explain!</p> <div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh3EKtKXuV99Nmc6HVriSK04I5m8lBmdIyLnkEFE_SsoT4jqQk0I3S8iLrYI-Lw29dbw22OU17Nr2oB0tF-wCTIPHWRZjU1JtGm_qTsOtxqVAGXTQVrsJne1U_LlC493uq-KZHmvIrTfuLKMufwqFhiEHLhMXD8lwLrs1epcqKOb2tHmnRv4Q/s1537/multivalidabstract.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="1317" data-original-width="1537" height="274" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh3EKtKXuV99Nmc6HVriSK04I5m8lBmdIyLnkEFE_SsoT4jqQk0I3S8iLrYI-Lw29dbw22OU17Nr2oB0tF-wCTIPHWRZjU1JtGm_qTsOtxqVAGXTQVrsJne1U_LlC493uq-KZHmvIrTfuLKMufwqFhiEHLhMXD8lwLrs1epcqKOb2tHmnRv4Q/s320/multivalidabstract.png" width="320" /></a></div><br /><div style="text-align: center;"><br /></div><p class="MsoBodyText" style="line-height: 143%; margin-bottom: 0in; margin-left: 29.35pt; margin-right: 35.55pt; margin-top: 5.3pt; margin: 5.3pt 35.55pt 0in 29.35pt;">Instead of making point predictions, we can quantify uncertainty by producing "prediction sets" --- sets of labels that contain the true label with (say) 90% probability. The problem is, in a k label prediction problem, there are $2^k$ prediction sets. The curse of dimensionality!</p><div><br /></div> </div> <div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhXZ28g9ua1ZIrtpLdSVI31ywp6_zVubYv6xiqFGBvbfqG87j35gd7fDg9BdQH9XWsfAVOctL7Fvd8uu33NQLVZF0KckbYym_L9PnCDWN9KChVCrXG0fQmbgcgyItO15Sw_Ad2GSrzLg17JAwPE53edn8gidmX73z4nzsKg5SewR4k6jROwAA/s1770/predictionsets.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="684" data-original-width="1770" height="124" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhXZ28g9ua1ZIrtpLdSVI31ywp6_zVubYv6xiqFGBvbfqG87j35gd7fDg9BdQH9XWsfAVOctL7Fvd8uu33NQLVZF0KckbYym_L9PnCDWN9KChVCrXG0fQmbgcgyItO15Sw_Ad2GSrzLg17JAwPE53edn8gidmX73z4nzsKg5SewR4k6jROwAA/s320/predictionsets.png" width="320" /></a></div><br /><span style="font-family: &quot;Georgia&quot;,serif; font-size: 11pt; line-height: 143%; mso-ansi-language: EN-US; mso-bidi-font-family: Georgia; mso-bidi-language: AR-SA; mso-fareast-font-family: Georgia; mso-fareast-language: EN-US;"><br clear="all" style="break-before: page; mso-break-type: section-break; page-break-before: always;" /></span> <div class="WordSection2"> <p class="MsoBodyText" style="line-height: 143%; margin-bottom: 0in; margin-left: 29.35pt; margin-right: 35.55pt; margin-top: 4.2pt; margin: 4.2pt 35.55pt 0in 29.35pt;">One of the great ideas of conformal prediction is that if we can find a good "non-conformity score" s(x,y) telling us how unusual a label y seems for features x, we can focus on a 1-parameter family of prediction sets $P(x, t) = \{y : s(x,y) &lt; t\}$. Now the problem is just to find $t$.</p><div><br /></div> <p class="MsoBodyText" style="line-height: 143%; margin-bottom: 0in; margin-left: 29.35pt; margin-right: 33.35pt; margin-top: .05pt; margin: 0.05pt 33.35pt 0in 29.35pt;">The usual recipe in split conformal prediction is to use a holdout set of points (x,y) to find a $t$ such that $\Pr[s(x,y) \leq t] = 0.9$. Then over the randomness of new examples (x,y), we have that $\Pr[y \in P(x,t)] = 0.9$. This is a -marginal- guarantee: the randomness is over x and y.</p><p class="MsoBodyText" style="line-height: 143%; margin-bottom: 0in; margin-left: 29.35pt; margin-right: 33.35pt; margin-top: .05pt; margin: 0.05pt 33.35pt 0in 29.35pt;"><span style="font-size: 8.5pt;">&nbsp;</span></p> <p class="MsoBodyText" style="line-height: 143%; margin-bottom: 0in; margin-left: 29.35pt; margin-right: 33.35pt; margin-top: 0in; margin: 0in 33.35pt 0in 29.35pt;">Suppose we have a bunch of groups (subsets of the feature space) g that we think are prediction-relevant? g could record e.g. demographic or other attributes of people. We might want to promise $\Pr[y \in P(x,t) | x \in g] = 0.9$. Vanilla split conformal doesn't promise this.&nbsp;</p><p class="MsoBodyText" style="line-height: 143%; margin-bottom: 0in; margin-left: 29.35pt; margin-right: 33.35pt; margin-top: 0in; margin: 0in 33.35pt 0in 29.35pt;"><span style="font-size: 8.5pt;">&nbsp;</span></p> <div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEisVkQNmcRBIeSOA-116B_i4Oc3mjytbm_1LNtF4E-Q9rDTPV6yXDPK-UVXnfQxqH0bnDm09TEwnLrshka-uu5ubYsWtlxqM5s_0m8AqDhQ3XJlKhCUyJLkdnOgs2sYMrl55hUApFttjdPwWLl5oC80vl1pbFcCb8hBZvk6qsMtxx_hSJg3HQ/s794/groups.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="605" data-original-width="794" height="244" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEisVkQNmcRBIeSOA-116B_i4Oc3mjytbm_1LNtF4E-Q9rDTPV6yXDPK-UVXnfQxqH0bnDm09TEwnLrshka-uu5ubYsWtlxqM5s_0m8AqDhQ3XJlKhCUyJLkdnOgs2sYMrl55hUApFttjdPwWLl5oC80vl1pbFcCb8hBZvk6qsMtxx_hSJg3HQ/s320/groups.png" width="320" /></a></div><br /><p class="MsoBodyText" style="line-height: 142%; margin-bottom: 0in; margin-left: 29.35pt; margin-right: 35.55pt; margin-top: 0in; margin: 0in 35.55pt 0in 29.35pt;"><br /><br clear="ALL" style="mso-ignore: vglayout;" /></p><p class="MsoBodyText" style="line-height: 142%; margin-bottom: 0in; margin-left: 29.35pt; margin-right: 35.55pt; margin-top: 0in; margin: 0in 35.55pt 0in 29.35pt;">If the groups g are disjoint, you could use a different threshold $t_g$ for each group --- but what if a single example can be a member of multiple groups? You can be conservative and use the largest threshold $t_g$ among all groups g that x is a member of, but this will over-cover.</p><p class="MsoBodyText" style="margin-top: 0.55pt;"><span style="font-size: 10pt; mso-bidi-font-size: 9.0pt;"><o:p>&nbsp;</o:p></span></p> <p class="MsoBodyText" style="line-height: 141%; margin-bottom: 0in; margin-left: 29.35pt; margin-right: 35.55pt; margin-top: 5.25pt; margin: 5.25pt 35.55pt 0in 29.35pt;">The first insight here is that it no longer suffices to find a single threshold $t$ --- we need to find a function f mapping examples to thresholds, and to consider prediction sets $P(x,f(x)) =\{y : s(x,y) &lt; f(x)\}$. The problem is to use a calibration set to train the function f.&nbsp;</p><p class="MsoBodyText" style="line-height: 141%; margin-bottom: 0in; margin-left: 29.35pt; margin-right: 35.55pt; margin-top: 5.25pt; margin: 5.25pt 35.55pt 0in 29.35pt;"><span style="font-size: 7.5pt;">&nbsp;</span></p><p class="MsoBodyText" style="line-height: 143%; margin-bottom: 0in; margin-left: 29.35pt; margin-right: 32.05pt; margin-top: 5.3pt; margin: 5.3pt 32.05pt 0in 29.35pt;">Our first algorithm is super simple and given any set of (intersecting!) groups G, trains f such that for every $g \in G$, we have that for new examples, $\Pr[y \in P(x,f(x))|g\in G] = 0.9$. How? f just minimizes pinball loss over linear combinations of group indicator functions $g \in G$.&nbsp;</p><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi8JzcMlNLjaC3LAiu5YCW4uHHy8cvOh4Ue4T1V1pCslq3QNVH_IdAB61cAK64lvSQ_Gd03lMQF3lQLodUD0EypN4H1CEPe1gHfN0Q7KEmRtqCIsR1Si56jHRRDaqcg4r5QSlyB4TdR3z3mmXShBCN4wo4z8aHcepGwFII8ALsZ3gQlnY-4cA/s2394/alg1.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="554" data-original-width="2394" height="74" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi8JzcMlNLjaC3LAiu5YCW4uHHy8cvOh4Ue4T1V1pCslq3QNVH_IdAB61cAK64lvSQ_Gd03lMQF3lQLodUD0EypN4H1CEPe1gHfN0Q7KEmRtqCIsR1Si56jHRRDaqcg4r5QSlyB4TdR3z3mmXShBCN4wo4z8aHcepGwFII8ALsZ3gQlnY-4cA/s320/alg1.png" width="320" /></a></div><br /><p class="MsoBodyText" style="line-height: 143%; margin-bottom: 0in; margin-left: 29.35pt; margin-right: 32.05pt; margin-top: 5.3pt; margin: 5.3pt 32.05pt 0in 29.35pt;"><br /></p> <p class="MsoBodyText" style="line-height: 143%; margin-bottom: 0in; margin-left: 29.35pt; margin-right: 35.55pt; margin-top: 5.25pt; margin: 5.25pt 35.55pt 0in 29.35pt;">Now that we are using different thresholds f(x) for different x, you might worry that the threshold f(x) itself is correlated with coverage. To make sure its not, we can also ask for threshold calibration: $\Pr[y \in P(x,f(x)) | x \in g, f(x) = t] = 0.9$ for all $g \in G$ and all t.&nbsp;</p><div><br /></div></div><div class="WordSection3"><p class="MsoBodyText" style="line-height: 143%; margin-bottom: 0in; margin-left: 29.35pt; margin-right: 35.55pt; margin-top: 4.2pt; margin: 4.2pt 35.55pt 0in 29.35pt;"><span style="letter-spacing: -0.133333px;">Our second algorithm trains f so that it has both group conditional and threshold calibrated coverage - what we call "full multivalid" coverage. It is also simple: It iteratively finds pairs $(g,t)$ on which multivalid coverage is violated empirically, and corrects the violations.&nbsp;</span></p><div><br /></div><p class="MsoBodyText" style="line-height: 143%; margin-bottom: 0in; margin-left: 29.35pt; margin-right: 35.55pt; margin-top: 4.2pt; margin: 4.2pt 35.55pt 0in 29.35pt;"></p><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgHYwLrvyFFbgNPysBs_dWndxmHnu-6_RmtqALakp9Z5QcynlqWlJofTmlj_jxZGB0Y2Jcb8NOyppsr-j_qOlTCHZ06770aics97nYxTsjjOH-kZBS80hcO9gdLU9lV-UMHCQijjiGM5CQttlmFy8Gay-gZv9v9iaCIOF5ASRvCdZgKgOLWNA/s2401/alg2.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="960" data-original-width="2401" height="128" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgHYwLrvyFFbgNPysBs_dWndxmHnu-6_RmtqALakp9Z5QcynlqWlJofTmlj_jxZGB0Y2Jcb8NOyppsr-j_qOlTCHZ06770aics97nYxTsjjOH-kZBS80hcO9gdLU9lV-UMHCQijjiGM5CQttlmFy8Gay-gZv9v9iaCIOF5ASRvCdZgKgOLWNA/s320/alg2.png" width="320" /></a></div><br /><span style="mso-font-width: 105%;"><br /></span><p></p> <p class="MsoBodyText" style="margin-top: 0.55pt;"><span style="font-size: 10pt; mso-bidi-font-size: 9.0pt;"><o:p>&nbsp;</o:p></span></p> <p class="MsoBodyText" style="line-height: 141%; margin-bottom: 0in; margin-left: 29.35pt; margin-right: 35.55pt; margin-top: 5.25pt; margin: 5.25pt 35.55pt 0in 29.35pt;">This<span style="letter-spacing: -0.6pt;"> </span>is<span style="letter-spacing: -0.55pt;"> </span>the<span style="letter-spacing: -0.6pt;"> </span>batch<span style="letter-spacing: -0.55pt;"> </span>analogue<span style="letter-spacing: -0.55pt;"></span>of<span style="letter-spacing: -0.6pt;"> </span>what<span style="letter-spacing: -0.55pt;"> </span>we<span style="letter-spacing: -0.6pt;"> </span>did<span style="letter-spacing: -0.55pt;"> </span>in<span style="letter-spacing: -0.55pt;"> </span>our<span style="letter-spacing: -0.6pt;"> </span>NeurIPS<span style="letter-spacing: -0.55pt;"></span>2022<span style="letter-spacing: -0.6pt;"> </span>paper<span style="letter-spacing: -0.55pt;"> </span>in<span style="letter-spacing: -0.55pt;"> </span>the<span style="letter-spacing: -0.6pt;"> </span>sequential <span style="letter-spacing: -0.1pt;">setting, which I wrote about here:&nbsp;&nbsp;</span><span style="letter-spacing: -0.133333px;"><a href="https://aaronsadventures.blogspot.com/2022/06/practical-robust-and-equitable.html">https://aaronsadventures.blogspot.com/2022/06/practical-robust-and-equitable.html</a>&nbsp;</span><span style="letter-spacing: -0.1pt;">The</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">sequential</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">setting</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">is</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">more</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">difficult</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">in</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">many</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">respects</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">(no</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">need</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">to</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">assume</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">exchangable </span>data!) but it requires labels at test time. Our new algorithms don't.</p></div><div class="WordSection4"><p class="MsoBodyText" style="line-height: 143%; margin-bottom: 0in; margin-left: 29.35pt; margin-right: 35.55pt; margin-top: 4.2pt; margin: 4.2pt 35.55pt 0in 29.35pt;"><br clear="ALL" style="mso-ignore: vglayout;" /><span style="mso-font-width: 105%;">Both<span style="letter-spacing: -0.35pt;"> </span>algorithms<span style="letter-spacing: -0.35pt;"> </span>are<span style="letter-spacing: -0.35pt;"> </span>very<span style="letter-spacing: -0.35pt;"> </span>performant,<span style="letter-spacing: -0.35pt;"> </span>taking<span style="letter-spacing: -0.35pt;"> </span>a<span style="letter-spacing: -0.35pt;"> </span>couple<span style="letter-spacing: -0.35pt;"></span>of<span style="letter-spacing: -0.35pt;"> </span>seconds<span style="letter-spacing: -0.35pt;"> </span>to<span style="letter-spacing: -0.35pt;"> </span>train<span style="letter-spacing: -0.35pt;"> </span>on<span style="letter-spacing: -0.35pt;"> </span>thousands<span style="letter-spacing: -0.35pt;"> </span>of <span style="letter-spacing: -0.1pt;">points.</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">Our</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">first</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">algorithm</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">gets</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">nearly</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">perfect</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">group</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">conditional</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">coverage</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">on</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">real</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">datasets, </span>and<span style="letter-spacing: -0.1pt;"> </span>our<span style="letter-spacing: -0.1pt;"> </span>second<span style="letter-spacing: -0.1pt;"> </span>is<span style="letter-spacing: -0.1pt;"> </span>never<span style="letter-spacing: -0.1pt;"> </span>off<span style="letter-spacing: -0.1pt;"> </span>by<span style="letter-spacing: -0.1pt;"> </span>more<span style="letter-spacing: -0.1pt;"> </span>than<span style="letter-spacing: -0.1pt;"> </span>1%,<span style="letter-spacing: -0.1pt;"> </span>both<span style="letter-spacing: -0.1pt;"> </span>improving<span style="letter-spacing: -0.1pt;"> </span>significantly<span style="letter-spacing: -0.1pt;"> </span>on<span style="letter-spacing: -0.1pt;"> </span>baselines.</span><o:p></o:p></p> <p class="MsoBodyText" style="margin-top: 0.55pt;"><span style="font-size: 10pt; mso-bidi-font-size: 9.0pt;"><o:p>&nbsp;</o:p></span></p> <div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiIMmyM-Xs7OehV0bZrwvyCHZNuKGpau7oSpB-HgOZSTSJzxO867axlRNWNyw1-ljD9TAc7t8RcYfA6CVTvEQ3O18j4MXx9tMqa52rqIm00sWxMvi6zpgENv6BNwAP2RobfGd0t1qc5YLGg9ZkjObHzByiWPmMA_975aa9Y_4Ci5gwWYeIo8A/s2134/coverage.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="691" data-original-width="2134" height="104" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiIMmyM-Xs7OehV0bZrwvyCHZNuKGpau7oSpB-HgOZSTSJzxO867axlRNWNyw1-ljD9TAc7t8RcYfA6CVTvEQ3O18j4MXx9tMqa52rqIm00sWxMvi6zpgENv6BNwAP2RobfGd0t1qc5YLGg9ZkjObHzByiWPmMA_975aa9Y_4Ci5gwWYeIo8A/s320/coverage.png" width="320" /></a></div><br /><p class="MsoBodyText" style="line-height: 142%; margin-bottom: 0in; margin-left: 29.35pt; margin-right: 35.55pt; margin-top: 5.25pt; margin: 5.25pt 35.55pt 0in 29.35pt;"><br /><br clear="ALL" style="mso-ignore: vglayout;" /><span style="mso-font-width: 105%;">Our<span style="letter-spacing: -0.15pt;"> </span>second<span style="letter-spacing: -0.15pt;"> </span>algorithm<span style="letter-spacing: -0.15pt;"> </span>gets<span style="letter-spacing: -0.15pt;"> </span>better<span style="letter-spacing: -0.15pt;"> </span>threshold<span style="letter-spacing: -0.15pt;"> </span>calibration<span style="letter-spacing: -0.15pt;"> </span>than<span style="letter-spacing: -0.15pt;"> </span>our<span style="letter-spacing: -0.15pt;"> </span>first<span style="letter-spacing: -0.15pt;"> </span>(and<span style="letter-spacing: -0.15pt;"> </span>compared<span style="letter-spacing: -0.15pt;"> </span>to <span style="letter-spacing: -0.1pt;">baselines),</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">as</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">expected.</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">But</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">perhaps</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">surprisingly,</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">our</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">first</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">algorithm</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">performs</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">quite</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">well</span><span style="letter-spacing: -0.2pt;"> </span><span style="letter-spacing: -0.1pt;">on </span>calibration<span style="letter-spacing: -0.15pt;"> </span>tests<span style="letter-spacing: -0.15pt;"></span>---<span style="letter-spacing: -0.15pt;"> </span>significantly<span style="letter-spacing: -0.15pt;"> </span>beating<span style="letter-spacing: -0.15pt;"></span>baselines<span style="letter-spacing: -0.15pt;"> </span>---<span style="letter-spacing: -0.15pt;"> </span>despite<span style="letter-spacing: -0.15pt;"></span>no<span style="letter-spacing: -0.15pt;"> </span>formal<span style="letter-spacing: -0.15pt;"> </span>calibration <span style="letter-spacing: -0.1pt;">guarantees.</span></span><o:p></o:p></p> <p class="MsoBodyText" style="margin-top: 0.55pt;"><span style="font-size: 10pt; mso-bidi-font-size: 9.0pt;"><o:p>&nbsp;</o:p></span></p><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhs4s-a1gUCk87Lv9LdRRAsj4x-7rGlttiAAtV1D8cFpBsQYjZMabwEQu7TXKQ3vfHNFWkJp0Ijajd-C_Wg6qjxEFoY43_Nu-U-PtPofaiXDR-s11bgMT27EzdBz4MR2nYrfnzQy3A2qCgoE-HUYINyJBEUiwHvNIJs11_S9812aA3-kih09w/s1037/quantilecalibration.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="707" data-original-width="1037" height="218" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhs4s-a1gUCk87Lv9LdRRAsj4x-7rGlttiAAtV1D8cFpBsQYjZMabwEQu7TXKQ3vfHNFWkJp0Ijajd-C_Wg6qjxEFoY43_Nu-U-PtPofaiXDR-s11bgMT27EzdBz4MR2nYrfnzQy3A2qCgoE-HUYINyJBEUiwHvNIJs11_S9812aA3-kih09w/s320/quantilecalibration.png" width="320" /></a></div><br /><p></p> <p class="MsoBodyText" style="line-height: 143%; margin-bottom: 0in; margin-left: 29.35pt; margin-right: 0in; margin-top: 5.25pt; margin: 5.25pt 0in 0in 29.35pt;"><span style="letter-spacing: -0.1pt; mso-font-width: 105%;"><br />Our</span><span style="letter-spacing: -0.15pt; mso-font-width: 105%;"> </span><span style="letter-spacing: -0.1pt; mso-font-width: 105%;">techniques</span><span style="letter-spacing: -0.15pt; mso-font-width: 105%;"> </span><span style="letter-spacing: -0.1pt; mso-font-width: 105%;">come</span><span style="letter-spacing: -0.15pt; mso-font-width: 105%;"> </span><span style="letter-spacing: -0.1pt; mso-font-width: 105%;">from</span><span style="letter-spacing: -0.15pt; mso-font-width: 105%;"> </span><span style="letter-spacing: -0.1pt; mso-font-width: 105%;">the</span><span style="letter-spacing: -0.15pt; mso-font-width: 105%;"> </span><span style="letter-spacing: -0.1pt; mso-font-width: 105%;">algorithmic</span><span style="letter-spacing: -0.15pt; mso-font-width: 105%;"> </span><span style="letter-spacing: -0.1pt; mso-font-width: 105%;">fairness</span><span style="letter-spacing: -0.15pt; mso-font-width: 105%;"> </span><span style="letter-spacing: -0.1pt; mso-font-width: 105%;">literature</span><span style="letter-spacing: -0.15pt; mso-font-width: 105%;"> </span><span style="letter-spacing: -0.1pt; mso-font-width: 105%;">---</span><span style="letter-spacing: -0.15pt; mso-font-width: 105%;"> </span><span style="letter-spacing: -0.1pt; mso-font-width: 105%;">we</span><span style="letter-spacing: -0.15pt; mso-font-width: 105%;"> </span><span style="letter-spacing: -0.1pt; mso-font-width: 105%;">train</span><span style="letter-spacing: -0.15pt; mso-font-width: 105%;"> </span><span style="letter-spacing: -0.1pt; mso-font-width: 105%;">f</span><span style="letter-spacing: -0.15pt; mso-font-width: 105%;"> </span><span style="letter-spacing: -0.1pt; mso-font-width: 105%;">to</span><span style="letter-spacing: -0.15pt; mso-font-width: 105%;"> </span><span style="letter-spacing: -0.1pt; mso-font-width: 105%;">satisfy</span><span style="letter-spacing: -0.15pt; mso-font-width: 105%;"> </span><span style="letter-spacing: -0.1pt; mso-font-width: 105%;">quantile </span>analogues<span style="letter-spacing: -0.15pt;"> </span>of<span style="letter-spacing: -0.15pt;"> </span>multicalibration<span style="letter-spacing: -0.15pt;"> </span>and<span style="letter-spacing: -0.15pt;"> </span>multi-accuracy.<span style="letter-spacing: -0.15pt;"> </span>If<span style="letter-spacing: -0.15pt;"> </span>you<span style="letter-spacing: -0.15pt;"> </span>haven't<span style="letter-spacing: -0.15pt;"></span>been<span style="letter-spacing: -0.15pt;"> </span>paying<span style="letter-spacing: -0.15pt;"> </span>attention<span style="letter-spacing: -0.15pt;"> </span>to algorithmic<span style="letter-spacing: -0.15pt;"> </span>fairness,<span style="letter-spacing: -0.15pt;"> </span>maybe<span style="letter-spacing: -0.15pt;"></span>you<span style="letter-spacing: -0.15pt;"> </span>should<span style="letter-spacing: -0.15pt;"> </span>start<span style="letter-spacing: -0.15pt;"></span>---<span style="letter-spacing: -0.15pt;"> </span>there<span style="letter-spacing: -0.15pt;"> </span>is<span style="letter-spacing: -0.15pt;"> </span>interesting<span style="letter-spacing: -0.15pt;"> </span>stuff<span style="letter-spacing: -0.15pt;"></span>going<span style="letter-spacing: -0.15pt;"> </span>on<span style="letter-spacing: -0.15pt;"> </span>there! Check out e.g. the <a href="https://toc4fairness.org/">Simons Collaboration on Algorithmic Fairness</a><o:p></o:p></p> </div> <span style="font-family: &quot;Georgia&quot;,serif; font-size: 11pt; line-height: 143%; mso-ansi-language: EN-US; mso-bidi-font-family: Georgia; mso-bidi-language: AR-SA; mso-fareast-font-family: Georgia; mso-fareast-language: EN-US;"><br clear="all" style="break-before: page; mso-break-type: section-break; page-break-before: always;" /></span> <p class="MsoBodyText" style="line-height: 141%; margin-bottom: 0in; margin-left: 29.35pt; margin-right: 32.05pt; margin-top: 4.2pt; margin: 4.2pt 32.05pt 0in 29.35pt;"><span style="letter-spacing: -0.1pt; mso-font-width: 105%;">This</span><span style="letter-spacing: -0.25pt; mso-font-width: 105%;"> </span><span style="letter-spacing: -0.1pt; mso-font-width: 105%;">is</span><span style="letter-spacing: -0.25pt; mso-font-width: 105%;"> </span><span style="letter-spacing: -0.1pt; mso-font-width: 105%;">joint</span><span style="letter-spacing: -0.25pt; mso-font-width: 105%;"> </span><span style="letter-spacing: -0.1pt; mso-font-width: 105%;">work</span><span style="letter-spacing: -0.25pt; mso-font-width: 105%;"> </span><span style="letter-spacing: -0.1pt; mso-font-width: 105%;">with</span><span style="letter-spacing: -0.25pt; mso-font-width: 105%;"> </span><span style="letter-spacing: -0.1pt; mso-font-width: 105%;">the</span><span style="letter-spacing: -0.25pt; mso-font-width: 105%;"> </span><span style="letter-spacing: -0.1pt; mso-font-width: 105%;">excellent</span><span style="letter-spacing: -0.333333px;">&nbsp;Chris Jung</span><span style="letter-spacing: -0.1pt; mso-font-width: 105%;">,</span><span style="letter-spacing: -0.25pt; mso-font-width: 105%;"> </span><span style="letter-spacing: -0.1pt; mso-font-width: 105%;">Georgy</span><span style="letter-spacing: -0.25pt; mso-font-width: 105%;"> </span><span style="letter-spacing: -0.1pt; mso-font-width: 105%;">Noarov,</span><span style="letter-spacing: -0.25pt; mso-font-width: 105%;"> </span><span style="letter-spacing: -0.1pt; mso-font-width: 105%;">and</span><span style="letter-spacing: -0.25pt; mso-font-width: 105%;"> </span><span style="letter-spacing: -0.1pt; mso-font-width: 105%;">Ramya</span><span style="letter-spacing: -0.25pt; mso-font-width: 105%;"> </span><span style="letter-spacing: -0.1pt; mso-font-width: 105%;">Ramalingam.</span></p><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg8-_Ambo1aG8-QpLWxzz-znP2pja9XCi2p9bnOtORWj6VtuZKaDEPbuKBem0BV6My-f1fG2hroXMIK4aR9gs4bRwcTOprGcX6r2sy01kkuaSQ7EFaGQTJPOARTz1gZTU2I8SbSrOaP5Yby1Z-wYiGAmoWHlddFvUAiAwBDsFV_5C0zsI2hDA/s1043/coauthors.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="366" data-original-width="1043" height="112" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg8-_Ambo1aG8-QpLWxzz-znP2pja9XCi2p9bnOtORWj6VtuZKaDEPbuKBem0BV6My-f1fG2hroXMIK4aR9gs4bRwcTOprGcX6r2sy01kkuaSQ7EFaGQTJPOARTz1gZTU2I8SbSrOaP5Yby1Z-wYiGAmoWHlddFvUAiAwBDsFV_5C0zsI2hDA/s320/coauthors.png" width="320" /></a></div><br /><p class="MsoBodyText" style="line-height: 141%; margin-bottom: 0in; margin-left: 29.35pt; margin-right: 32.05pt; margin-top: 4.2pt; margin: 4.2pt 32.05pt 0in 29.35pt;"><br /></p><p class="MsoBodyText" style="line-height: 141%; margin-bottom: 0in; margin-left: 29.35pt; margin-right: 32.05pt; margin-top: 4.2pt; margin: 4.2pt 32.05pt 0in 29.35pt;"><span style="letter-spacing: -0.1pt; mso-font-width: 105%;"></span>Our paper is here: <a href="https://arxiv.org/abs/2209.15145">https://arxiv.org/abs/2209.15145</a>&nbsp;and<span style="letter-spacing: -0.5pt;"> </span>our<span style="letter-spacing: -0.5pt;"> </span>code<span style="letter-spacing: -0.45pt;"> </span>is<span style="letter-spacing: -0.5pt;"> </span><span style="letter-spacing: -0.1pt;">here:&nbsp;</span><span style="letter-spacing: -0.133333px;"><a href="https://github.com/ProgBelarus/BatchMultivalidConformal">https://github.com/ProgBelarus/BatchMultivalidConformal</a></span></p><p class="MsoBodyText" style="margin-left: 29.35pt;"><o:p></o:p></p> <br /> <p class="MsoBodyText"><span style="font-size: 10pt; mso-bidi-font-size: 9.0pt;"><o:p>&nbsp;</o:p></span></p><p class="authors">By Aaron</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-03T19:07:00Z">Monday, October 03 2022, 19:07</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2209.15149'>Pure-Circuit: Strong Inapproximability for PPAD</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Argyrios Deligkas, John Fearnley, Alexandros Hollender, Themistoklis Melissourgos</p><p>The current state-of-the-art methods for showing inapproximability in PPAD
arise from the $\varepsilon$-Generalized-Circuit ($\varepsilon$-GCircuit)
problem. Rubinstein (2018) showed that there exists a small unknown constant
$\varepsilon$ for which $\varepsilon$-GCircuit is PPAD-hard, and subsequent
work has shown hardness results for other problems in PPAD by using
$\varepsilon$-GCircuit as an intermediate problem.
</p>
<p>We introduce Pure-Circuit, a new intermediate problem for PPAD, which can be
thought of as $\varepsilon$-GCircuit pushed to the limit as $\varepsilon
\rightarrow 1$, and we show that the problem is PPAD-complete. We then prove
that $\varepsilon$-GCircuit is PPAD-hard for all $\varepsilon &lt; 0.1$ by a
reduction from Pure-Circuit, and thus strengthen all prior work that has used
GCircuit as an intermediate problem from the existential-constant regime to the
large-constant regime.
</p>
<p>We show that stronger inapproximability results can be derived by reducing
directly from Pure-Circuit. In particular, we prove tight inapproximability
results for computing $\varepsilon$-well-supported Nash equilibria in
two-action polymatrix games, as well as for finding approximate equilibria in
threshold games.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Deligkas_A/0/1/0/all/0/1">Argyrios Deligkas</a>, <a href="http://arxiv.org/find/cs/1/au:+Fearnley_J/0/1/0/all/0/1">John Fearnley</a>, <a href="http://arxiv.org/find/cs/1/au:+Hollender_A/0/1/0/all/0/1">Alexandros Hollender</a>, <a href="http://arxiv.org/find/cs/1/au:+Melissourgos_T/0/1/0/all/0/1">Themistoklis Melissourgos</a></p><p>The current state-of-the-art methods for showing inapproximability in PPAD
arise from the $\varepsilon$-Generalized-Circuit ($\varepsilon$-GCircuit)
problem. Rubinstein (2018) showed that there exists a small unknown constant
$\varepsilon$ for which $\varepsilon$-GCircuit is PPAD-hard, and subsequent
work has shown hardness results for other problems in PPAD by using
$\varepsilon$-GCircuit as an intermediate problem.
</p>
<p>We introduce Pure-Circuit, a new intermediate problem for PPAD, which can be
thought of as $\varepsilon$-GCircuit pushed to the limit as $\varepsilon
\rightarrow 1$, and we show that the problem is PPAD-complete. We then prove
that $\varepsilon$-GCircuit is PPAD-hard for all $\varepsilon &lt; 0.1$ by a
reduction from Pure-Circuit, and thus strengthen all prior work that has used
GCircuit as an intermediate problem from the existential-constant regime to the
large-constant regime.
</p>
<p>We show that stronger inapproximability results can be derived by reducing
directly from Pure-Circuit. In particular, we prove tight inapproximability
results for computing $\varepsilon$-well-supported Nash equilibria in
two-action polymatrix games, as well as for finding approximate equilibria in
threshold games.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-03T00:30:00Z">Monday, October 03 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2209.15151'>Tight Inapproximability for Graphical Games</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Argyrios Deligkas, John Fearnley, Alexandros Hollender, Themistoklis Melissourgos</p><p>We provide a complete characterization for the computational complexity of
finding approximate equilibria in two-action graphical games. We consider the
two most well-studied approximation notions: $\varepsilon$-Nash equilibria
($\varepsilon$-NE) and $\varepsilon$-well-supported Nash equilibria
($\varepsilon$-WSNE), where $\varepsilon \in [0,1]$. We prove that computing an
$\varepsilon$-NE is PPAD-complete for any constant $\varepsilon &lt; 1/2$, while a
very simple algorithm (namely, letting all players mix uniformly between their
two actions) yields a $1/2$-NE. On the other hand, we show that computing an
$\varepsilon$-WSNE is PPAD-complete for any constant $\varepsilon &lt; 1$, while a
$1$-WSNE is trivial to achieve, because any strategy profile is a $1$-WSNE. All
of our lower bounds immediately also apply to graphical games with more than
two actions per player.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Deligkas_A/0/1/0/all/0/1">Argyrios Deligkas</a>, <a href="http://arxiv.org/find/cs/1/au:+Fearnley_J/0/1/0/all/0/1">John Fearnley</a>, <a href="http://arxiv.org/find/cs/1/au:+Hollender_A/0/1/0/all/0/1">Alexandros Hollender</a>, <a href="http://arxiv.org/find/cs/1/au:+Melissourgos_T/0/1/0/all/0/1">Themistoklis Melissourgos</a></p><p>We provide a complete characterization for the computational complexity of
finding approximate equilibria in two-action graphical games. We consider the
two most well-studied approximation notions: $\varepsilon$-Nash equilibria
($\varepsilon$-NE) and $\varepsilon$-well-supported Nash equilibria
($\varepsilon$-WSNE), where $\varepsilon \in [0,1]$. We prove that computing an
$\varepsilon$-NE is PPAD-complete for any constant $\varepsilon &lt; 1/2$, while a
very simple algorithm (namely, letting all players mix uniformly between their
two actions) yields a $1/2$-NE. On the other hand, we show that computing an
$\varepsilon$-WSNE is PPAD-complete for any constant $\varepsilon &lt; 1$, while a
$1$-WSNE is trivial to achieve, because any strategy profile is a $1$-WSNE. All
of our lower bounds immediately also apply to graphical games with more than
two actions per player.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-03T00:30:00Z">Monday, October 03 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2209.15275'>A Multivariate Complexity Analysis of Qualitative Reasoning Problems</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Leif Eriksson, Victor Lagerkvist</p><p>Qualitative reasoning is an important subfield of artificial intelligence
where one describes relationships with qualitative, rather than numerical,
relations. Many such reasoning tasks, e.g., Allen's interval algebra, can be
solved in $2^{O(n \cdot \log n)}$ time, but single-exponential running times
$2^{O(n)}$ are currently far out of reach. In this paper we consider
single-exponential algorithms via a multivariate analysis consisting of a
fine-grained parameter $n$ (e.g., the number of variables) and a coarse-grained
parameter $k$ expected to be relatively small. We introduce the classes FPE and
XE of problems solvable in $f(k) \cdot 2^{O(n)}$, respectively $f(k)^n$, time,
and prove several fundamental properties of these classes. We proceed by
studying temporal reasoning problems and (1) show that the Partially Ordered
Time problem of effective width $k$ is solvable in $16^{kn}$ time and is thus
included in XE, and (2) that the network consistency problem for Allen's
interval algebra with no interval overlapping with more than $k$ others is
solvable in $(2nk)^{2k} \cdot 2^{n}$ time and is included in FPE. Our
multivariate approach is in no way limited to these to specific problems and
may be a generally useful approach for obtaining single-exponential algorithms.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Eriksson_L/0/1/0/all/0/1">Leif Eriksson</a>, <a href="http://arxiv.org/find/cs/1/au:+Lagerkvist_V/0/1/0/all/0/1">Victor Lagerkvist</a></p><p>Qualitative reasoning is an important subfield of artificial intelligence
where one describes relationships with qualitative, rather than numerical,
relations. Many such reasoning tasks, e.g., Allen's interval algebra, can be
solved in $2^{O(n \cdot \log n)}$ time, but single-exponential running times
$2^{O(n)}$ are currently far out of reach. In this paper we consider
single-exponential algorithms via a multivariate analysis consisting of a
fine-grained parameter $n$ (e.g., the number of variables) and a coarse-grained
parameter $k$ expected to be relatively small. We introduce the classes FPE and
XE of problems solvable in $f(k) \cdot 2^{O(n)}$, respectively $f(k)^n$, time,
and prove several fundamental properties of these classes. We proceed by
studying temporal reasoning problems and (1) show that the Partially Ordered
Time problem of effective width $k$ is solvable in $16^{kn}$ time and is thus
included in XE, and (2) that the network consistency problem for Allen's
interval algebra with no interval overlapping with more than $k$ others is
solvable in $(2nk)^{2k} \cdot 2^{n}$ time and is included in FPE. Our
multivariate approach is in no way limited to these to specific problems and
may be a generally useful approach for obtaining single-exponential algorithms.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-03T00:30:00Z">Monday, October 03 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2209.15396'>Broadening the Complexity-theoretic Analysis of Manipulative Attacks in Group Identification</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Emil Junker</p><p>In the Group Identification problem, we are given a set of individuals and
are asked to identify a socially qualified subset among them. Each individual
in the set has an opinion about who should be considered socially qualified.
There are several different rules that can be used to determine the socially
qualified subset based on these mutual opinions. In a manipulative attack, an
outsider attempts to exploit the way the used rule works, with the goal of
changing the outcome of the selection process to their liking.
</p>
<p>In recent years, the complexity of group control and bribery based
manipulative attacks in Group Identification has been the subject of intense
research. However, the picture is far from complete, and there remain many open
questions related to what exactly makes certain problems hard, or certain rules
immune to some attacks.
</p>
<p>Supplementing previous results, we examine the complexity of group
microbribery on so-called protective problem instances; that is, instances
where all individuals from the constructive target set are already socially
qualified initially. In addition, we study a relaxed variant of group control
by deleting individuals for the consent rules, the consensus-start-respecting
rule, and the liberal-start-respecting rule. Based on existing literature, we
also formalize three new social rules of the iterative consensus type, and we
provide a comprehensive complexity-theoretic analysis of group control and
bribery problems for these rules.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Junker_E/0/1/0/all/0/1">Emil Junker</a></p><p>In the Group Identification problem, we are given a set of individuals and
are asked to identify a socially qualified subset among them. Each individual
in the set has an opinion about who should be considered socially qualified.
There are several different rules that can be used to determine the socially
qualified subset based on these mutual opinions. In a manipulative attack, an
outsider attempts to exploit the way the used rule works, with the goal of
changing the outcome of the selection process to their liking.
</p>
<p>In recent years, the complexity of group control and bribery based
manipulative attacks in Group Identification has been the subject of intense
research. However, the picture is far from complete, and there remain many open
questions related to what exactly makes certain problems hard, or certain rules
immune to some attacks.
</p>
<p>Supplementing previous results, we examine the complexity of group
microbribery on so-called protective problem instances; that is, instances
where all individuals from the constructive target set are already socially
qualified initially. In addition, we study a relaxed variant of group control
by deleting individuals for the consent rules, the consensus-start-respecting
rule, and the liberal-start-respecting rule. Based on existing literature, we
also formalize three new social rules of the iterative consensus type, and we
provide a comprehensive complexity-theoretic analysis of group control and
bribery problems for these rules.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-03T00:30:00Z">Monday, October 03 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2209.15410'>P vs NP</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.CC/recent'>arXiv: Computational Complexity</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Jian-Gang Tang</p><p>In this paper, we discuss the $\mathcal{NP}$ problem using the Henkin's
Theory and the Herbrand Theory in the first-order logic, and prove that
$\mathcal{P}$ is a proper subset of $\mathcal{NP}$.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Tang_J/0/1/0/all/0/1">Jian-Gang Tang</a></p><p>In this paper, we discuss the $\mathcal{NP}$ problem using the Henkin's
Theory and the Herbrand Theory in the first-order logic, and prove that
$\mathcal{P}$ is a proper subset of $\mathcal{NP}$.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-03T00:30:00Z">Monday, October 03 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2209.15574'>An improved algorithm for Generalized \v{C}ech complex construction</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.CG/recent'>arXiv: Computational Geometry</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Jie Chu, Mikael Vejdemo-Johansson, Ping Ji</p><p>In this paper, we present an algorithm that computes the generalized \v{C}ech
complex for a finite set of disks where each may have a different radius in 2D
space. An extension of this algorithm is also proposed for a set of balls in 3D
space with different radius.
</p>
<p>To compute a $k$-simplex, we leverage the computation performed in the round
of $(k-1)$-simplices such that we can reduce the number of potential candidates
to verify to improve the efficiency. An efficient verification method is
proposed to confirm if a $k$-simplex can be constructed on the basis of the
$(k-1)$-simplices. We demonstrate the performance with a comparison to some
closely related algorithms.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Chu_J/0/1/0/all/0/1">Jie Chu</a>, <a href="http://arxiv.org/find/cs/1/au:+Vejdemo_Johansson_M/0/1/0/all/0/1">Mikael Vejdemo-Johansson</a>, <a href="http://arxiv.org/find/cs/1/au:+Ji_P/0/1/0/all/0/1">Ping Ji</a></p><p>In this paper, we present an algorithm that computes the generalized \v{C}ech
complex for a finite set of disks where each may have a different radius in 2D
space. An extension of this algorithm is also proposed for a set of balls in 3D
space with different radius.
</p>
<p>To compute a $k$-simplex, we leverage the computation performed in the round
of $(k-1)$-simplices such that we can reduce the number of potential candidates
to verify to improve the efficiency. An efficient verification method is
proposed to confirm if a $k$-simplex can be constructed on the basis of the
$(k-1)$-simplices. We demonstrate the performance with a comparison to some
closely related algorithms.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-03T00:30:00Z">Monday, October 03 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2209.15219'>Optimal Query Complexities for Dynamic Trace Estimation</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: David P. Woodruff, Fred Zhang, Qiuyi Zhang</p><p>We consider the problem of minimizing the number of matrix-vector queries
needed for accurate trace estimation in the dynamic setting where our
underlying matrix is changing slowly, such as during an optimization process.
Specifically, for any $m$ matrices $A_1,...,A_m$ with consecutive differences
bounded in Schatten-$1$ norm by $\alpha$, we provide a novel binary tree
summation procedure that simultaneously estimates all $m$ traces up to
$\epsilon$ error with $\delta$ failure probability with an optimal query
complexity of $\widetilde{O}\left(m \alpha\sqrt{\log(1/\delta)}/\epsilon +
m\log(1/\delta)\right)$, improving the dependence on both $\alpha$ and $\delta$
from Dharangutte and Musco (NeurIPS, 2021). Our procedure works without
additional norm bounds on $A_i$ and can be generalized to a bound for the
$p$-th Schatten norm for $p \in [1,2]$, giving a complexity of
$\widetilde{O}\left(m \alpha\left(\sqrt{\log(1/\delta)}/\epsilon\right)^p +m
\log(1/\delta)\right)$.
</p>
<p>By using novel reductions to communication complexity and
information-theoretic analyses of Gaussian matrices, we provide matching lower
bounds for static and dynamic trace estimation in all relevant parameters,
including the failure probability. Our lower bounds (1) give the first tight
bounds for Hutchinson's estimator in the matrix-vector product model with
Frobenius norm error even in the static setting, and (2) are the first
unconditional lower bounds for dynamic trace estimation, resolving open
questions of prior work.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Woodruff_D/0/1/0/all/0/1">David P. Woodruff</a>, <a href="http://arxiv.org/find/cs/1/au:+Zhang_F/0/1/0/all/0/1">Fred Zhang</a>, <a href="http://arxiv.org/find/cs/1/au:+Zhang_Q/0/1/0/all/0/1">Qiuyi Zhang</a></p><p>We consider the problem of minimizing the number of matrix-vector queries
needed for accurate trace estimation in the dynamic setting where our
underlying matrix is changing slowly, such as during an optimization process.
Specifically, for any $m$ matrices $A_1,...,A_m$ with consecutive differences
bounded in Schatten-$1$ norm by $\alpha$, we provide a novel binary tree
summation procedure that simultaneously estimates all $m$ traces up to
$\epsilon$ error with $\delta$ failure probability with an optimal query
complexity of $\widetilde{O}\left(m \alpha\sqrt{\log(1/\delta)}/\epsilon +
m\log(1/\delta)\right)$, improving the dependence on both $\alpha$ and $\delta$
from Dharangutte and Musco (NeurIPS, 2021). Our procedure works without
additional norm bounds on $A_i$ and can be generalized to a bound for the
$p$-th Schatten norm for $p \in [1,2]$, giving a complexity of
$\widetilde{O}\left(m \alpha\left(\sqrt{\log(1/\delta)}/\epsilon\right)^p +m
\log(1/\delta)\right)$.
</p>
<p>By using novel reductions to communication complexity and
information-theoretic analyses of Gaussian matrices, we provide matching lower
bounds for static and dynamic trace estimation in all relevant parameters,
including the failure probability. Our lower bounds (1) give the first tight
bounds for Hutchinson's estimator in the matrix-vector product model with
Frobenius norm error even in the static setting, and (2) are the first
unconditional lower bounds for dynamic trace estimation, resolving open
questions of prior work.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-03T00:30:00Z">Monday, October 03 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2209.15220'>Assortment Optimization Under the Multivariate MNL Model</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Xin Chen, Jiachun Li, Menglong Li, Tiancheng Zhao, Yuan Zhou</p><p>We study an assortment optimization problem under a multi-purchase choice
model in which customers choose a bundle of up to one product from each of two
product categories. Different bundles have different utilities and the bundle
price is the summation of the prices of products in it. For the uncapacitated
setting where any set of products can be offered, we prove that this problem is
strongly NP-hard. We show that an adjusted-revenue-ordered assortment provides
a 1/2-approximation. Furthermore, we develop an approximation framework based
on a linear programming relaxation of the problem and obtain a
0.74-approximation algorithm. This approximation ratio almost matches the
integrality gap of the linear program, which is proven to be at most 0.75. For
the capacitated setting, we prove that there does not exist a constant-factor
approximation algorithm assuming the Exponential Time Hypothesis. The same
hardness result holds for settings with general bundle prices or more than two
categories. Finally, we conduct numerical experiments on randomly generated
problem instances. The average approximation ratios of our algorithms are over
99%.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Chen_X/0/1/0/all/0/1">Xin Chen</a>, <a href="http://arxiv.org/find/cs/1/au:+Li_J/0/1/0/all/0/1">Jiachun Li</a>, <a href="http://arxiv.org/find/cs/1/au:+Li_M/0/1/0/all/0/1">Menglong Li</a>, <a href="http://arxiv.org/find/cs/1/au:+Zhao_T/0/1/0/all/0/1">Tiancheng Zhao</a>, <a href="http://arxiv.org/find/cs/1/au:+Zhou_Y/0/1/0/all/0/1">Yuan Zhou</a></p><p>We study an assortment optimization problem under a multi-purchase choice
model in which customers choose a bundle of up to one product from each of two
product categories. Different bundles have different utilities and the bundle
price is the summation of the prices of products in it. For the uncapacitated
setting where any set of products can be offered, we prove that this problem is
strongly NP-hard. We show that an adjusted-revenue-ordered assortment provides
a 1/2-approximation. Furthermore, we develop an approximation framework based
on a linear programming relaxation of the problem and obtain a
0.74-approximation algorithm. This approximation ratio almost matches the
integrality gap of the linear program, which is proven to be at most 0.75. For
the capacitated setting, we prove that there does not exist a constant-factor
approximation algorithm assuming the Exponential Time Hypothesis. The same
hardness result holds for settings with general bundle prices or more than two
categories. Finally, we conduct numerical experiments on randomly generated
problem instances. The average approximation ratios of our algorithms are over
99%.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-03T00:30:00Z">Monday, October 03 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2209.15300'>Deterministic Performance Guarantees for Bidirectional BFS on Real-World Networks</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Thomas Bl&#xe4;sius, Marcus Wilhelm</p><p>A common technique to speed up shortest path queries in graphs is to use a
bidirectional search, i.e., performing a forward search from the start and a
backward search from the destination until a common vertex on a shortest path
is found. In practice, this has a tremendous impact on the performance on some
real-world networks, while it only seems to save a constant factor on other
types of networks. Even though finding shortest paths is a ubiquitous problem,
there are only few studies attempting to understand the apparently asymptotic
speedups on some networks, using average case analysis on certain models for
real-world networks.
</p>
<p>In this paper we give a new perspective on this, by analyzing deterministic
properties that permit theoretical analysis and that can easily be checked on
any particular instance. We prove that these parameters imply sublinear running
time for the bidirectional breadth-first search in several regimes, some of
which are tight. Moreover, we perform experiments on a large set of real-world
networks showing that our parameters capture the concept of practical running
time well.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Blasius_T/0/1/0/all/0/1">Thomas Bl&#xe4;sius</a>, <a href="http://arxiv.org/find/cs/1/au:+Wilhelm_M/0/1/0/all/0/1">Marcus Wilhelm</a></p><p>A common technique to speed up shortest path queries in graphs is to use a
bidirectional search, i.e., performing a forward search from the start and a
backward search from the destination until a common vertex on a shortest path
is found. In practice, this has a tremendous impact on the performance on some
real-world networks, while it only seems to save a constant factor on other
types of networks. Even though finding shortest paths is a ubiquitous problem,
there are only few studies attempting to understand the apparently asymptotic
speedups on some networks, using average case analysis on certain models for
real-world networks.
</p>
<p>In this paper we give a new perspective on this, by analyzing deterministic
properties that permit theoretical analysis and that can easily be checked on
any particular instance. We prove that these parameters imply sublinear running
time for the bidirectional breadth-first search in several regimes, some of
which are tight. Moreover, we perform experiments on a large set of real-world
networks showing that our parameters capture the concept of practical running
time well.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-03T00:30:00Z">Monday, October 03 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2209.15305'>Proportionally Fair Online Allocation of Public Goods with Predictions</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Siddhartha Banerjee, Vasilis Gkatzelis, Safwan Hossain, Billy Jin, Evi Micha, Nisarg Shah</p><p>We design online algorithms for the fair allocation of public goods to a set
of $N$ agents over a sequence of $T$ rounds and focus on improving their
performance using predictions. In the basic model, a public good arrives in
each round, the algorithm learns every agent's value for the good, and must
irrevocably decide the amount of investment in the good without exceeding a
total budget of $B$ across all rounds. The algorithm can utilize (potentially
inaccurate) predictions of each agent's total value for all the goods to
arrive. We measure the performance of the algorithm using a proportional
fairness objective, which informally demands that every group of agents be
rewarded in proportion to its size and the cohesiveness of its preferences.
</p>
<p>In the special case of binary agent preferences and a unit budget, we show
that $O(\log N)$ proportional fairness can be achieved without using any
predictions, and that this is optimal even if perfectly accurate predictions
were available. However, for general preferences and budget no algorithm can
achieve better than $\Theta(T/B)$ proportional fairness without predictions. We
show that algorithms with (reasonably accurate) predictions can do much better,
achieving $\Theta(\log (T/B))$ proportional fairness. We also extend this
result to a general model in which a batch of $L$ public goods arrive in each
round and achieve $O(\log (\min(N,L) \cdot T/B))$ proportional fairness. Our
exact bounds are parametrized as a function of the error in the predictions and
the performance degrades gracefully with increasing errors.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Banerjee_S/0/1/0/all/0/1">Siddhartha Banerjee</a>, <a href="http://arxiv.org/find/cs/1/au:+Gkatzelis_V/0/1/0/all/0/1">Vasilis Gkatzelis</a>, <a href="http://arxiv.org/find/cs/1/au:+Hossain_S/0/1/0/all/0/1">Safwan Hossain</a>, <a href="http://arxiv.org/find/cs/1/au:+Jin_B/0/1/0/all/0/1">Billy Jin</a>, <a href="http://arxiv.org/find/cs/1/au:+Micha_E/0/1/0/all/0/1">Evi Micha</a>, <a href="http://arxiv.org/find/cs/1/au:+Shah_N/0/1/0/all/0/1">Nisarg Shah</a></p><p>We design online algorithms for the fair allocation of public goods to a set
of $N$ agents over a sequence of $T$ rounds and focus on improving their
performance using predictions. In the basic model, a public good arrives in
each round, the algorithm learns every agent's value for the good, and must
irrevocably decide the amount of investment in the good without exceeding a
total budget of $B$ across all rounds. The algorithm can utilize (potentially
inaccurate) predictions of each agent's total value for all the goods to
arrive. We measure the performance of the algorithm using a proportional
fairness objective, which informally demands that every group of agents be
rewarded in proportion to its size and the cohesiveness of its preferences.
</p>
<p>In the special case of binary agent preferences and a unit budget, we show
that $O(\log N)$ proportional fairness can be achieved without using any
predictions, and that this is optimal even if perfectly accurate predictions
were available. However, for general preferences and budget no algorithm can
achieve better than $\Theta(T/B)$ proportional fairness without predictions. We
show that algorithms with (reasonably accurate) predictions can do much better,
achieving $\Theta(\log (T/B))$ proportional fairness. We also extend this
result to a general model in which a batch of $L$ public goods arrive in each
round and achieve $O(\log (\min(N,L) \cdot T/B))$ proportional fairness. Our
exact bounds are parametrized as a function of the error in the predictions and
the performance degrades gracefully with increasing errors.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-03T00:30:00Z">Monday, October 03 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2209.15416'>Optimal Efficiency-Envy Trade-Off via Optimal Transport</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Steven Yin, Christian Kroer</p><p>We consider the problem of allocating a distribution of items to $n$
recipients where each recipient has to be allocated a fixed, prespecified
fraction of all items, while ensuring that each recipient does not experience
too much envy. We show that this problem can be formulated as a variant of the
semi-discrete optimal transport (OT) problem, whose solution structure in this
case has a concise representation and a simple geometric interpretation. Unlike
existing literature that treats envy-freeness as a hard constraint, our
formulation allows us to \emph{optimally} trade off efficiency and envy
continuously. Additionally, we study the statistical properties of the space of
our OT based allocation policies by showing a polynomial bound on the number of
samples needed to approximate the optimal solution from samples. Our approach
is suitable for large-scale fair allocation problems such as the blood donation
matching problem, and we show numerically that it performs well on a prior
realistic data simulator.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/cs/1/au:+Yin_S/0/1/0/all/0/1">Steven Yin</a>, <a href="http://arxiv.org/find/cs/1/au:+Kroer_C/0/1/0/all/0/1">Christian Kroer</a></p><p>We consider the problem of allocating a distribution of items to $n$
recipients where each recipient has to be allocated a fixed, prespecified
fraction of all items, while ensuring that each recipient does not experience
too much envy. We show that this problem can be formulated as a variant of the
semi-discrete optimal transport (OT) problem, whose solution structure in this
case has a concise representation and a simple geometric interpretation. Unlike
existing literature that treats envy-freeness as a hard constraint, our
formulation allows us to \emph{optimally} trade off efficiency and envy
continuously. Additionally, we study the statistical properties of the space of
our OT based allocation policies by showing a polynomial bound on the number of
samples needed to approximate the optimal solution from samples. Our approach
is suitable for large-scale fair allocation problems such as the blood donation
matching problem, and we show numerically that it performs well on a prior
realistic data simulator.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-03T00:30:00Z">Monday, October 03 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='http://arxiv.org/abs/2209.15497'>Local dominance unveils clusters in networks</a></h3>
          <p class='item-feed'>from <a href='https://arxiv.org/list/cs.DS/recent'>arXiv: Data Structures and Algorithms</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          <p>Authors: Fan Shang, Bingsheng Chen, Paul Expert, Linyuan L&#xfc;, Ao Yang, H.Eugene Stanley, Renaud Lambiotte, Tim S.Evans, Ruiqi Li</p><p>Clusters or communities can provide a coarse-grained description of complex
systems at multiple scales, but their detection remains challenging in
practice. Community detection methods often define communities as dense
subgraphs, or subgraphs with few connections in-between, via concepts such as
the cut, conductance, or modularity. Here we consider another perspective built
on the notion of local dominance, where low-degree nodes are assigned to the
basin of influence of high-degree nodes, and design an efficient algorithm
based on local information. Local dominance gives rises to community centers,
and uncovers local hierarchies in the network. Community centers have a larger
degree than their neighbors and are sufficiently distant from other centers.
The strength of our framework is demonstrated on synthesized and empirical
networks with ground-truth community labels. The notion of local dominance and
the associated asymmetric relations between nodes are not restricted to
community detection, and can be utilised in clustering problems, as we
illustrate on networks derived from vector data.
</p>
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p class="arxiv-authors"><b>Authors:</b> <a href="http://arxiv.org/find/physics/1/au:+Shang_F/0/1/0/all/0/1">Fan Shang</a>, <a href="http://arxiv.org/find/physics/1/au:+Chen_B/0/1/0/all/0/1">Bingsheng Chen</a>, <a href="http://arxiv.org/find/physics/1/au:+Expert_P/0/1/0/all/0/1">Paul Expert</a>, <a href="http://arxiv.org/find/physics/1/au:+Lu_L/0/1/0/all/0/1">Linyuan L&#xfc;</a>, <a href="http://arxiv.org/find/physics/1/au:+Yang_A/0/1/0/all/0/1">Ao Yang</a>, <a href="http://arxiv.org/find/physics/1/au:+Stanley_H/0/1/0/all/0/1">H.Eugene Stanley</a>, <a href="http://arxiv.org/find/physics/1/au:+Lambiotte_R/0/1/0/all/0/1">Renaud Lambiotte</a>, <a href="http://arxiv.org/find/physics/1/au:+Evans_T/0/1/0/all/0/1">Tim S.Evans</a>, <a href="http://arxiv.org/find/physics/1/au:+Li_R/0/1/0/all/0/1">Ruiqi Li</a></p><p>Clusters or communities can provide a coarse-grained description of complex
systems at multiple scales, but their detection remains challenging in
practice. Community detection methods often define communities as dense
subgraphs, or subgraphs with few connections in-between, via concepts such as
the cut, conductance, or modularity. Here we consider another perspective built
on the notion of local dominance, where low-degree nodes are assigned to the
basin of influence of high-degree nodes, and design an efficient algorithm
based on local information. Local dominance gives rises to community centers,
and uncovers local hierarchies in the network. Community centers have a larger
degree than their neighbors and are sufficiently distant from other centers.
The strength of our framework is demonstrated on synthesized and empirical
networks with ground-truth community labels. The notion of local dominance and
the associated asymmetric relations between nodes are not restricted to
community detection, and can be utilised in clustering problems, as we
illustrate on networks derived from vector data.
</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-03T00:30:00Z">Monday, October 03 2022, 00:30</time>
        </div>
      </div>
    </article>
  
    
    <h2 class='new-date'>
      <i class='icon-calendar-empty'></i> Sunday, October 02
    </h2>
    

    <article class='item'>
      <div class='item-header'>
        <span class='item-caret'>
          <i class='icon-large icon-caret-down item-collapse item-close item-opened'></i>
          <i class='icon-large icon-caret-right item-expand item-open item-closed'></i>
        </span>
        <span class='item-info'>
          <h3 class='item-title'><a href='https://dstheory.wordpress.com/2022/10/02/wednesday-oct-5th-2022-david-woodruff-from-cmu/'>Wednesday Oct 5th 2022 â David Woodruff from CMU</a></h3>
          <p class='item-feed'>from <a href='https://dstheory.wordpress.com'>Foundation of Data Science - Virtual Talk Series</a></p>
        </span>
      </div>

      <div class='item-body'>
        <div class='item-snippet'>
        
          The first Foundations of Data Science virtual talk of the season, and first of a series on recent advances in adversarially robust streaming, will take place on Wednesday, October 5th at 1:00 PM Pacific Time (16:00 Eastern Time, 22:00 Central European Time, 20:00 UTC). David Woodruff from CMU will give us a survey about âAdversariallyContinue reading "Wednesday Oct 5th 2022 â David Woodruff from&#160;CMU"
        
        </div>

        <div class='item-content item-summary'>
        
          
          <p>The first <a rel="noreferrer noopener" href="https://sites.google.com/view/dstheory/home" target="_blank">Foundations of Data Science</a> virtual talk of the season, and first of a series on recent advances in adversarially robust streaming, will take place on <strong>Wednesday, October 5th</strong> at <strong>1:00 PM Pacific Time</strong> (16:00 Eastern Time, 22:00 Central European Time, 20:00 UTC). <a href="http://www.cs.cmu.edu/~dwoodruf/">David Woodruff</a> from<strong> CMU</strong> will give us a survey about âAdversarially Robust Streaming Algorithms.<em>â</em></p>



<p><a href="https://sites.google.com/view/dstheory">Details of the talk (Zoom link) available here.</a></p>



<p><strong>Abstract</strong>:  A streaming algorithm is given a sequence of items and seeks to compute or approximate some function of this sequence using a small amount of memory. A body of work has been developed over the last two decades, resulting in optimal streaming algorithms for a number of problems. I will start by surveying some of these problems. I will then investigate the adversarial robustness of streaming algorithms. An algorithm is considered robust if its performance guarantees hold even if the stream is chosen adaptively by an adversary that observes the outputs of the algorithm along the stream and can react in an online manner. While deterministic streaming algorithms are inherently robust, many central problems do not admit sublinear-space deterministic algorithms; on the other hand, space-efficient randomized algorithms for these problems are generally not adversarially robust. This raises the question of whether there exist efficient adversarially robust (randomized) streaming algorithms for these problems. I will survey work showing for a number of streaming problems, one can obtain algorithms that are adversarially robust with a small overhead in their memory requirements.</p>



<p>&nbsp;The series is supported by the <a href="https://www.nsf.gov/awardsearch/showAward?AWD_ID=1934846&amp;HistoricalAwards=false">NSF HDR TRIPODS Grant 1934846</a>.</p>
<p class="authors">By dstheory</p>
        
        </div>

        <div class='item-footer'>
          <time class='timeago' datetime="2022-10-02T10:01:30Z">Sunday, October 02 2022, 10:01</time>
        </div>
      </div>
    </article>
  
  </div>

  <script src='js/jquery-2.0.3.min.js'></script>
  <script src="js/jquery.timeago.js" type="text/javascript"></script>
  <script>
    jQuery(document).ready(function() {
      jQuery("time.timeago").timeago();
    });
  </script>
  <script src='js/blank.js'></script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>
